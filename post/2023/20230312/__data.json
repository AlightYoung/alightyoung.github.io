{"type":"data","nodes":[{"type":"data","data":[{"link2PostContent":1,"link2PostMeta":92},{"post/2019/20190922/":2,"post/2019/20190923/":3,"post/2019/20191001/":4,"post/2019/20191011/":5,"post/2019/20191015/":6,"post/2019/20191021/":7,"post/2019/20191024/":8,"post/2019/20191028/":9,"post/2019/20191103/":10,"post/2019/20191106/":11,"post/2019/20191110/":12,"post/2019/20191112/":13,"post/2019/20191116/":14,"post/2019/20191120/":15,"post/2019/20191121/":16,"post/2019/20191123/":17,"post/2019/20191127/":18,"post/2019/20191128/":19,"post/2019/20191129/":20,"post/2019/20191202/":21,"post/2019/20191206/":22,"post/2019/20191210/":23,"post/2019/20191215/":24,"post/2019/20191220/":25,"post/2019/20191228/":26,"post/2020/20200101/":27,"post/2020/20200108/":28,"post/2020/20200115/":29,"post/2020/20200122/":30,"post/2020/20200130/":31,"post/2020/20200605/":32,"post/2020/20200606/":33,"post/2020/20200607/":34,"post/2020/20200608/":35,"post/2020/20200609/":36,"post/2020/20200610/":37,"post/2020/20200611/":38,"post/2020/20200612/":39,"post/2020/20200625/":40,"post/2020/20200628/":41,"post/2020/20200713/":42,"post/2020/20200725/":43,"post/2020/20200731/":44,"post/2020/20200810/":45,"post/2020/20201028/":46,"post/2020/20201029/":47,"post/2020/20201107/":48,"post/2020/20201122/":49,"post/2021/20210321/":50,"post/2021/20210326/":51,"post/2021/20210330/":52,"post/2021/20210408/":53,"post/2021/20210419/":54,"post/2021/20210425/":55,"post/2021/20210508/":56,"post/2021/20210510/":57,"post/2021/20210518/":58,"post/2021/20210629/":59,"post/2021/20210630/":60,"post/2021/20210706/":61,"post/2021/20210709/":62,"post/2021/20210710/":63,"post/2021/20210711/":64,"post/2021/20210720/":65,"post/2021/20210725/":66,"post/2021/20210728/":67,"post/2021/20210731/":68,"post/2021/20210801/":69,"post/2021/20210802/":70,"post/2021/20210803/":71,"post/2021/20210804/":72,"post/2021/20210812/":73,"post/2021/20210813/":74,"post/2021/20210816/":75,"post/2021/20211118/":76,"post/2021/20211119/":77,"post/2022/20220223/":78,"post/2022/20220326/":79,"post/2022/20220526/":80,"post/2022/20220601/":81,"post/2022/20220810/":82,"post/2022/20220829/":83,"post/2022/20221009/":84,"post/2022/20221031/":85,"post/2022/20221209/":86,"post/2023/20230312/":87,"post/2023/20230805/":88,"post/2024/20240225/":89,"post/2024/20240310/":90,"post/2024/20240311/":91},"\n### 开始\n\n新建的第一篇文章,就写写hexo的一些东西吧\n\nhexo的本地安装到部署到github pages\n\n还有主题,~~以及gitalk的配置~~\n\n### 准备\n\nhexo的安装十分方便,官网也讲的非常清楚,需要 NodeJs 和 git 环境,这里不再赘述,不清楚的可以查看 [官方文档](https://hexo.io/docs/)\n\n当准备工作完成之后,就可以直接使用npm来安装hexo\n\n```bash\n# npm的仓库切换\n# 由于npm的仓库默认是国外的 所以很多人考虑使用cnpm\n# 但是cnpm安装可能会出现问题 所以这里推荐一下nrm\n\n# 安装nrm\nnpm install -g nrm\n# 查看可用仓库\nnrm ls\n# 使用cnpm仓库\nnrm use cnpm\n# 查看当前仓库\nnpm get registry\n# 安装hexo\nnpm install -g hexo-cli\n```\n\n之后就是初始化的过程\n\n```bash\nhexo init \u003Cfolder>\ncd \u003Cfolder>\nnpm install\n```\n\n### 配置\n\n新建完成后，指定文件夹的目录如下：\n\n```\n.\n├── _config.yml\n├── package.json\n├── scaffolds\n├── source\n|   ├── _drafts\n|   └── _posts\n└── themes\n```\n\n开始的话,我们需要关注的就是 `config.yml`, 这个是全局的一些配置文件.主题文件在themes文件夹,默认的主题是landspace,如果想切换主题可以去github搜索,或者直接查看[hexo官方主题](https://hexo.io/themes),一般的话更换主题都是将主题文件安装到themes文件夹下,然后在全局配置文件中更改主题。\n\n至于评论系统的,这里使用的是gitalk(Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。),为什么是gitalk呢?因为这个主题的配置文件就是配置的gitalk.其他主题配置的评论系统也许是别的,主题文档应该会有说明,可以根据文档自行配置.因为评论插件太多了,这个就自行百度吧。\n\n### 新建博客\n\n新建博客的话,使用 `hexo new` 命令即可,也可以直接在 *source/_posts* 文件夹下新建 markdown 文件直接编写.\n\n```bash\nhexo new (title)\n```\n\n如果想在部署前预览的话,使用 `hexo s` 命令即可通过 [http://localhost:4000](http://localhost:4000) 查看效果。\n\n```bash\nhexo s\n```\n\n### 部署\n\n部署到github pages的话,直接在全局配置文件config.yml修改deploy配置\n\n```yml\ndeploy:\n type: git\n repo: https://github.com/github名称/github名称.github.io.git\n branch: master\n```\n\n然后的话还需要安装一个插件才能部署\n\n```\nnpm install hexo-deployer-git --save\n```\n\n之后执行以下命令即可部署到github pages\n\n```\nhexo g && hexo d\n```\n\n### 最后\n\n接下来就是愉快的水博客环节~\n\n\n> 个人配置\n> 主题: [hexo-theme-next](https://github.com/next-theme/hexo-theme-next)\n>\n> 备份: [hexo-git-backup](https://github.com/coneycode/hexo-git-backup)\n>\n> 评论: [valine](https://valine.js.org/)\n>\n> 模型: [hexo-helper-live2d](https://github.com/EYHN/hexo-helper-live2d)\n>\n> 邮件通知: [Valine-Admin](https://github.com/DesertsP/Valine-Admin)\n>\n> 微信qq通知: [Valine-Admin-Server](https://github.com/Dreamy-TZK/Valine-Admin-Server)\n>\n> leancloud流控解决方案: [WakeLeanCloud](https://github.com/blogimg/WakeLeanCloud)\n","\n### 开始\n\n其实一直有体验Linux的想法，只是以前bios设了密码，后来给忘了，最近突然尝试猜了一下，居然对了！天意！双系统启动！\n\n好，说整就整！\n\n### Ubuntu的安装\n\nUbuntu作为当红Linux发行版，好就它了！\n\n本地是win10环境，上网找了很多win10+Ubuntu的双系统安装教程，好像还和是不是单硬盘、支不支持uefi有关，个人认为这个教程讲的十分详细 -> [传送门](https://www.cnblogs.com/masbay/p/10745170.html)\n\n我这边是uefi+单硬盘，所以大概说一下，其他情况可以参考上面那篇博客。\n\n1. 在win10中分出一个空白分区留给Linux\n\n    win10专业版的话就是 此电脑右键-管理-磁盘管理 应该就能看到磁盘的各个分区，如果只有C盘的话直接压缩卷即可，如果自己分了cde的话就把最后那个分区删除卷也行，记得备份！记得备份！记得备份，我这边分了100g左右。\n2. 将Ubuntu镜像写入U盘\n\n    准备一个U盘，下载并安装软碟通，Ubuntu镜像直接在官网下载的桌面版18.04LTS。然后就是用软碟通把镜像刷入U盘，等就完事了。\n3. 安装Ubuntu\n\n    接下来，就是正常的BIOS设置U盘先加载，哦对了，还要关了sucure boot，我也不知道为啥，关就完事了。然后会进入Ubuntu的安装界面，直接选择安装，记得断网安装，不然的下载一个世纪的文件（泪）。安装的话有大概这么一些选项\n    1. 语言选择（自己看着选）\n    2. 安装 （有个在安装中下载更新的，记得断网，最小安装就行了）\n    3. 安装类型（好像会提示和win10作为双系统安装，应该也没事，反正我点的自定义。）\n    4. 分区（大佬说的 /boot 分200mb  /home 35g  其他全给/ ,有些教程分区分了很多，反正我就这样分的，我8g内存，感觉应该够。就没分swap，后面发现自动分了2g，问题不大，赶紧进入系统才是王道）\n\n之后就是系统的一些简单默认配置了，都能看懂，不多说了\n\n### 初体验\n\n安装完成之后就是拔U盘，重启！默认是grub引导双系统界面，应该能看到Ubuntu和windows，选择Ubuntu，开始！\n\n对了 有些因为显卡原因，在Ubuntu重启会死机，在软件更新器点设置，有个附加驱动，会自动搜索可用驱动，装上驱动就好了，妈妈再也不用担心我死机了：）\n\n### 简单配置\n\n在瞎点了几下之后，差不多可以开始一些简单的配置了，比如换源，用阿里云就完事了，中文输入法，直接firefox搜搜狗Linux，有安装教程。\n\n下载的话好像挺多人用uget配合aria2下载，百度就完事了。\n\n对了如果下载jetbrains全家桶的话建议用toolbox，稳定，下载速度也可以。\n\n办公的话wps，听歌的话用网易云。qq用的deepin wine版本的，比原版wine好用那么一点---[deepin wine传送门](https://github.com/wszqkzqk/deepin-wine-ubuntu)，美化的话，慢慢百度吧，怎么舒服怎么来。\n\n### 最后\n\n差不多了，接下来就是慢慢折腾了，养老的话也是很舒适的。\n\n### 2019/9/27更新\n\nubuntu已被玩坏（gnome依赖可能出问题了...），转身投入deepin（15.11）的怀抱。\n\n自带 chrome 搜狗输入法 wps 深度截图 网易云 qq等\n\n开箱即用的体验 界面的话 有好有坏\n\n- 好处：界面还算漂亮 dock支持win和默认方案 grub不算难看 省去了换refind的时间\n- 坏处：字体渲染可能比Ubuntu差点（maybe）默认终端太丑了 美化的话 慢慢折腾吧\n\n顺带说一下 开关机还有音效 太蠢了！\n\n### END\n\n双系统引导关了,转身投入win怀抱,最后一次更新,Linux果然还是太折腾了,windows真香 :)\n\n\n","\n### 开始\n\n前端时间Java13好像发布了,正好看到有篇文章记录了Java13中的5个特性,就拿过来水一下了. :)[传送门](https://zhuanlan.zhihu.com/p/82637772).\n\n### Dynamic CDS Archives\n这一特性是在JEP310：Application Class-Data Sharing基础上扩展而来的，Dynamic CDS Archives中的CDS指的就是Class-Data Sharing。\n\n那么，这个JEP310是个啥东西呢？\n\n我们知道在同一个物理机／虚拟机上启动多个JVM时，如果每个虚拟机都单独装载自己需要的所有类，启动成本和内存占用是比较高的。所以Java团队引入了CDS的概念，通过把一些核心类在每个JVM间共享，每个JVM只需要装载自己的应用类，启动时间减少了，另外核心类是共享的，所以JVM的内存占用也减少了。\n\nCDS 只能作用于 Boot Class Loader 加载的类，不能作用于 App Class Loader 或者自定义的 Class Loader 加载的类。\n\n在 Java 10 中，则将 CDS 扩展为 AppCDS，顾名思义，AppCDS 不止能够作用于 Boot Class Loader了，App Class Loader 和自定义的 Class Loader 也都能够起作用，大大加大了 CDS 的适用范围。也就说开发自定义的类也可以装载给多个JVM共享了。\n\nJava 10中包含的JEP310的通过跨不同Java进程共享公共类元数据来减少了内存占用和改进了启动时间。\n\n但是，JEP310中，使用AppCDS的过程还是比较复杂的，需要有三个步骤：\n> 1、决定要 Dump 哪些 Class\n>\n> 2、将类的内存 Dump 到归档文件中\n>\n> 3、使用 Dump 出来的归档文件加快应用启动速度\n\n这一次的JDK 13中的JEP 350 ，在JEP310的基础上，又做了一些扩展。允许在Java应用程序执行结束时动态归档类，归档类将包括默认的基础层 CDS（class data-sharing）存档中不存在的所有已加载的应用程序类和库类。\n\n也就是说，在Java 13中再使用AppCDS的时候，就不在需要这么复杂了。\n### ZGC: Uncommit Unused Memory\n在讨论这个问题之前，想先问一个问题，JVM的GC释放的内存会还给操作系统吗？\n\nGC后的内存如何处置，其实是取决于不同的垃圾回收器的。因为把内存还给OS，意味着要调整JVM的堆大小，这个过程是比较耗费资源的。\n\n在JDK 11中，Java引入了ZGC，这是一款可伸缩的低延迟垃圾收集器，但是当时只是实验性的。并且，ZGC释放的内存是不会还给操作系统的。\n![image](https://alightyoung.gitee.io/static/img/6.jpg)\n\n而在Java 13中，JEP 351再次对ZGC做了增强，本次 ZGC 可以将未使用的堆内存返回给操作系统。之所以引入这个特性，是因为如今有很多场景中内存是比较昂贵的资源，在以下情况中，将内存还给操作系统还是很有必要的：\n\n1. 那些需要根据使用量付费的容器\n2. 应用程序可能长时间处于空闲状态并与许多其他应用程序共享或竞争资源的环境。\n3. 应用程序在执行期间可能有非常不同的堆空间需求。例如，启动期间所需的堆可能大于稍后在稳定状态执行期间所需的堆。\n\n### Reimplement the Legacy Socket API\n\n使用易于维护和调试的更简单、更现代的实现替换 java.net.Socket 和 java.net.ServerSocket API。\n\njava.net.Socket和java.net.ServerSocket的实现非常古老，这个JEP为它们引入了一个现代的实现。现代实现是Java 13中的默认实现，但是旧的实现还没有删除，可以通过设置系统属性jdk.net.usePlainSocketImpl来使用它们。\n\n运行一个实例化Socket和ServerSocket的类将显示这个调试输出。这是默认的(新的):\n\n```bash\njava -XX:+TraceClassLoading JEP353  | grep Socket\n[0.033s][info   ][class,load] java.net.Socket source: jrt:/java.base\n[0.035s][info   ][class,load] java.net.SocketOptions source: jrt:/java.base\n[0.035s][info   ][class,load] java.net.SocketImpl source: jrt:/java.base\n[0.039s][info   ][class,load] java.net.SocketImpl$$Lambda$1/0x0000000800b50840 source: java.net.SocketImpl\n[0.042s][info   ][class,load] sun.net.PlatformSocketImpl source: jrt:/java.base\n[0.042s][info   ][class,load] sun.nio.ch.NioSocketImpl source: jrt:/java.base\n[0.043s][info   ][class,load] sun.nio.ch.SocketDispatcher source: jrt:/java.base\n[0.044s][info   ][class,load] java.net.DelegatingSocketImpl source: jrt:/java.base\n[0.044s][info   ][class,load] java.net.SocksSocketImpl source: jrt:/java.base\n[0.044s][info   ][class,load] java.net.ServerSocket source: jrt:/java.base\n[0.045s][info   ][class,load] jdk.internal.access.JavaNetSocketAccess source: jrt:/java.base\n[0.045s][info   ][class,load] java.net.ServerSocket$1 source: jrt:/java.base\n```\n\n上面输出的sun.nio.ch.NioSocketImpl就是新提供的实现。\n\n如果使用旧的实现也是可以的（指定参数jdk.net.usePlainSocketImpl）：\n\n```bash\n$ java -Djdk.net.usePlainSocketImpl -XX:+TraceClassLoading JEP353  | grep Socket\n[0.037s][info   ][class,load] java.net.Socket source: jrt:/java.base\n[0.039s][info   ][class,load] java.net.SocketOptions source: jrt:/java.base\n[0.039s][info   ][class,load] java.net.SocketImpl source: jrt:/java.base\n[0.043s][info   ][class,load] java.net.SocketImpl$$Lambda$1/0x0000000800b50840 source: java.net.SocketImpl\n[0.046s][info   ][class,load] sun.net.PlatformSocketImpl source: jrt:/java.base\n[0.047s][info   ][class,load] java.net.AbstractPlainSocketImpl source: jrt:/java.base\n[0.047s][info   ][class,load] java.net.PlainSocketImpl source: jrt:/java.base\n[0.047s][info   ][class,load] java.net.AbstractPlainSocketImpl$1 source: jrt:/java.base\n[0.047s][info   ][class,load] sun.net.ext.ExtendedSocketOptions source: jrt:/java.base\n[0.047s][info   ][class,load] jdk.net.ExtendedSocketOptions source: jrt:/jdk.net\n[0.047s][info   ][class,load] java.net.SocketOption source: jrt:/java.base\n[0.047s][info   ][class,load] jdk.net.ExtendedSocketOptions$ExtSocketOption source: jrt:/jdk.net\n[0.047s][info   ][class,load] jdk.net.SocketFlow source: jrt:/jdk.net\n[0.047s][info   ][class,load] jdk.net.ExtendedSocketOptions$PlatformSocketOptions source: jrt:/jdk.net\n[0.047s][info   ][class,load] jdk.net.ExtendedSocketOptions$PlatformSocketOptions$1 source: jrt:/jdk.net\n[0.048s][info   ][class,load] jdk.net.LinuxSocketOptions source: jrt:/jdk.net\n[0.048s][info   ][class,load] jdk.net.LinuxSocketOptions$$Lambda$2/0x0000000800b51040 source: jdk.net.LinuxSocketOptions\n[0.049s][info   ][class,load] jdk.net.ExtendedSocketOptions$1 source: jrt:/jdk.net\n[0.049s][info   ][class,load] java.net.StandardSocketOptions source: jrt:/java.base\n[0.049s][info   ][class,load] java.net.StandardSocketOptions$StdSocketOption source: jrt:/java.base\n[0.051s][info   ][class,load] sun.net.ext.ExtendedSocketOptions$$Lambda$3/0x0000000800b51440 source: sun.net.ext.ExtendedSocketOptions\n[0.057s][info   ][class,load] java.net.DelegatingSocketImpl source: jrt:/java.base\n[0.057s][info   ][class,load] java.net.SocksSocketImpl source: jrt:/java.base\n[0.058s][info   ][class,load] java.net.ServerSocket source: jrt:/java.base\n[0.058s][info   ][class,load] jdk.internal.access.JavaNetSocketAccess source: jrt:/java.base\n[0.058s][info   ][class,load] java.net.ServerSocket$1 source: jrt:/java.base\n```\n\n上面的结果中，旧的实现java.net.PlainSocketImpl被用到了。\n\n### Switch Expressions (Preview)\n\n在JDK 12中引入了Switch表达式作为预览特性。JEP 354修改了这个特性，它引入了yield语句，用于返回值。这意味着，switch表达式(返回值)应该使用yield, switch语句(不返回值)应该使用break。\n\n在以前，我们想要在switch中返回内容，还是比较麻烦的，一般语法如下：\n\n```java\nint i;\nswitch (x) {\n    case \"1\":\n        i=1;\n        break;\n    case \"2\":\n        i=2;\n        break;\n    default:\n        i = x.length();\n        break;\n}\n```\n\n在JDK13中使用以下语法：\n\n```java\nint i = switch (x) {\n    case \"1\" -> 1;\n    case \"2\" -> 2;\n    default -> {\n        int len = args[1].length();\n        yield len;\n    }\n};\n```\n\n或者\n\n```java\nint i = switch (x) {\n    case \"1\": yield 1;\n    case \"2\": yield 2;\n    default: {\n        int len = args[1].length();\n        yield len;\n    }\n};\n```\n\n在这之后，switch中就多了一个关键字用于跳出switch块了，那就是yield，他用于返回一个值。和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。\n\n### Text Blocks (Preview)\n\n在JDK 12中引入了Raw String Literals特性，但在发布之前就放弃了。这个JEP在引入多行字符串文字（text block）在意义上是类似的。\n\ntext block，文本块，是一个多行字符串文字，它避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串，并在需要时让开发人员控制格式。\n\n我们以前从外部copy一段文本串到Java中，会被自动转义，如有一段以下字符串：\n\n```html\n\u003Chtml>\n  \u003Cbody>\n      \u003Cp>Hello, world\u003C/p>\n  \u003C/body>\n\u003C/html>\n```\n\n将其复制到Java的字符串中，会展示成以下内容：\n\n```java\n\"\u003Chtml>\\n\" +\n\"    \u003Cbody>\\n\" +\n\"        \u003Cp>Hello, world\u003C/p>\\n\" +\n\"    \u003C/body>\\n\" +\n\"\u003C/html>\\n\";\n```\n\n即被自动进行了转义，这样的字符串看起来不是很直观，在JDK 13中，就可以使用以下语法了：\n\n```java\n\"\"\"\n\u003Chtml>\n  \u003Cbody>\n      \u003Cp>Hello, world\u003C/p>\n  \u003C/body>\n\u003C/html>\n\"\"\";\n```\n\n使用\"\"\"作为文本块的开始符合结束符，在其中就可以放置多行的字符串，不需要进行任何转义。看起来就十分清爽了。\n\n如常见的SQL语句：\n\n```java\nString query = \"\"\"\n    SELECT `EMP_ID`, `LAST_NAME` FROM `EMPLOYEE_TB`\n    WHERE `CITY` = 'INDIANAPOLIS'\n    ORDER BY `EMP_ID`, `LAST_NAME`;\n\"\"\";\n```\n\n看起来就比较直观，清爽了。\n\n### 最后\n水完了 over!\n","\n### What is Apache Shiro\n\nApacheShiro™ 是一个功能强大且易于使用的 Java 安全框架，它执行身份验证、授权、加密和会话管理。使用 Shiro 易于理解的 API，您可以快速轻松地获得任何应用程序——从最小的移动应用程序到最大的 Web 和企业应用程序。\n\n### Apache Shiro Features\n\nApache Shiro 是具有许多功能的全面的应用程序安全框架。下图显示了 Shiro 集中精力的地方\n![shiro](https://alightyoung.gitee.io/static/img/29.png)\nShiro 以 Shiro 开发团队所谓的“应用程序安全性的四个基石”为目标-身份验证，授权，会话管理和密码学：\n\n-   Authentication: 有时称为\"登录\",这是证明用户是他们所说的身份的行为.\n-   Authorization: 访问控制的过程,即确定“谁”有权访问\"什么\".\n-   Session Management:即使在非 Web 或 EJB 应用程序中,也可以管理用户特定的会话.\n-   Cryptography: 使用密码算法保持数据安全，同时仍然易于使用。\n\n### shiro.ini\n\nshiro.ini 是 shiro 中的配置文件，以下是常见配置的解析\n\n**[main]** 用于配置应用程序的 SecurityManager 实例及任何它的依赖组件(如 realm)的地方.\n\n```ini\n[main]\nmyRealm=*.*.*.*realm\n#依赖注入\nsecurityManager.realm=$MyRealm\n```\n\n**[users]** 用于配置静态用户\n\n```ini\n[users]\nzhangsan=1111\nlisi=1111,role1,role2\n```\n\n**[roles]** 用于定义角色\n\n```ini\n[users]\nzhangsan=1111,role1\n[roles]\nrole1=user:add\n```\n\n### Authentication\n\n登录验证及异常捕获:\n\n```java\n    // 1 创建SecurityManager工厂\n    Factory\u003CSecurityManager> factory  = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\n    // 2 通过securityManager工厂获取securityManager实例\n    SecurityManager securityManager = factory.getInstance();\n    // 3 将securityManager对象设置到运行环境中\n    SecurityUtils.setSecurityManager(securityManager);\n    // 4 通过securityUtils获取subject\n    Subject subject = SecurityUtils.getSubject();\n    // 5 用户名 zhangsan 密码 1111 (表示用户登陆时输入的登录信息)\n    // shiro.ini的信息为数据库的信息\n    UsernamePasswordToken token = new UsernamePasswordToken(\"zhangsan\",\"1111\");\n    try {\n        // 进行用户身份验证\n        subject.login(token);\n        // 通过subject判断用户是否通过验证\n        if(subject.isAuthenticated()){\n            System.out.println(\"登录成功\");\n        }\n    } catch (AuthenticationException e) { //可以进行详细捕获\n        e.printStackTrace();\n        System.out.println(\"登录失败\");\n    }\n```\n\n关于异常的详细捕获 以下是 AuthenticationException 的子类关系,可根据不同的异常进行不同的处理.\n\n-   **AuthenticationException**\n    -   AccountException\n        -   DisabledAccountException\n            -   LockedAccountException\n        -   ConcurrentAccessException\n        -   ExcessiveAttemptsException\n        -   UnknownAccountException\n    -   CredentialsException\n        -   IncorrectCredentialsException\n        -   ExpiredCredentialsException\n    -   UnsupportedTokenException\n\n### JDBC Realm\n\n1. shiro 完成认证的话默认使用的是 ini realm,如需使用其他 realm,则需要进行相关配置\n2. 使用 jdbc realm 来完成身份认证\n\n使用 jdbc realm 主要是在 shiro.ini 配置 realm\n\n```ini\n[main]\ndataSource=com.mchange.v2.c3p0.ComboPooledDataSource\ndataSource.driverClass=com.mysql.cj.jdbc.Driver\ndataSource.jdbcUrl=jdbc:mysql://localhost:3306/[数据库名]?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=UTC\ndataSource.user=[数据库账户名]\ndataSource.password=[数据库密码]\njdbcRealm=org.apache.shiro.realm.jdbc.JdbcRealm\njdbcRealm.dataSource=$dataSource\nsecurityManager.realm=$jdbcRealm\n```\n\n值得一提的是 mysql 驱动为 8.0 以上的话,driverClass 才为 com.mysql.cj.jdbc.Driver，以前的版本的话则是 com.mysql.jdbc.Driver，而且 8.0+的 url 也必须加上一些设置,否则会抛出异常,无法连接到数据库.\n\n### Authentication Stratery\n\nAuthenticationStratery 是 shiro 中定义的验证多 realm 情况的验证策略的接口\n它具有三种实现验证策略,基本上能解决大部分问题\n\n> **FirstSuccessfulStrategy**:只要有一个 Realm 验证成功即可，只返回第一个 Realm 身份验证成功的认证信息，其他的忽略。\n>\n> **AtLeastOneSuccessfulStrategy**:只要有一个 Realm 验证成功即可，和 FirstSuccessfulStrategy 不同，将返回所有 Realm 身份校验成功的认证信息。\n>\n> **AllSuccessfulStrategy**:所有 Realm 验证成功才算成功，且返回所有 Realm 身份认证成功的认证信息，如果有一个失败就失败了。\n\n关于多 realm 配置\n\n```\nsecurityManager.realms=$jdbcRealm,$jdbcRealm1\n```\n\n验证策略配置\n\n```ini\n# 配置验证策略\n## eg\n### authenticationStrategy=org.apache.shiro.authc.pam.AtLeastOneSuccessfulStrategy\n### authenticationStrategy=org.apache.shiro.authc.pam.AllSuccessfulStrategy\n### authenticationStrategy=org.apache.shiro.authc.pam.FirstSuccessfulStrategy\nauthenticationStrategy= org.apache.shiro.authc.pam.FirstSuccessfulStrategy\n# 设置验证策略\nsecurityManager.authenticator.authenticationStrategy=$authenticationStrategy\n```\n\n### Custom Realm\n\n有时 jdbcRealm 的局限性有些时候并不能支持我们完成需求,这个时候便需要自定义 realm\n\n自定义 realm 需要实现 realm 接口,shiro 自身已经提供了一些实现类 eg. AuthenticatingRealm(实现了获取身份信息的功能)&AuthorizingRealm(实现了获取权限信息的功能).一般自定义 realm 会选择继承 AuthorizingRealm,因为该类既提供了身份认证的自定义方法,也能实现授权的自定义方法.\n\n**example:**\n\n```java\npublic class MyRealm extends AuthorizingRealm {\n\n    @Override\n    public String getName() {\n        return \"myRealm\";\n    }\n    //完成身份认证并返回认证信息,认证失败返回null\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        //获取用户输入的用户名\n        String username = (String)token.getPrincipal();\n        System.out.println(\"username---->\"+username);\n        //根据用户名到数据库查询密码信息\n        //todo... (jdbc)\n        // if return pwd=1111\n        String pwd = \"1111\";\n        //将查询的信息封装到SimpleAuthenticationInfo中\n        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username,pwd,getName());\n        return info;\n    }\n    //授权信息\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        return null;\n    }\n}\n```\n\nshiro 本身并不会维护数据,它只负责从相关接口接收传递来的数据进行验证授权流程.\n\n### Hash Algorithm\n\nHash algorithm 也被称为散列算法,一般用于生成一段文本的摘要信息,散列算法不可逆,将内容可以生成摘要,无法将摘要转成原始内容.散列算法常用于对密码进行散列.在 shiro 中,也定义了一些常用的散列算法,eg：md2,md5,sha1,sha2(sha256,sha384,sha512).并且可以加入 salt (一般散列算法需要提供一个 salt（盐）与原始内容生成摘要信息，这样做的目的是为了安全性 ) ,以下是 md5 的常见用法.\n\n```java\n    //使用md5加密算法(salt)\n    Md5Hash md5Hash =  new Md5Hash(\"1111\");\n    System.out.println(md5Hash);\n    //加入salt(source,salt)\n    md5Hash = new Md5Hash(\"1111\",\"xxx\");\n    System.out.println(md5Hash);\n    //加入迭代次数(source,salt,hashIterations)\n    md5Hash = new Md5Hash(\"1111\",\"xxx\",2);\n    System.out.println(md5Hash);\n```\n\n自定义 realm 中使用 hash algorithm\n\n首先在自定义 realm 进行配置\n\n```java\n    //完成身份认证并返回认证信息,认证失败返回null\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        //获取用户输入的用户名\n        String username = (String)token.getPrincipal();\n        System.out.println(\"username---->\"+username);\n\n        //根据用户名到数据库查询密码信息\n        //todo... (jdbc)\n\n        // if return pwd=1111(数据库返回pwd) & pwd salt=xxx & Iterations=2(shiro.ini中配置)\n        //进行md5加密赋值给pwd 此处省略new md5Hash(\"1111\",\"xxx\",2).toString();\n        String md5Hash = \"2588ac6dd96981c619b6b6a94fb9ab59\";\n        String salt = \"xxx\";\n\n        //将查询的信息封装到SimpleAuthenticationInfo中\n        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username,md5Hash, ByteSource.Util.bytes(salt),getName());\n\n        return info;\n    }\n```\n\nshiro.ini 配置\n\n```ini\n[main]\n# 配置 credentialsMatcher\ncredentialsMatcher= org.apache.shiro.authc.credential.HashedCredentialsMatcher\ncredentialsMatcher.hashAlgorithmName=md5\ncredentialsMatcher.hashIterations=2\n# 配置自定义realm\n## eg: myRealm=com.xxx.realm.MyRealm\nmyRealm=MyRealm\nmyRealm.credentialsMatcher=$credentialsMatcher\n# 设置realm\nsecurityManager.realm=$myRealm\n```\n\n### Authorization\n\n1. 授权，也称为访问控制，是管理对资源的访问的过程。换句话说，控制谁可以访问应用程序。\n2. 权限粒度:分为粗细两种粒度,shiro 管理的是粗粒度的权限,细粒度的话一般需要结合业务进行设计,所以权限框架一般不会设计细粒度的权限管理.\n3. 角色:含有相同权限的集合,方便管理.\n4. 权限表示规则: 资源:操作:实例.可以用通配符表示:\n    1. user:add 表示对 user 有添加权限.\n    2. user:\\* 表示具有所有操作的权限.\n    3. user:delete:100 表示对 user 标识为 100 的记录具有删除的权限.\n5. shiro 中的授权顺序\n\n![shiro中的权限流程](https://alightyoung.gitee.io/static/img/30.png)\n\n> 步骤 1：应用程序或框架代码调用任何的 Subject hasRole*，checkRole*，isPermitted*，或 checkPermission*方法的变体，传递是必需的任何许可或角色表示。\n>\n> 步骤 2：该 Subject 情况下，典型地是 DelegatingSubject（或子类）委托给应用程序的 SecurityManager 调用 securityManager 的几乎相同的各自 hasRole*，checkRole*，isPermitted*，或 checkPermission*方法变体（所述 securityManager 实现了 org.apache.shiro.authz.Authorizer 接口，它定义了所有特定主题授权方法）。\n>\n> 步骤 3：本 SecurityManager，作为一个基本的“伞”分量，继电器/委托给其内部 org.apache.shiro.authz.Authorizer 通过调用实例 authorizer 的各自 hasRole*，checkRole*，isPermitted*，或 checkPermission*方法。该 authorizer 实例默认情况下是一个 ModularRealmAuthorizer 实例，它支持 Realm 在任何授权操作期间协调一个或多个实例。\n>\n> 步骤 4：Realm 检查每个已配置的配置是否实现相同的 Authorizer 接口。如果是这样，该领域的各自的 hasRole*，checkRole*，isPermitted*，或 checkPermission*方法被调用。\n\n6. 授权实现\n\n**编码实现**\n\nshiro.ini 配置\n\n```ini\n[users]\nzhangsan=1111,role1\nlisi=1111,role2\n```\n\n测试类\n\n```java\npublic class AuthorizationDemo {\n    public static void main(String[] args) {\n        Factory\u003CSecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\n        SecurityManager securityManager = factory.getInstance();\n        SecurityUtils.setSecurityManager(securityManager);\n        Subject subject = SecurityUtils.getSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zhangsan\",\"1111\");\n        try {\n            subject.login(token);\n            if(subject.isAuthenticated()){\n                System.out.println(\"认证成功\");\n                //基于角色的授权判断\n                if(subject.hasRole(\"role1\")){\n                    System.out.println(\"授权成功\");\n                }else{\n                    System.out.println(\"授权失败\");\n                }\n                //hasRoles(list)的授权判断\n                //subject.hasRoles(Arrays.asList(\"role1\",\"role2\"));\n                //checkRole的授权判断,授权失败则抛出UnauthorizedException异常,同样可使用checkRoles()判断多个角色\n                //subject.checkRole(\"role2\");\n                //subject.checkRoles(\"role1\",\"role2\");\n                //基于资源的判断\n                //System.out.println(subject.isPermitted(\"user:select\"));\n                //System.out.println(subject.isPermittedAll(\"user:*\"));\n                //checkPermission判断 类似checkRole,授权失败也会抛出UnauthorizedException异常\n                //subject.checkPermission(\"user:add\");\n                //subject.checkPermissions(\"user:*\");\n            }\n        } catch (AuthenticationException e) {\n            e.printStackTrace();\n            System.out.println(\"认证失败\");\n        }\n    }\n}\n```\n\n**注解实现**\n\n![注解结构](https://alightyoung.gitee.io/static/img/31.png)\n\n| 注解                    | 意义                                                    | 案例                        |\n| ------                  | ---------                                               | -----------                |\n| @RequiresAuthentication | 验证用户是否登录                                         |       无                    |\n| @RequiresUser           | 当前用户已经验证过了或则记住我了                           |       无                   |\n| @RequiresGuest          | 是否是游客身份                                           |       无                   |\n| @RequiresRoles          | 判断 subject 中有 aRoleName 角色才可以访问方法 someMethod | `@RequiresRoles({\"admin\"})`  |\n| @RequiresPermissions    | 需要拥有权限   | `@RequiresPermissions({\"file:read\", \"write:aFile.txt\"} )`             |\n\n__jsp标签实现__\n\n```\n\u003C%--shiro 标签 --%>\n\u003C%@taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %>\n```\n\n|标签|意义|\n|----|----|\n|`\u003Cshiro:authenticated>`|登录之后|\n|`\u003Cshiro:notAuthenticated>`|不在登录状态时|\n|`\u003Cshiro:guest>`|用户在没有RememberMe时|\n|`\u003Cshiro:user>`|用户在RememberMe时|\n|`\u003Cshiro:hasAnyRoles name=\"abc,123\" >`|在有abc或者123角色时|\n|`\u003Cshiro:hasRole name=\"abc\">`|拥有角色abc|\n|`\u003Cshiro:lacksRole name=\"abc\">`|没有角色abc|\n|`\u003Cshiro:hasPermission name=\"abc\">`|拥有权限资源abc|\n|`\u003Cshiro:lacksPermission name=\"abc\">`|没有abc权限资源|\n|`\u003Cshiro:principal>`|默认显示用户名称|\n\n_关于自定义realm中的设置权限_\n可通过`SimpleAuthorizationInfo`类的方法进行权限或者角色的添加\n最后返回info信息即可\n\n```java\n//授权信息\n@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n    String username = principalCollection.getPrimaryPrincipal().toString();\n    System.out.println(username);\n    List\u003CString> permission = new ArrayList\u003CString>();\n    permission.add(\"user:add\");\n    permission.add(\"user:update\");\n    permission.add(\"user:delete\");\n    permission.add(\"user:find\");\n    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n    info.addRole(\"role1\");\n    for (String perms:permission){\n        info.addStringPermission(perms);\n    }\n    return info;\n}\n```\n\n### Integrations\n\n___shiro与ssm的整合___\n\nweb.xml添加shiro配置\n\n```xml\n\u003C!--shiro web.xml配置-->\n\n\u003C!--shiroFilter配置 通过代理配置 对象是spring容器创建的 交与servlet容器管理-->\n\u003Cfilter>\n    \u003Cfilter-name>shiroFilter\u003C/filter-name>\n    \u003Cfilter-class>org.springframework.web.filter.DelegatingFilterProxy\u003C/filter-class>\n    \u003Cinit-param>\n        \u003C!--将bean生命周期交与servlet管理-->\n        \u003Cparam-name>targetFilterLifecycle\u003C/param-name>\n        \u003Cparam-value>true\u003C/param-value>\n    \u003C/init-param>\n    \u003Cinit-param>\n        \u003C!--表示在spring容器中bean的id交与servlet管理-->\n        \u003C!--不配置默认值与filter的Name一致,此处配置只做示例-->\n        \u003Cparam-name>targetBeanName\u003C/param-name>\n        \u003Cparam-value>shiroFilter\u003C/param-value>\n    \u003C/init-param>\n\u003C/filter>\n\n\u003Cfilter-mapping>\n    \u003Cfilter-name>shiroFilter\u003C/filter-name>\n    \u003Curl-pattern>/*\u003C/url-pattern>\n\u003C/filter-mapping>\n```\n\napplicationContext.xml中添加shiro配置\n\n```xml\n\u003C?xml version='1.0' encoding='UTF-8'  ?>\n\u003Cbeans>\n    \u003C!--shiro applicationContext配置-->\n    \u003Cbean id=\"shiroFilter\" class=\"org.apache.shiro.spring.web.ShiroFilterFactoryBean\">\n        \u003C!--引用securityManager-->\n        \u003Cproperty name=\"securityManager\" ref=\"securityManager\">\u003C/property>\n        \u003C!--登录url 在访问需要认证资源时未认证跳转到此url-->\n        \u003C!--不配置时默认路径为/login.jsp-->\n        \u003Cproperty name=\"LoginUrl\" value=\"/login\">\u003C/property>\n        \u003C!--认证成功url-->\n        \u003C!--successUrl配置只是做为一种附加配置，只有session中没有用户请求地址时才会使用successUrl 所以一般不设置 默认是成功后跳转到上一个请求的url-->\n        \u003C!--\u003Cproperty name=\"successUrl\" >\u003C/property>-->\n        \u003C!--配置用户没有权限访问资源时跳转的url-->\n        \u003Cproperty name=\"unauthorizedUrl\" value=\"/refuse\">\u003C/property>\n        \u003C!--配置shiro过滤器链-->\n        \u003Cproperty name=\"filterChainDefinitions\">\n            \u003Cvalue>\n                /toLogin=anon\n                /login=authc\n                /logout=logout\n                /**=anon\n                \u003C!--静态资源-->\n                /css/**=anon\n                /js/**=anon\n                /images/**=anon\n            \u003C/value>\n        \u003C/property>\n    \u003C/bean>\n    \u003C!--配置authc过滤器-->\n    \u003Cbean id=\"authc\" class=\"org.apache.shiro.web.filter.authc.FormAuthenticationFilter\">\n        \u003C!--表单中的name 默认为username password-->\n        \u003Cproperty name=\"usernameParam\" value=\"name\">\u003C/property>\n        \u003Cproperty name=\"passwordParam\" value=\"pwd\">\u003C/property>\n    \u003C/bean>\n    \u003C!--配置logout过滤器-->\n    \u003Cbean id=\"logout\" class=\"org.apache.shiro.web.filter.authc.LogoutFilter\">\n        \u003C!--默认为\"/\"-->\n        \u003Cproperty name=\"redirectUrl\" value=\"/\" />\n    \u003C/bean>\n    \u003C!--配置securityManager-->\n    \u003Cbean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n        \u003C!--引用realm-->\n        \u003Cproperty name=\"realm\" ref=\"userRealm\">\u003C/property>\n    \u003C/bean>\n    \u003C!--配置userRealm-->\n    \u003Cbean id=\"userRealm\" class=\"com.xxx.realm.userRealm\">\n        \u003C!--引用凭证匹配器-->\n        \u003C!--注意!引用凭证匹配器需要序列化userBean,同时realm需传入salt-->\n        \u003Cproperty name=\"credentialsMatcher\" ref=\"credentialsMatcher\"/>\n    \u003C/bean>\n    \u003C!--配置凭证匹配器-->\n    \u003Cbean id=\"credentialsMatcher\" class=\"org.apache.shiro.authc.credential.HashedCredentialsMatcher\">\n        \u003Cproperty name=\"hashAlgorithmName\" value=\"md5\"/>\n        \u003Cproperty name=\"hashIterations\" value=\"2\"/>\n    \u003C/bean>\n\u003C/beans>\n```\n\nloginController的/login方法配置\n\n```java\n//登录\n@requestMapping(\"/login\")\npublic static ModelAndView login(HttpServletRequest request){\n    ModelAndView mav = new ModelAndView(\"login\");\n    String className=(String)request.getAttribute(\"shiroLoginFailure\");\n    if(UnknownAccountException.class.getName().equals(className)){\n        //抛出自定义异常\n        mav.addObject(\"msg\",\"用户名或密码错误\");\n    }else if(IncorrectCredentialsException.class.getName().equals(className)){\n        //抛出自定义异常\n        mav.addObject(\"msg\",\"用户名或密码错误\");\n    }else{\n        mav.addObject(\"msg\",\"未知错误\");\n    }\n    return mav;\n}\n```\n\ncustom realm配置\n\n```java\npublic class UserRealm extends AuthorizingRealm {\n\n    @Override\n    public String getName() {\n        return \"userRealm\";\n    }\n    //认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        String username = (String)token.getPrincipal();\n        //通过services(调用mapper)方法根据用户名查询并返回user信息\n        //此处pwd为示例简写 正常则为返回的user.getPwd()方法得出\n        String pwd = \"1111\";\n\n        SimpleAuthenticationInfo info = new SimpleAuthenticationInfo(username,pwd,getName());\n        return info;\n    }\n    //授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {\n        //获取用户对象\n        User user = principalCollection.getPrimaryPrincipal();\n        //根据对象查询角色 再查询出权限 此处略过\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        // info.addStringPermissions();\n        return info;\n    }\n}\n```\n\nspring mvc配置aop代理实现shiro授权\n\n```xml\n\u003C!--spring-mvc.xml-->\n\u003C!--开启aop 对类代理-->\n\u003Caop:config proxy-target-class=\"true\">\u003C/aop:config>\n\u003C!--添加shiro授权注解支持-->\n\u003Cbean class=\"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor\">\n    \u003Cproperty name=\"securityManager\" ref=\"securityManager\">\n\u003C/bean>\n```\n此时,如果授权不通过的话shiro并不会处理异常(认证也一样),需要在spring mvc中处理,具体配置如下\n```xml\n\u003C!--shiro异常处理-->\n\u003Cbean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\">\n    \u003Cproperty name=\"exceptionMappings\">\n        \u003Cprops>\n            \u003C!--key为异常完全限定名(包名+类名),值为视图名-->\n            \u003C!--授权异常-->\n            \u003Cprop key=\"org.apache.shiro.authz.UnauthorizedEeception\">refuse\u003C/prop>\n            \u003C!--认证异常-->\n            \u003Cprop key=\"org.apache.shiro.authz.UnauthenticatedEeception\">login\u003C/prop>\n        \u003C/props>\n    \u003C/property>\n\u003C/bean>\n```\n\n__添加ehcache缓存管理__\n\nshiro默认集成了ehcache配置,如需自定义需把配置文件放入src目录下\n\n自定义配置文件\n\n```xml\n\u003C?xml version=\"1.0\" encoding=\"utf-8\" ?>\n\u003Cehcache>\n    \u003CdiskStore path=\"java.io.tmpdir\"/>\n    \u003CdefaultCache\n    maxElementsInMemory=\"10000\"\n    eternal=\"false\"\n    timeToIdleSeconds=\"120\"\n    timeToLiveSeconds=\"128\"\n    overflowToDisk=\"true\"/>\n\u003C/ehcache>\n```\n\n之后在applicationContext.xml中cacheManager的配置\n\n```xml\n\u003C!--配置securityManager-->\n    \u003Cbean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n        \u003C!--引用realm-->\n        \u003Cproperty name=\"realm\" ref=\"userRealm\">\u003C/property>\n        \u003C!--引用缓存管理器-->\n        \u003Cproperty name=\"cacheManager\" ref=\"cacheManager\">\u003C/property>\n    \u003C/bean>\n    \u003C!--配置缓存管理器-->\n    \u003Cbean name=\"cacheManager\" class=\"org.apache.shiro.cache.ehcache.EhCacheManager\">\n        \u003C!--添加了自定义配置才需加上-->\n        \u003Cproperty name=\"cacheManagerConfigFile\" value=\"classpath:ehcache.xml\">\u003C/property>\n    \u003C/bean>\n```\n\n如果因为权限变更需要清理缓存则需在spring容器中调用realm中的清理缓存方法`clearCache(SecurityUtils.getSubject().getPrincipals());`\n\n__Session管理和rememberMe__\n\nsessionManager同样也是在ApplicationContext.xml的securityManger下的property中进行配置\n\n```xml\n\u003C!--配置securityManager-->\n\u003Cbean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    \u003C!--引用realm-->\n    \u003Cproperty name=\"realm\" ref=\"userRealm\"/>\n    \u003C!--引用缓存管理器-->\n    \u003Cproperty name=\"cacheManager\" ref=\"cacheManager\"/>\n    \u003C!--引用sessionManager-->\n    \u003Cproperty name=\"sessionManager\" ref=\"sessionManager\"/>\n\u003C/bean>\n\u003C!--配置会话管理器-->\n\u003Cbean id=\"sessionManager\" class=\"org.apache.shiro.session.mgt.DefaultSessionManager\">\n    \u003C!--单位ms-->\n    \u003Cproperty name=\"globalSessionTimeout\" value=\"300000\"/>\n\u003C/bean>\n```\n\nrememberMe\n\n首先在authc过滤器中添加\n\n```xml\n\u003C!--配置authc过滤器-->\n    \u003Cbean id=\"authc\" class=\"org.apache.shiro.web.filter.authc.FormAuthenticationFilter\">\n        \u003C!--表单中的name-->\n        \u003Cproperty name=\"usernameParam\" value=\"name\"/>\n        \u003Cproperty name=\"passwordParam\" value=\"pwd\"/>\n        \u003C!--rememberMe-->\n        \u003Cproperty name=\"rememberMeParam\" value=\"rememberMe\"/>\n    \u003C/bean>\n```\n\n同样的,还需要在securityManager中引入rememberMeManager\n\n```xml\n\u003C!--配置securityManager-->\n\u003Cbean id=\"securityManager\" class=\"org.apache.shiro.web.mgt.DefaultWebSecurityManager\">\n    \u003C!--引用realm-->\n    \u003Cproperty name=\"realm\" ref=\"userRealm\"/>\n    \u003C!--引用缓存管理器-->\n    \u003Cproperty name=\"cacheManager\" ref=\"cacheManager\"/>\n    \u003C!--引用sessionManager-->\n    \u003Cproperty name=\"sessionManager\" ref=\"sessionManager\"/>\n    \u003C!--引用rememberMeManager-->\n    \u003Cproperty name=\"rememberMeManager\" ref=\"rememberMeManager\"/>\n\u003C/bean>\n\u003C!--配置rememberMeManager-->\n\u003Cbean id=\"rememberMeManager\" class=\"org.apache.shiro.web.mgt.CookieRememberMeManager\">\n    \u003C!--引用rememberMeCookie-->\n    \u003Cproperty name=\"cookie\" ref=\"rememberMeCookie\"/>\n\u003C/bean>\n\u003C!--配置rememberMeCookie-->\n\u003Cbean id=\"rememberMeCookie\" class=\"org.apache.shiro.web.servlet.SimpleCookie\">\n    \u003C!--cookie存活时间-->\n    \u003Cproperty name=\"maxAge\" value=\"604800\"/>\n    \u003C!--设置cookie名称-->\n    \u003Cproperty name=\"name\" value=\"rememberMe\"/>\n    \u003C!--需要完全序列化userBean(包括userBean引用的类也需要被序列化)-->\n\u003C/bean>\n```\n\n同时在过滤器链将首页验证改为user\n\n```xml\n\u003C!--配置shiro过滤器链-->\n\u003Cproperty name=\"filterChainDefinitions\">\n    \u003Cvalue>\n        /toLogin=anon\n        /login=authc\n        /logout=logout\n        \u003C!--使用该过滤器以实现记住我-->\n        /index=user\n        /**=authc\n        \u003C!--静态资源-->\n        /css/**=anon\n        /js/**=anon\n        /images/**=anon\n    \u003C/value>\n\u003C/property>\n```\n\n最后记得把记住我的checkbox的name改为rememberMe\n\n### 最后\n\n到这里shiro差不多可以告一段落了,其他的什么功能以后用到再加上来吧.\n","\n### Maven认识\nMaven 翻译为\"专家\"、\"内行\"，是 Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven利用一个中央信息片段能管理一个项目的构建、报告和文档等步骤。\n\nMaven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。\n\nMaven 也可被用于构建和管理各种项目，例如 C#，Ruby，Scala 和其他语言编写的项目。Maven 曾是 Jakarta 项目的子项目，现为由 Apache 软件基金会主持的独立 Apache 项目。\n\n### Maven基本功能\n- 构建\n- 文档生成\n- 报告\n- 依赖\n- SCMs\n- 发布\n- 分布\n- 邮件列表\n\n### 轻松上手\n\n使用maven构建项目可以摆脱传统项目中繁杂的jar配置,在maven项目中有一个配置文件`pom.xml`,在该文件中可以轻松添加jar的依赖.\n\n__具体步骤__\n\n建议自行下载Maven而不是使用IDEA自带的。\n\n建议添加阿里云Maven镜像[https://maven.aliyun.com/mvn/search](https://maven.aliyun.com/mvn/search)\n\n新建Maven项目，毋庸置疑。\n\n找到pom.xml，需要什么jar,可以在 [mvnrepository](https://mvnrepository.com/)或者[阿里云Maven仓库](https://maven.aliyun.com/mvn/search) 直接搜索,然后把dependency加到pom.xml的dependencies里面去就行了\n\nGAV坐标组成Jar包在仓库的唯一标识\n\n如果需要发布到Tomcat的话，需要在`project structure`->`artifacts->output layout`->`available elements`中的可用jar 右键 put into output root(要不然不会打包jar到tomcat)\n\n\n### 私服环境搭建\n\n[下载Nexus OSS](https://www.sonatype.com/download-oss-sonatype)\n\n下载安装很简单，之后解压通过nexus run可在前台运行，start则可以在后台运行，确认防火墙没问题就可以在浏览器输入ip：8081试试了，第一次会提示你密码在哪个文件夹，cat查看一下就好了。\n\n进入之后可以看到点设置那个图标可以看到repositories，然后就可以看到自己的repositories了，此时可以新建两个仓库，一个release，一个snapshot,仓库的format设置为maven2 hosted。创建好就需要配置自己的pom文件了\n\n```xml\n\u003CdistributionManagement>\n    \u003Crepository>\n        \u003Cid>yelog-release\u003C/id>\n        \u003Cname>Release Repository of yelog\u003C/name>\n        \u003Curl>http://192.168.0.86:8081/repository/yelog-release/\u003C/url>\n    \u003C/repository>\n    \u003CsnapshotRepository>\n        \u003Cid>yelog-snapshot\u003C/id>\n        \u003Cname>Snapshot Repository of yelog\u003C/name>\n        \u003Curl>http://192.168.0.86:8081/repository/yelog-snapshot/\u003C/url>\n    \u003C/snapshotRepository>\n\u003C/distributionManagement>\n```\nmaven的settings.xml\n```xml\n\u003Cservers>\n    \u003Cserver>\n      \u003Cid>yelog-realease\u003C/id>\n      \u003Cusername>admin\u003C/username>\n      \u003Cpassword>admin123\u003C/password>\n    \u003C/server>\n    \u003Cserver>\n      \u003Cid>yelog-snapshot\u003C/id>\n      \u003Cusername>admin\u003C/username>\n      \u003Cpassword>admin123\u003C/password>\n    \u003C/server>\n\u003C/servers>\n```\n然后用idea的maven插件deploy上传就好了\n\n**从私服拉去依赖库**\n\nweb管理页面把刚才两个仓库加到maven-public里去\n\npom 文件中添加如下配置\n```xml\n\u003Crepositories>\n    \u003Crepository>\n        \u003Cid>public\u003C/id>\n        \u003Cname>public Repository\u003C/name>\n        \u003Curl>http://192.168.0.86:8081/repository/maven-public/\u003C/url>\n        \u003Creleases>\n            \u003Cenabled>true\u003C/enabled>\n        \u003C/releases>\n        \u003Csnapshots>\n            \u003Cenabled>true\u003C/enabled>\n        \u003C/snapshots>\n    \u003C/repository>\n\u003C/repositories>\n\u003CpluginRepositories>\n    \u003CpluginRepository>\n        \u003Cid>public\u003C/id>\n        \u003Cname>Public Repositories\u003C/name>\n        \u003Curl>http://192.168.0.86:8081/repository/maven-public/\u003C/url>\n    \u003C/pluginRepository>\n\u003C/pluginRepositories>\n```\n\n引入依赖\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>org.soul\u003C/groupId>\n    \u003CartifactId>commons\u003C/artifactId>\n    \u003Cversion>1.0-SNAPSHOT\u003C/version>\n\u003C/dependency>\n```\n\n希望了解更多请参考[https://help.sonatype.com/repomanager3/installation](https://help.sonatype.com/repomanager3/installation)\n\n### Dependency Scope\n\n**依赖范围**用于限制依赖项的**可传递性**，并确定何时将依赖项**包括在类路径中**。\n\n何时将依赖包含在类路径（classpath）分为三个阶段，分别是**编译（compilation ）**、**测试（test）**、**运行（runtime ）**。\n\n目前依赖范围有6个，分别是\n\n1. **compile**\n\n   默认的范围，编译的依赖项在项目的**所有类路径**均可用，并且**可以传递**。\n\n2. **provided**\n\n   与compile类似，但表示你希望在JDK或容器运行时提供依赖项。举个例子，当你部署JavaEE的Web应用时，你就需要将scope设置为provided，因为servlet以及其他JavaEE的API在Web容器中早已提供。这个依赖范围只在**编译**和**测试**是生效，并且**不可传递**。\n\n3. **runtime**\n\n   此依赖范围表示依赖项只在**运行**和**测试**时需要，**可以传递**。通常用于JDBC驱动。\n\n4. **test**\n\n   此依赖范围表示依赖项只在**运行**和**测试**时需要，**不可传递**。通常用于JUnit之类的测试库。同时，它也适用于Commons IO这种仅用于单元测试（src/test/java）而不用于模型代码（src/main/java）的非测试库。\n\n5. **system**\n\n   与provided类似，不同之处在于你必须提供显式包含它的JAR。该artifact始终可用，并且不会在存储库中查找。基本不用。\n\n6. **import**\n\n   此范围仅在type为pom且处于 `\u003CdependencyManagement>` 部分中的依赖项才支持。它表示该部分的依赖项将在有效的依赖关系列表中被替换。由于它们将被替换，因此具有该范围的依赖项实际上并**不涉及**到限制依赖项的**可传递性**。\n\n","\r\n## Git简介\r\nGit 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。之前对git没有很深的认识，只是了解过简单的push pull等基本命令。一直听说廖雪峰的git教程，刚好也想看看，所以就有了今天的博客:)\r\n\r\n### 分布式&集中式\r\n集中式版本控制系统，版本库是集中存放在中央服务器的，工作时，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始工作，工作后版本变更则需要把自己变更后的版本推送给中央服务器。\r\n分布式版本控制系统没有“中央服务器”，每个人的电脑上都是一个完整的版本库，但是在团队工作中往往会有一台服务器充当中央服务器的角色，用于团队互相查阅各个版本的变更。（可能这就是github诞生的原因8）\r\n其实分布式的版本控制系统还有Mercurial和Bazaar等，但是目前最火的肯定还是git了。\r\n\r\n## Git的安装\r\n最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。\r\n\r\n### Linux安装\r\n如果是比较新的debian系，比如ubuntu18.04LTS（亲测）应该直接sudo apt install git就行了。如果是别的发行版（没试过），可以考虑官网下载源码安装（大致是解压、`./config`、`make`、`sudo make install`就行了）\r\n\r\n### MacOS安装\r\n直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。\r\n\r\n### Windows安装\r\n在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。\r\n安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\r\n安装完成后，还需要最后一步设置，在命令行输入：\r\n`git config --global user.name \"Your Name\"`\r\n` git config --global user.email \"email@example.com\"`\r\n\r\n## 创建版本库\r\n什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。\r\n\r\n第一步，选择或者新建一个空目录\r\n\r\n第二步 ，执行git init(会多一个.git目录)\r\n\r\n然后这个文件夹就是repository，ez!\r\n\r\n### 基本命令\r\n`git add (file)`:把文件添加到repository中，可以多次添加，可以添加文件夹\r\n`git commit -m (commit message)`:用于将添加的文件进行提交，并且需要填写提交信息。\r\n\r\n## 时光机穿梭\r\n`git status`:用于查看版本库的状态(有无文件被修改)\r\n`git diff`:查看修改的内容\r\n\r\n### 版本回退\r\n`git log` 命令显示从最近到最远的提交日志。\r\n如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数：\r\n`git log --pretty=oneline`。 \r\n需要友情提示的是，你看到的一大串类似1094adb。。。的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。\r\n\r\n`git reset --hard HEAD^/ commit_id / HEAD ~ n`:在Git中，用HEAD表示当前版本，上一个版本就是HEAD ^ ，上上一个版本就是HEAD ^^ ，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\r\n`--hard`删除末次提交，并清空所有基于这次commit的修改。可能会造成数据丢失。\r\n\r\n>提示:版本号没必要写全，前几位就可以了(形成独一标识)，Git会自动去找。\r\n\r\n`git reflog`:查看命令历史(可以用来确定未来某个版本的commit_id用git reset变更为未来版本)\r\n\r\n### 工作区和暂存区\r\n\r\n__工作区（Working Directory）__:就是你在电脑里能看到的目录\r\n\r\n__版本库（Repository）__:工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。\r\n\r\nGit的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。之前的git add操作就是将文件添加到暂存区，需要commit之后才会将暂存区的文件提交到分支当中。理解暂存区有利于理解很多命令大概干了哪些事。\r\n\r\n### 管理修改\r\n为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。比如说你修改了一个文件，然后调用git add，之后你再修改文件，并且没有add而是直接commit，然后你会发现第二次更改没有被提交。所以说git提交的不是文件，而且修改之后add操作添加到暂存区的内容。\r\n\r\n### 撤销修改\r\n- 情况1:修改后未执行add操作，使用git checkout --file，注意是两个-，单个的话则是切换命令分支。\r\n\r\n- 情况2:修改文件执行了add操作，但未执行commit，则需要多一步，第一步先执行git reset HEAD file，此刻暂存区的内容会被清除，之后再执行情景1的命令就好了。\r\n\r\n- 情况3:已经commit过了，则需要进行版本回退(前面有提到)，前提是还没推送到远程库。\r\n\r\n### 删除文件\r\n在Git中，删除也是一个修改操作，一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了`rm file`，这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，`git status`命令会立刻告诉你哪些文件被删除了，现在你有两个选择:\r\n- 确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit。\r\n- 删错了，但是版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：`git checkout -- file`，`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。\r\n\r\n> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！\r\n\r\n## 远程仓库\r\nGit是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。但是远程仓库是需要服务器环境的，所以你可以考虑搭建git私服或者使用[GitHub](https://github.com)。这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号(very ez)，就可以免费获得Git远程仓库。(现在私有库都免费了，不过最多支持3人协作，但是还是，真香!)\r\n\r\n### 添加远程库\r\n当你有了github的免费git仓库之后，你就可以使用它来同步你本地的git仓库了。(还能分享给别人学习- -)同步到远程库具体分为以下步骤:\r\n\r\n- 在github创建repository\r\n- 本地库和远程库关联xxxx(可以使用https或者ssh协议自行选择)\r\n`git remote add origin path/xxxx.git`\r\n- git push推送本地库到远程库进行同步`git push -u origin master`\r\n\r\n此命令是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\r\n\r\n推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样，从现在起，只要本地作了提交，就可以通过命令：`git push origin master`\r\n\r\n### 从远程仓库克隆\r\n`git clone path/xxxx.git`\r\n然后你会得到在当前目录下多了一个本地库。和远程库一致。\r\n\r\n## 分支管理\r\n几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。\r\n\r\nGit的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。\r\n\r\n### 创建与合并分支\r\n`git checkout -b branchName` 创建指定分支并切换到该分支。相当于`git branch branchName` `git checkout branchName`\r\n`git branch`命令会列出所有分支，当前分支前面会标一个`*`号。\r\n`git merge branchName`命令用于合并指定分支到当前分支。\r\n合并之后可以使用`git branxh -d branchName`删除指定分支\r\n因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在`master`分支上工作效果是一样的，但过程更安全。\r\n\r\n >switch & checkout\r\n \r\n最新版本的Git提供了新的`git switch`命令来切换分支：`git switch -c branchName`，效果等同于`git checkout -c branchName`，checkout就让他专门用来进行撤销吧，省的整混了\r\n\r\n### 解决冲突\r\n有的时候分支合并可能会发生冲突，比如你在a分支某个文件进行了append，然后你又在b分支对同一个文件又进行了append，此刻快去合并分支则会失败，并要求对冲突的内容进行修改。\r\n\r\n### 分支管理策略\r\n通常，合并分支时，如果可能，Git会用`Fast forward`模式，但这种模式下，删除分支后，会丢掉分支信息。\r\n\r\n如果要强制禁用`Fast forward`模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。\r\n`git merge --no-ff -m \"merge with no-ff\" dev`，其中--no-ff表示禁用`Fast forward`。\r\n\r\n因为本次合并要创建一个新的commit，所以加上`-m`参数，把commit描述写进去。\r\n\r\n之后可以用`git log`查看分支历史\r\n\r\n在实际开发中，通常master都是正式版本的分支，个人开发一般新建一个分支，之后确认无误再将新建的分支合并到master分支中。\r\n\r\n### Bug分支\r\n修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\r\n\r\n当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场；\r\n\r\n在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick \u003Ccommit>`命令，把bug提交的修改“复制”到当前分支，避免重复劳动。\r\n\r\n### Feature分支\r\n开发一个新feature，最好新建一个分支；\r\n\r\n如果要丢弃一个没有被合并过的分支，可以通过`git branch -D \u003Cname>`强行删除。\r\n\r\n### 多人协作\r\n查看远程库信息，使用`git remote -v`；\r\n\r\n本地新建的分支如果不推送到远程，对其他人就是不可见的；\r\n\r\n从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\r\n\r\n在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\r\n\r\n建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\r\n\r\n从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\r\n\r\n### Rebase\r\nrebase操作可以把本地未push的分叉提交历史整理成直线；\r\n\r\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\r\n\r\n## 标签管理\r\ntag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。\r\n\r\n发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。\r\n\r\nGit的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。\r\n\r\n### 创建标签\r\n- 命令`git tag \u003Ctagname>`用于新建一个标签，默认为HEAD，也可以指定一个commit id。\r\n\r\n- 命令`git tag -a \u003Ctagname> -m \"message\"`可以指定标签信息。\r\n\r\n- 命令`git tag`可以查看所有标签。\r\n\r\n### 操作标签\r\n- 命令`git push origin \u003Ctagname>`可以推送一个本地标签。\r\n\r\n- 命令`git push origin --tags`可以推送全部未推送过的本地标签。\r\n\r\n- 命令`git tag -d \u003Ctagname>`可以删除一个本地标签。\r\n\r\n- 命令`git push origin :refs/tags/\u003Ctagname>`可以删除一个远程标签。\r\n\r\n## 码云\r\n众所周知，github访问速度一般，但是除了github还有gitee!也就是码云。码云也是一个git仓库托管的平台，同样支持私有库，最高5人上限，良好的访问速度。而且git本来就是分布式版本控制系统，也就是说，你可以把本地库同步到github的同时也同步到gitee，只是远程名不能都叫origin了，得分别设置。总之，gitee的中文界面，访问速度值得你去尝试。至于有些开源项目，你仍然可以选择star on github，这并不冲突。\r\n\r\n## 自定义功能\r\n\r\n### 忽略配置文件\r\n当你不想把一些文件提交到git仓库时，你可以选择提交忽略。\r\n忽略某些文件时，需要编写.gitignore；\r\n\r\n.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！\r\n\r\n### 配置别名\r\n~~有的时候你可能会忘记有些命令单词~~，贴心的git为你设计了别名。但是感觉git使用频率不高，感觉没必要配置，这里就简单说一下，其实就是可以通过命令配置别名达到偷懒的作用。eg:`git config --global alias.st status`，在输入这个命令后，以后就可以直接git st代替git status，其他类似。感觉没什么必要，就不多赘述了。\r\n\r\n### 搭建git服务器\r\n1. 服务器安装git(根据发行版自行安装)\r\n2. 创建git用户，用于运行git服务\r\n3. 创建证书登录\r\n4. 初始化git仓库\r\n5. 禁用shell登录\r\n6. 克隆远程仓库\r\n\r\n管理公钥:自行了解Gitosis\r\n\r\n管理权限:自行了解Gitolite\r\n\r\n## 最后\r\n差不多了,对了最近好像 GitHub Mobile beta ios已经开始测试了,Android也可以预约beta了 感兴趣可以了解一下 over -.-\r\n\r\n\r\n\r\n","\r\n### Synchronized 关键字\r\nJava语言的关键字，可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，当一个线程访问object的一个加锁代码块时，另一个线程仍可以访问该object中的非加锁代码块。\r\n\r\n#### 同步方法\r\n`synchronized T methodName(){}`同步方法锁定的是当前对象。当多线程通过同一个对象引用多次调用当前同步方法时，需同步执行。\r\n\r\n#### 同步代码块\r\n同步代码块的同步粒度更加细致，是实际开发中推荐的编程方式。可以定位到具体的同步位置，而不是简单的将方法整体实现同步逻辑。在效率上，相对更高。\r\n\r\n##### 锁定临界对象\r\n``` java\r\nT methodName(){\r\n    synchronized(object){ \r\n    }\r\n}\r\n```\r\n同步代码块在执行时，是锁定 object 对象。当多个线程调用同一个方法时，锁定对象不变的情况下，需同步执行。\r\n\r\n##### 锁定当前对象\r\n``` java\r\nT methodName(){\r\n    synchronized(this){     \r\n    }\r\n}\r\n```\r\n当锁定对象为 this 时，相当于调用`synchronized T methodName(){}`同步方法。\r\n\r\n#### 锁的底层实现\r\nJava 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现。同步方法 并不是由 monitor enter 和 monitor exit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。\r\n\r\n##### 对象内存简图\r\n![img](https://alightyoung.gitee.io/static/img/33.webp)\r\n\r\n**对象头**:存储对象的 hashCode、锁信息或分代年龄或 GC 标志，类型指针指向对象的类\r\n**元数据**:JVM 通过这个指针确定该对象是哪个类的实例等信息。\r\n**实例变量**：存放类的属性数据信息，包括父类的属性信息\r\n**填充数据**：由于虚拟机要求对象起始地址必须是 8 字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐\r\n\r\n当在对象上加锁时，数据是记录在对象头中。当执行 synchronized 同步方法或同步代码块时，会在对象头中记录锁标记，锁标记指向的是 monitor 对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如 monitor 可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。\r\n\r\n在 Java 虚拟机(HotSpot)中，monitor 是由 ObjectMonitor 实现的。ObjectMonitor 中有两个队列，_WaitSet 和 _EntryList，以及_Owner 标记。其中_WaitSet是用于管理等待队列(wait)线程的，_EntryList 是用于管理锁池阻塞线程的，_Owner 标记用于记录当前执行线程。线程状态图如下：\r\n![img](https://alightyoung.gitee.io/static/img/34.png)\r\n\r\n#### 锁的种类\r\nJava 中锁的种类大致分为偏向锁，锁的自旋，轻量级锁，重量级锁。\r\n\r\n锁的使用方式为：先提供偏向锁，如果不满足的时候，升级为轻量级锁，再不满足，升级为重量级锁。*自旋锁是一个过渡的锁状态，不是一种实际的锁类型。*锁只能升级，不能降级。\r\n\r\n##### 重量级锁\r\n内置锁在Java中被抽象为监视器锁（monitor）。\r\n\r\n在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。也就是上面说的锁的底层。\r\n\r\n##### 偏向锁\r\n偏向锁是一种编译解释锁。\r\n\r\n如果代码中不可能出现多线程并发争抢同一个锁的时候，JVM 编译代码，解释执行的时候，会自动的放弃同步信息。消除 synchronized 的同步代码结果。使用锁标记的形式记录锁状态。在 Monitor 中有变量 ACC_SYNCHRONIZED。当变量值使用的时候，代表偏向锁锁定。可以避免锁的争抢和锁池状态的维护。提高效率。\r\n\r\n##### 轻量级锁\r\n过渡锁。\r\n\r\n当偏向锁不满足，也就是有多线程并发访问，锁定同一个对象的时候，先提升为轻量级锁。也是使用标记 ACC_SYNCHRONIZED 标记记录的。ACC_UNSYNCHRONIZED 标记记录未获取到锁信息的线程。就是只有两个线程争抢锁标记的时候，优先使用轻量级锁。两个线程也可能出现重量级锁。\r\n\r\n##### 自旋锁\r\n自旋锁是一个过渡锁，是偏向锁和轻量级锁的过渡。\r\n\r\n当获取锁的过程中，未获取到。为了提高效率，JVM 自动执行若干次空循环，再次申请锁，而不是进入阻塞状态的情况。称为自旋锁。自旋锁提高效率就是避免线程状态的变更。\r\n\r\n### Volatile 关键字\r\n变量的线程可见性。在 CPU 计算过程中，会将计算过程需要的数据加载到 CPU 计算缓存中，当 CPU 计算中断时，有可能刷新缓存，重新读取内存中的数据。在线程运行的过程中，如果某变量被其他线程修改，可能造成数据不一致的情况，从而导致结果错误。而 volatile修饰的变量是线程可见的，当 JVM 解释 volatile 修饰的变量时，会通知 CPU，在计算过程中，每次使用变量参与计算时，都会检查内存中的数据是否发生变化，而不是一直使用 CPU 缓存中的数据，可以保证计算结果的正确。volatile 只是通知底层计算时，CPU 检查内存数据，而不是让一个变量在多个线程中同步。\r\n\r\n### wait&notify\r\n在Object对象中有三个方法wait()、notify()、notifyAll()，它们的用途都是用来控制线程的状态。\r\n\r\n#### wait()\r\n该方法用来将当前线程置入休眠状态，直到在其他线程调用此对象的notify()方法或notifyAll()方法将其唤醒。\r\n\r\n在调用wait()之前，线程必须要获得该对象的对象级别锁，因此只能在同步方法或同步块中调用wait()方法。进入wait()方法后，当前线程释放锁。在从wait()返回前，线程与其他线程竞争重新获得锁。如果调用wait()时，没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch结构。\r\n\r\n#### notify()\r\n该方法唤醒在此对象监视器上等待的单个线程。如果有多个线程都在此对象上等待，则会**随机选择**唤醒其中一个线程，对其发出通知notify()，并使它等待获取该对象的对象锁。注意“等待获取该对象的对象锁”，这意味着，即使收到了通知，wait的线程也不会马上获取对象锁，必须等待notify()方法的线程释放锁才可以。和wait()一样，notify()也要在同步方法/同步代码块中调用。\r\n\r\n#### notifyAll()\r\nnotifyAll()的作用是唤醒在此对象监视器上等待的**所有线程**。其用法与notify()基本一致，只不过它会唤醒一个对象监视器上等待的全部线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；\r\n\r\n#### 总结\r\nwait()使线程停止运行，notify()/notifyAll()使停止运行的线程继续运行。\r\n\r\n### AtomicXxx 类型组\r\n原子类型。\r\n\r\n在 concurrent.atomic 包中定义了若干原子类型，这些类型中的每个方法都是保证了原子操作的。多线程并发访问原子类型对象中的方法，不会出现数据错误。在多线程开发中，如果某数据需要多个线程同时操作，且要求计算原子性，可以考虑使用原子类型对象。\r\n>注意：原子类型中的方法是保证了原子操作，但多个方法之间是没有原子性的。如：\r\nAtomicInteger i = new AtomicInteger(0);\r\nif(i.get() != 5) i.incrementAndGet();\r\n在上述代码中，get 方法和 incrementAndGet 方法都是原子操作，但复合使用时，无法\r\n保证原子性，仍旧可能出现数据错误。\r\n\r\n### CountDownLatch\r\nCountDownLatch是 concurrent 包中定义的一个类型，是用于多线程通讯的一个辅助类型。\r\n\r\nCountDownLatch相当于在一个门上加多个锁，当线程调用 await 方法时，会检查CountDownLatch数量，如果CountDownLatch数量大于 0，线程会阻塞等待。当线程调用 countDown 时，会递减CountDownLatch的数量，当CountDownLatch数量为 0 时，await 阻塞线程可执行。\r\n\r\n### 锁的重入\r\n在 Java 中，同步锁是可以重入的。只有同一线程调用同步方法或执行同步代码块，对同一个对象加锁时才可重入。\r\n\r\n当线程持有锁时，会在 monitor 的计数器中执行递增计算，若当前线程调用其他同步代码，且同步代码的锁对象相同时，monitor 中的计数器继续递增。每个同步代码执行结束，monitor 中的计数器都会递减，直至所有同步代码执行结束，monitor 中的计数器为 0 时，释放锁标记，_Owner 标记赋值为 null。\r\n\r\n### ReentrantLock\r\n重入锁，建议应用的同步方式。相对效率比 synchronized 高。量级较轻。\r\n\r\nsynchronized 在 JDK1.5 版本开始，尝试优化。到 JDK1.7 版本后，优化效率已经非常好了。在绝对效率上，已经和reentrantLock差不多了。但ReentrantLock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。\r\n\r\n使用重入锁，必须必须必须手工释放锁标记。一般都是在 finally 代码块中定义释放锁标记的 unlock 方法。\r\n\r\n### 公平/非公平锁 & 乐观/非乐观锁\r\n#### 公平锁/非公平锁（多线程执行顺序的维度）\r\n\r\n**概念理解**\r\n\r\n- 公平锁：加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，先来先得。\r\n- 非公平所：线程加锁时直接尝试获取锁，获取不到就自动到队尾等待。\r\n\r\n**例子：**\r\n- ReentrantLock 同时支持两种锁\r\n``` java\r\n//创建一个非公平锁，默认是非公平锁\r\n\r\nLock nonFairLock= new ReentrantLock();\r\n\r\nLock nonFairLock= new ReentrantLock(false);\r\n\r\n//创建一个公平锁，构造传参true\r\n\r\nLock fairLock= new ReentrantLock(true);\r\n```\r\n\r\n**适用场景：**\r\n\r\n更多的是直接使用非公平锁：非公平锁比公平锁性能高5-10倍，因为公平锁需要在多核情况下维护一个队列，如果当前线程不是队列的第一个无法获取锁，增加了线程切换次数。\r\n\r\n#### 乐观锁/悲观锁（多线程操作共享数据的维度）\r\n\r\n**概念理解**\r\n\r\n- 悲观锁：假设一定会发生并发冲突，通过阻塞其他所有线程来保证数据的完整性。\r\n- 乐观锁：假设不会发生并发冲突，直接不加锁去完成某项更新，如果冲突就返回失败。\r\n\r\n**例子**\r\n\r\n- 悲观锁：Synchronized多线程同步，具有排他性，也会容易产生死锁。\r\n- 乐观锁：CAS机制，简单来说会有三个操作数，当前内存变量值V，变量预期值A，即将更新值B，当需要更新变量的时候，会直接将变量值V和预期值A进行比较，如果相同，则直接更新为B；如果不相同，则当前变量值V刷新到预期值中，然后重新尝试比较更新。\r\n\r\n**适用场景**\r\n\r\n- 乐观锁：适用于数据争用不严重/重试代价不大/需要相应速度快的场景。\r\n- 悲观锁：适用于数据争用严重/重试代价大的场景。\r\n\r\n### ThreadLocal\r\n早在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。\r\n\r\n当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。\r\n\r\n从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。\r\n\r\n所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。\r\n\r\n#### Thread同步机制的比较\r\n在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。\r\n\r\n而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。\r\n\r\n概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。\r\n\r\n\r\n\r\n\r\n\r\n","\r\n### 前言\r\nJava为了解决并发情况下的容器线程安全问题的,给多线程环境准备一个线程安全的容器对象。线程安全的容器对象： Vector, Hashtable。线程安全容器对象，都是使用 synchronized方法实现的。而concurrent 包中的同步容器，大多数是使用系统底层技术实现的线程安全。类似 native。Java8 中使用 CAS。\r\n\r\n以下是一些较为常见的并发容器\r\n\r\n### Map/Set\r\n\r\n#### ConcurrentHashMap/ConcurrentHashSet\r\n底层哈希实现的同步 Map(Set)。效率高，线程安全。使用系统底层技术实现线程安全。量级较 synchronized 低。key 和 value 不能为 null。\r\n\r\n#### ConcurrentSkipListMap/ConcurrentSkipListSet\r\n底层跳表（SkipList）实现的同步 Map(Set)。有序，效率比 ConcurrentHashMap 稍低。\r\n> [SkipList](https://baike.baidu.com/item/%E8%B7%B3%E8%A1%A8/22819833?fr=aladdin)\r\n\r\n### List\r\n\r\n#### CopyOnWriteArrayList\r\n写时复制集合。写入效率低，读取效率高。每次写入数据，都会创建一个新的底层数组。\r\n\r\n### Queue\r\n\r\n#### ConcurrentLinkedQueue \r\n基础链表同步队列。\r\n\r\n#### LinkedBlockingQueue\r\n阻塞队列，队列容量不足自动阻塞，队列容量为 0 自动阻塞。\r\n\r\n#### ArrayBlockingQueue\r\n底层数组实现的有界队列。自动阻塞。根据调用 API（add/put/offer）不同，有不同特性。当容量不足的时候，有阻塞能力。\r\n\r\nadd 方法在容量不足的时候，抛出异常。\r\n\r\nput 方法在容量不足的时候，阻塞等待。\r\n\r\noffer 方法，单参数 offer 方法，不阻塞。容量不足的时候，返回 false。当前新增数据操作放弃。三参数 offer 方法（offer(value,times,timeunit)），容量不足的时候，阻塞 times 时长（单位为 timeunit），如果在阻塞时长内，有容量空闲，新增数据返回 true。如果阻塞时长范围内，无容量空闲，放弃新增数据，返回 false。\r\n\r\n#### DelayQueue\r\n延时队列。根据比较机制，实现自定义处理顺序的队列。常用于定时任务。如：定时关机。\r\n\r\n#### LinkedTransferQueue\r\n转移队列，使用 transfer 方法，实现数据的即时处理。没有消费者，就阻塞。\r\n\r\n#### SynchronusQueue\r\n同步队列，是一个容量为 0 的队列。是一个特殊的 TransferQueue。必须现有消费线程等待，才能使用的队列。\r\nadd 方法，无阻塞。若没有消费线程阻塞等待数据，则抛出异常。\r\nput 方法，有阻塞。若没有消费线程阻塞等待数据，则阻塞。\r\n\r\n### 最后\r\n这里只是简单的记录一下并发容器，以后了解了再填坑。。。\r\n","\n\u003CBadge text=\"中等\" type=\"warning\"/> 原题链接：[https://leetcode-cn.com/problems/add-two-numbers](https://leetcode-cn.com/problems/add-two-numbers)\n\n## 题目描述\n\n给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n:::details{text=\"示例 1\"}\n![addtwonumber1.jpg](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)\n\n输入：l1 = [2,4,3], l2 = [5,6,4]\n\n输出：[7,0,8]\n\n解释：342 + 465 = 807.\n:::\n\n:::details{text=\"示例 2\"}\n输入：l1 = [0], l2 = [0]\n\n输出：[0]\n:::\n\n:::details{text=\"示例 3\"}\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n\n输出：[8,9,9,9,0,0,0,1]\n:::\n\n:::details{text=\"提示\"}\n每个链表中的节点数在范围 [1, 100] 内\n\n$0 \u003C= Node.val \u003C= 9$\n\n题目数据保证列表表示的数字不含前导零\n:::\n\n\n\n\n## Java 题解\n\n### 方法一：初等数学\n\n**思路**\n我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐位相加的过程。\n\n![图1，对两数相加方法的可视化: 342 + 465 = 807，每个结点都包含一个数字，并且数字按位逆序存储。](https://alightyoung.gitee.io/static/img/5.png)\n\n图 1，对两数相加方法的可视化: 342 + 465 = 807，每个结点都包含一个数字，并且数字按位逆序存储。\n\n**算法**\n\n就像你在纸上计算两个数字的和那样，我们首先从最低有效位也就是列表 l1 和 l2 的表头开始相加。由于每位数字都应当处于 $0 \\ldots 9$ 的范围内，我们计算两个数字的和时可能会出现 “溢出”。例如，5 + 7 = 12。在这种情况下，我们会将当前位的数值设置为 22，并将进位 carry = 1 带入下一次迭代。进位 carry 必定是 0 或 1，这是因为两个数字相加（考虑到进位）可能出现的最大和为 9 + 9 + 1 = 19。\n\n伪代码如下：\n\n-   将当前结点初始化为返回列表的哑结点。\n-   将进位 carry 初始化为 0。\n-   将 p 和 q 分别初始化为列表 l1 和 l2 的头部。\n-   遍历列表 l1 和 l2 直至到达它们的尾端。\n\n    -   将 x 设为结点 p 的值。如果 p 已经到达 l1 的末尾，则将其值设置为 0。\n    -   将 y 设为结点 q 的值。如果 q 已经到达 l2 的末尾，则将其值设置为 0。\n    -   设定 sum = x + y + carry。\n    -   更新进位的值，carry = sum / 10。\n    -   创建一个数值为 $(sum \\bmod 10)$ 的新结点，并将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点。\n    -   同时，将 p 和 q 前进到下一个结点。\n\n-   检查 carry = 1 是否成立，如果成立，则向返回列表追加一个含有数字 1 的新结点。\n-   返回哑结点的下一个结点。\n\n请注意，我们使用哑结点来简化代码。如果没有哑结点，则必须编写额外的条件语句来初始化表头的值。\n\n请特别注意以下情况：\n\n| 测试用例                       | 说明                                               |\n| :----------------------------- | :------------------------------------------------- |\n| l1=[0,1], l2=[0,1,2], l2=[0,1,2] | 当一个列表比另一个列表长时                         |\n| l1=[], l2=[0,1], l2=[0,1]        | 当一个列表为空时，即出现空列表                     |\n| l1=[9,9], l2=[1], l2=[1]         | 求和运算最后可能出现额外的进位，这一点很容易被遗忘 |\n\n```java\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n    ListNode dummyHead = new ListNode(0);\n    ListNode p = l1, q = l2, curr = dummyHead;\n    int carry = 0;\n    while (p != null || q != null) {\n        int x = (p != null) ? p.val : 0;\n        int y = (q != null) ? q.val : 0;\n        int sum = carry + x + y;\n        carry = sum / 10;\n        curr.next = new ListNode(sum % 10);\n        curr = curr.next;\n        if (p != null) p = p.next;\n        if (q != null) q = q.next;\n    }\n    if (carry > 0) {\n        curr.next = new ListNode(carry);\n    }\n    return dummyHead.next;\n}\n```\n\n**复杂度分析**\n\n-   时间复杂度：O(max(m, n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m, n) 次。\n\n-   空间复杂度：O(max(m, n))， 新列表的长度最多为 max(m,n) + 1。\n\n**拓展**\n\n如果链表中的数字不是按逆序存储的呢？例如：\n\n$$\n(3→4→2)+(4→6→5)=8→0→7\n$$\n\n## 总结\n\n拓展可以利用栈/递归（反正我不会 qaq，社区评论看的）。\n","\n### Executor\n线程池顶级接口。定义方法，void execute(Runnable)。方法是用于处理任务的一个服务方法。调用者提供 Runnable 接口的实现，线程池通过线程执行这个 Runnable。服务方法无返回值的。是 Runnable 接口中的 run 方法无返回值。常用方法 - void execute(Runnable)作用是： 启动线程任务的。\n\n### ExecutorService\nExecutor 接口的子接口。提供了一个新的服务方法，submit。有返回值（Future 类型）。\n\nsubmit 方法提供了 overload 方法。其中有参数类型为 Runnable 的，不需要提供返回值的；有参数类型为 Callable，可以提供线程执行后的返回值。\n\nFuture，是 submit 方法的返回值。代表未来，也就是线程执行结束后的一种结果。如返回值。\n\n常见方法 - void execute(Runnable)， Future submit(Callable)， Future submit(Runnable)\n\n线程池状态： Running， ShuttingDown， Termitnaed\n\n- Running - 线程池正在执行中。活动状态。\n- ShuttingDown - 线程池正在关闭过程中。优雅关闭。一旦进入这个状态，线程池不再接收新的任务，处理所有已接收的任务，处理完毕后，关闭线程池。\n- Terminated - 线程池已经关闭。\n\n### Future\n未来结果，代表线程任务执行结束后的结果。获取线程执行结果的方式是通过 get 方法获取的。get 无参，阻塞等待线程执行结束，并得到结果。get 有参，阻塞固定时长，等待线程执行结束后的结果，如果在阻塞时长范围内，线程未执行结束，抛出异常。\n\n常用方法： T get() T get(long, TimeUnit)\n\n### Callable\n可执行接口。 类似 Runnable 接口。也是可以启动一个线程的接口。其中定义的方法是call。call 方法的作用和 Runnable 中的 run 方法完全一致。call 方法有返回值。\n\n接口方法 ： Object call();相当于 Runnable 接口中的 run 方法。区别为此方法有返回值。不能抛出已检查异常。\n\n和 Runnable 接口的选择 - 需要返回值或需要抛出异常时，使用 Callable，其他情况可\n任意选择。\n\n### Executors\n工具类型。为 Executor 线程池提供工具方法。可以快速的提供若干种线程池。如：固定容量的，无限容量的，容量为 1 等各种线程池。\n\n线程池是一个进程级的重量级资源。默认的生命周期和 JVM 一致。当开启线程池后，直到 JVM 关闭为止，是线程池的默认生命周期。如果手工调用 shutdown 方法，那么线程池执行所有的任务后，自动关闭。\n\n开始 - 创建线程池。\n结束 - JVM 关闭或调用 shutdown 并处理完所有的任务。\n\n类似 Arrays，Collections 等工具类型的功用。\n\n### FixedThreadPool\n容量固定的线程池。活动状态和线程池容量是有上限的线程池。所有的线程池中，都有一个任务队列。使用的是 `BlockingQueue\u003CRunnable>` 作为任务的载体。当任务数量大于线程池容量的时候，没有运行的任务保存在任务队列中，当线程有空闲的，自动从队列中取出任务执行。\n\n使用场景： 大多数情况下，使用的线程池，首选推荐 FixedThreadPool。OS 系统和硬件是有线程支持上限。不能随意的无限制提供线程池。\n\n线程池默认的容量上限是 Integer.MAX_VALUE。\n\n常见的线程池容量： PC - 200。 服务器 - 1000~10000\n\nqueued tasks- 任务队列\n\ncompleted tasks - 结束任务队列\n\n### CachedThreadPool\n缓存的线程池。容量不限（Integer.MAX_VALUE）。自动扩容。容量管理策略：如果线程池中的线程数量不满足任务执行，创建新的线程。每次有新任务无法即时处理的时候，都会创建新的线程。当线程池中的线程空闲时长达到一定的临界值（默认 60 秒），自动释放线程。\n\n默认线程空闲 60 秒，自动销毁。\n\n应用场景： 内部应用或测试应用。\n\n内部应用，有条件的内部数据瞬间处理时应用，如：电信平台夜间执行数据整理（有把握在短时间内处理完所有工作，且对硬件和软件有足够的信心）。\n\n测试应用，在测试的时候，尝试得到硬件或软件的最高负载量，用于提供\nFixedThreadPool 容量的指导。\n\n### ScheduledThreadPool\n计划任务线程池。可以根据计划自动执行任务的线程池。\n\nscheduleAtFixedRate(Runnable, start_limit, limit, timeunit)\n\nrunnable - 要执行的任务。\nstart_limit - 第一次任务执行的间隔。\nlimit - 多次任务执行的间隔。\ntimeunit - 多次任务执行间隔的时间单位。\n\n使用场景： 计划任务时选用（DelaydQueue），如：电信行业中的数据整理，没分钟整\n理，没消失整理，每天整理等。\n\n### SingleThreadExceutor\n单一容量的线程池。\n\n使用场景： 保证任务顺序时使用。如： 游戏大厅中的公共频道聊天。\n\n### ForkJoinPool\n分支合并线程池（mapduce 类似的设计思想）。适合用于处理复杂任务。\n\n初始化线程容量与 CPU 核心数相关。\n\n线程池中运行的内容必须是 ForkJoinTask 的子类型（RecursiveTask,RecursiveAction）。\n\nForkJoinPool - 分支合并线程池。 可以递归完成复杂任务。要求可分支合并的任务必须是 ForkJoinTask 类型的子类型。其中提供了分支和合并的能力。ForkJoinTask 类型提供了两个抽象子类型，RecursiveTask 有返回结果的分支合并任务,RecursiveAction 无返回结果的分支合并任务。（Callable/Runnable）compute 方法：就是任务的执行逻辑。\n\nForkJoinPool 没有所谓的容量。默认都是 1 个线程。根据任务自动的分支新的子线程。当子线程任务结束后，自动合并。所谓自动是根据 fork 和 join 两个方法实现的。\n\n应用： 主要是做科学计算或天文计算的。数据分析的。\n\n### WorkStealingPool\nJDK1.8 新增的线程池。工作窃取线程池。当线程池中有空闲连接时，自动到等待队列中窃取未完成任务，自动执行。\n\n初始化线程容量与 CPU 核心数相关。此线程池中维护的是精灵线程。\n\n`ExecutorService.newWorkStealingPool();`\n\n### ThreadPoolExecutor\n线程池底层实现。除 ForkJoinPool 外，其他常用线程池底层都是使用 ThreadPoolExecutor实现的。\n```java\npublic ThreadPoolExecutor(\nint corePoolSize, // 核心容量，创建线程池的时候，默认有多少线程。也是线程池保持的最少线程数\nint maximumPoolSize, // 最大容量，线程池最多有多少线程\nlong keepAliveTime, // 生命周期，0 为永久。当线程空闲多久后，自动回收。\nTimeUnit unit, // 生命周期单位，为生命周期提供单位，如：秒，毫秒\nBlockingQueue\u003CRunnable> workQueue // 任务队列，阻塞队列。注意，泛型必须是Runnable\n);\n```\n使用场景： 默认提供的线程池不满足条件时使用。如：初始线程数据 4，最大线程数\n200，线程空闲周期 30 秒。\n\n### over\n","\n### JVM 简单结构图\n\n![img](https://alightyoung.gitee.io/static/img/7.png)\n\n#### 类加载子系统与方法区：\n\n类加载子系统负责从文件系统或者网络中加载 Class 信息，加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中可能还会存放运行时常量池信息，包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）。\n\n#### Java 堆\n\njava 堆在虚拟机启动的时候建立，它是 java 程序最主要的内存工作区域。几乎所有的 java 对象实例都存放在 java 堆中。堆空间是所有线程共享的，这是一块与 java 应用密切相关的内存空间。\n\n#### 直接内存\n\njava 的 NIO 库允许 java 程序使用直接内存。直接内存是在 java 堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于 java 堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。由于直接内存在 java 堆外，因此它的大小不会直接受限于 Xmx 指定的最大堆大小，但是系统内存是有限的，java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。\n\n#### 垃圾回收系统（GC）\n\n垃圾回收系统是 java 虚拟机的重要组成部分，垃圾回收器可以对方法区、java 堆和直接内存进行回收。其中，java 堆是垃圾收集器的工作重点。和 C/C++不同，java 中所有的对象空间释放都是隐式的，也就是说，java 中没有类似 free()或者 delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。\n\n#### Java 栈\n\n每一个 java 虚拟机线程都有一个私有的 java 栈，一个线程的 java 栈在线程创建的时候被创建，java 栈中保存着帧信息，java 栈中保存着局部变量、方法参数，同时和 java 方法的调用、返回密切相关。\n\n#### 本地方法栈\n\n本地方法栈和 java 栈非常类似，最大的不同在于 java 栈用于方法的调用，而本地方法栈则用于本地方法的调用，作为对 java 虚拟机的重要扩展，java 虚拟机允许 java 直接调用本地方法（通常使用 C 编写）\n\n#### PC 寄存器\n\nPC（Program Counter）寄存器也是每一个线程私有的空间，java 虚拟机会为每一个 java 线程创建 PC 寄存器。在任意时刻，一个 java 线程总是在执行一个方法，这个正在被执行的方法称为当前方法。如果当前方法不是本地方法，PC 寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么 PC 寄存器的值就是 undefined\n\n#### 执行引擎\n\n执行引擎是 java 虚拟机的最核心组件之一，它负责执行虚拟机的字节码，现代虚拟机为了提高执行效率，会使用即时编译(just in time)技术将方法编译成机器码后再执行。Java HotSpot Client VM(-client)，为在客户端环境中减少启动时间而优化的执行引擎；本地应用开发使用。（如：eclipse）\n\nJava HotSpot Server VM(-server)，为在服务器环境中最大化程序执行速度而设计的执行\n引擎。应用在服务端程序。（如：tomcat）\n\n**Java HotSpot Client 模式和 Server 模式的区别**\n当虚拟机运行在-client 模式的时候,使用的是一个代号为 C1 的轻量级编译器, 而-server 模式启动的虚拟机采用相对重量级,代号为 C2 的编译器. C2 比 C1 编译器编译的相对彻底,服务起来之后,性能更高\n\nJDK 安装目录/jre/lib/（x86、i386、amd32、amd64）/jvm.cfg\n文件中的内容，-server 和-client 哪一个配置在上，执行引擎就是哪一个。如果是 JDK1.5\n版本且是 64 位系统应用时，-client 无效。\n\n--64 位系统内容\n-server KNOWN\n-client IGNORE\n\n--32 位系统内容\n-server KNOWN\n-client KNOWN\n\n注意：在部分 JDK1.6 版本和后续的 JDK 版本(64 位系统)中，-client 参数已经不起作用了，Server 模式成为唯一。\n\n### 堆结构及对象分代\n\n#### 什么是分代，分代的必要性是什么\n\nJava 虚拟机根据对象存活的周期不同，把堆内存划分为几块，一般分为新生代、老年代和永久代（对 HotSpot 虚拟机而言），这就是 JVM 的内存分代策略。\n\n堆内存是虚拟机管理的内存中最大的一块，也是垃圾回收最频繁的一块区域，我们程序所有的对象实例都存放在堆内存中。给堆内存分代是为了提高对象内存分配和垃圾回收的效率。试想一下，如果堆内存没有区域划分，所有的新创建的对象和生命周期很长的对象放在一起，随着程序的执行，堆内存需要频繁进行垃圾收集，而每次回收都要遍历所有的对象，遍历这些对象所花费的时间代价是巨大的，会严重影响我们的 GC 效率。\n\n有了内存分代，情况就不同了，新创建的对象会在新生代中分配内存，经过多次回收仍然存活下来的对象存放在老年代中，静态属性、类信息等存放在永久代中，新生代中的对象存活时间短，只需要在新生代区域中频繁进行 GC，老年代中对象生命周期长，内存回收的频率相对较低，不需要频繁进行回收，永久代中回收效果太差，一般不进行垃圾回收，还可以根据不同年代的特点采用合适的垃圾收集算法。分代收集大大提升了收集效率，这些都是内存分代带来的好处。\n\n#### 分代的划分\n\nJava 虚拟机将堆内存划分为新生代、老年代和永久代，永久代是 HotSpot 虚拟机特有的概念（JDK1.8 之后为 metaspace 替代永久代），它采用永久代的方式来实现方法区，其他的虚拟机实现没有这一概念，而且 HotSpot 也有取消永久代的趋势，在 JDK 1.7 中 HotSpot 已经开始了“去永久化”，把原本放在永久代的字符串常量池移出。永久代主要存放常量、类信息、静态变量等数据，与垃圾回收关系不大，新生代和老年代是垃圾回收的主要区域。\n\n内存简图如下：\n\n![img](https://alightyoung.gitee.io/static/img/8.png)\n\n##### 新生代（Young Generation\n\n新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低，在新生代中，常规应用进行一次垃圾收集一般可以回收 70% ~ 95% 的空间，回收效率很高。\n\nHotSpot 将新生代划分为三块，一块较大的 Eden（伊甸）空间和两块较小的 Survivor（幸存者）空间，默认比例为 8：1：1。\n\n划分的目的是因为 HotSpot 采用复制算法来回收新生代，设置这个比例是为了充分利用内存空间，减少浪费。新生成的对象在 Eden 区分配（大对象除外，大对象直接进入老年代）\n\n当 Eden 区没有足够的空间进行分配时，虚拟机将发起一次 Minor GC。\n\nGC 开始时，对象只会存在于 Eden 区和 From Survivor 区，To Survivor 区是空的（作为保留区域）。\n\nGC 进行时，Eden 区中所有存活的对象都会被复制到 To Survivor 区，而在 FromSurvivor 区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为 15，新生代中的对象每熬过一轮垃圾回收，年龄值就加 1，GC 分代年龄存储在对象的 header 中）的对象会被移到老年代中，没有达到阀值的对象会被复制到 To Survivor 区。接着清空 Eden 区和 From Survivor 区，新生代中存活的对象都在 To Survivor 区。接着， From Survivor 区和 To Survivor 区会交换它们的角色，也就是新的 To Survivor 区就是上次 GC 清空的 FromSurvivor 区，新的 From Survivor 区就是上次 GC 的 To Survivor 区，总之，不管怎样都会保证 To Survivor 区在一轮 GC 后是空的。\n\nGC 时当 To Survivor 区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。\n\n##### 老年代（Old Generationn）\n\n在新生代中经历了多次（具体看虚拟机配置的阀值）GC 后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行 GC 的频率相对而言较低，而且回收的速度也比较慢。\n\n##### 永久代（Permanent Generationn）\n\n永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java 虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。\n\n### 垃圾回收算法及分代垃圾收集器\n\n#### 垃圾收集器的分类\n\n##### 次收集器\n\nScavenge GC，指发生在新生代的 GC，因为新生代的 Java 对象大多都是朝生夕死，所以 Scavenge GC 非常频繁，一般回收速度也比较快。当 Eden 空间不足以为对象分配内存时，会触发 Scavenge GC。一般情况下，当新对象生成，并且在 Eden 申请空间失败时，就会触发 Scavenge GC，对 Eden 区域进行 GC，清除非存活对象，并且把尚且存活的对象移动到 Survivor 区。然后整理 Survivor 的两个区。这种方式的 GC 是对年轻代的 Eden 区进行，不会影响到年老代。因为大部分对象都是从 Eden 区开始的，同时 Eden 区不会分配的很大，所以 Eden 区的 GC 会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使 Eden 去能尽快空闲出来。当年轻代堆空间紧张时会被触发相对于全收集而言，收集间隔较短\n\n##### 全收集器\n\nFull GC，指发生在老年代的 GC，出现了 Full GC 一般会伴随着至少一次的 Minor GC（老年代的对象大部分是 Scavenge GC 过程中从新生代进入老年代），比如：分配担保失败。FullGC 的速度一般会比 Scavenge GC 慢 10 倍以上。当老年代内存不足或者显式调用 System.gc()方法时，会触发 Full GC。\n\n当老年代或者持久代堆空间满了，会触发全收集操作可以使用 System.gc()方法来显式的启动全收集全收集一般根据堆大小的不同，需要的时间不尽相同，但一般会比较长。\n\n##### 垃圾回收器的常规匹配\n\n![img](https://alightyoung.gitee.io/static/img/9.png)\n\n#### 常见垃圾回收算法\n\n##### 引用计数（Reference Counting）\n\n比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为 0 的对象。此算法最致命的是无法处理循环引用的问题。\n\n##### 复制（Copying）\n\n此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。简图如下：\n![img](https://alightyoung.gitee.io/static/img/10.png)\n\n##### 标记-清除（Mark-Sweep）\n\n此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。简图如下：\n![img](https://alightyoung.gitee.io/static/img/11.webp)\n\n##### 标记-整理（Mark-Compact）\n\n此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。简图如下：\n![img](https://alightyoung.gitee.io/static/img/12.webp)\n\n#### 分代垃圾收集器\n\n##### 串行收集器（Serial）\n\nSerial 收集器是 Hotspot 运行在 Client 模式下的默认新生代收集器, 它的特点是：只用一个 CPU（计算核心）一条收集线程去完成 GC 工作, 且在进行垃圾收集时必须暂停其他所有的工作线程(“Stop The World” -后面简称 STW)。可以使用-XX:+UseSerialGC 打开。虽然是单线程收集, 但它却简单而高效, 在 VM 管理内存不大的情况下(收集几十 M~一两百 M 的新生代), 停顿时间完全可以控制在几十毫秒~一百多毫秒内。\n![img](https://alightyoung.gitee.io/static/img/13.png)\n\n##### 并行收集器（ParNew）\n\nParNew 收集器其实是前面 Serial 的多线程版本, 除使用多条线程进行 GC 外, 包括 Serial 可用的所有控制参数、收集算法、STW、对象分配规则、回收策略等都与 Serial 完全一样(也是 VM 启用 CMS 收集器-XX: +UseConcMarkSweepGC 的默认新生代收集器)。由于存在线程切换的开销, ParNew 在单 CPU 的环境中比不上 Serial, 且在通过超线程技术实现的两个 CPU 的环境中也不能 100%保证能超越 Serial. 但随着可用的 CPU 数量的增加,收集效率肯定也会大大增加(ParNew 收集线程数与 CPU 的数量相同, 因此在 CPU 数量过大的环境中, 可用 `-XX:ParallelGCThreads=\u003CN>` 参数控制 GC 线程数)。\n![img](https://alightyoung.gitee.io/static/img/14.png)\n\n##### Parallel Scavenge 收集器\n\n与 ParNew 类似, Parallel Scavenge 也是使用复制算法, 也是并行多线程收集器. 但与其他收集器关注尽可能缩短垃圾收集时间不同, Parallel Scavenge 更关注系统吞吐量:系统吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)停顿时间越短就越适用于用户交互的程序-良好的响应速度能提升用户的体验;而高吞吐量则适用于后台运算而不需要太多交互的任务-可以最高效率地利用 CPU 时间,尽快地完成程序的运算任务. Parallel Scavenge 提供了如下参数设置系统吞吐量:\nParallel Scavenge 参数|描述\n---|---\n-XX:MaxGCPauseMillis | (毫秒数) 收集器将尽力保证内存回收花费的时间不超过设定值, 但如果太小将会导致 GC 的频率增加.\n-XX:GCTimeRatio|(整数:`0 \u003C GCTimeRatio \u003C 100`) 是垃圾收集时间占总时间的比率\nXX:+UseAdaptiveSizePolicy|启用 GC 自适应的调节策略: 不再需要手工指定-Xmn-XX:SurvivorRatio-XX:PretenureSizeThreshold 等细节参数, VM 会根据当前系统的运行情况收集性能监控信息, 动态调整这些参数以提供最合适的停顿时间或最大的吞吐量\n\n##### Serial Old 收集器\n\nSerial Old 是 Serial 收集器的老年代版本, 同样是单线程收集器,使用“标记-整理”算法\n![img](https://alightyoung.gitee.io/static/img/15.png)\n\n##### Parallel Old 收集器\n\nParallel Old 是 Parallel Scavenge 收集器的老年代版本, 使用多线程和“标记－整理”算\n法, 吞吐量优先, 主要与 Parallel Scavenge 配合在注重吞吐量及 CPU 资源敏感系统内使用；\n![img](https://alightyoung.gitee.io/static/img/16.png)\n\n##### CMS 收集器（Concurrent Mark Sweep）\n\nCMS(Concurrent Mark Sweep)收集器是一款具有划时代意义的收集器, 一款真正意义上的并发收集器, 虽然现在已经有了理论意义上表现更好的 G1 收集器, 但现在主流互联网企业线上选用的仍是 CMS(如 Taobao、微店).\n\nCMS 是一种以获取最短回收停顿时间为目标的收集器(CMS 又称多并发低暂停的收集器),\n基于”标记-清除”算法实现, 整个 GC 过程分为以下 4 个步骤:\n\n1. 初始标记(CMS initial mark)\n2. 并发标记(CMS concurrent mark: GC Roots Tracing 过程)\n3. 重新标记(CMS remark)\n4. 并发清除(CMS concurrent sweep: 已死对象将会就地释放, 注意:此处没有压缩)\n\n其中 1，3 两个步骤(初始标记、重新标记)仍需 STW. 但初始标记仅只标记一下 GC Roots 能直接关联到的对象, 速度很快; 而重新标记则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录, 虽然一般比初始标记阶段稍长, 但要远小于并发标记时间.\n![img](https://alightyoung.gitee.io/static/img/17.png)\n\n**CMS 特点：**\nCMS 默认启动的回收线程数=(CPU 数目+3),当 CPU 数 > 4 时, GC 线程一般占用不超过 25%的 CPU 资源, 但是当 CPU 数 `\u003C=` 4 时, GC 线程可能就会过多的占用用户 CPU 资源, 从而导致应用程序变慢, 总吞吐量降低.\n\n无法处理浮动垃圾, 可能出现 Promotion Failure、Concurrent Mode Failure 而导致另一次 Full GC 的产生: 浮动垃圾是指在 CMS 并发清理阶段用户线程运行而产生的新垃圾. 由于在 GC 阶段用户线程还需运行, 因此还需要预留足够的内存空间给用户线程使用, 导致 CMS 不 能 像 其 他收 集 器那 样 等到 老 年 代几 乎 填满 了 再进 行 收 集. 因此 CMS 提供了-XX:CMSInitiatingOccupancyFraction 参 数 来 设 置 GC 的 触 发 百 分 比 ( 以 及-XX:+UseCMSInitiatingOccupancyOnly 来启用该触发百分比), 当老年代的使用空间超过该比例后 CMS 就会被触发(JDK 1.6 之后默认 92%). 但当 CMS 运行期间预留的内存无法满足程序需要, 就会出现上述 Promotion Failure 等失败, 这时 VM 将启动后备预案: 临时启用 Serial Old 收集器来重新执行 Full GC(CMS 通常配合大内存使用, 一旦大内存转入串行的 Serial GC, 那停顿的时间就是大家都不愿看到的了).\n\n最后, 由于 CMS 采用”标记-清除”算法实现, 可能会产生大量内存碎片. 内存碎片过多可能会导致无 法分配大对象而提前触发 Full GC. 因 此 CMS 提供了-XX:+UseCMSCompactAtFullCollection 开关参数, 用于在 Full GC 后再执行一个碎片整理过程.但内存整理是无法并发的, 内存碎片问题虽然没有了, 但停顿时间也因此变长了, 因此 CMS 还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction 用于设置在执行 N 次不进行内存整理的 Full GC 后, 跟着来一次带整理的(默认为 0: 每次进入 Full GC 时都进行碎片整理).\n\n##### 分区收集- G1 收集器\n\nG1(Garbage-First)是一款面向服务端应用的收集器, 主要目标用于配备多颗 CPU 的服务器治理大内存.\n\n-G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector(CMS).\n\n-XX:+UseG1GC 启用 G1 收集器.\n\n与其他基于分代的收集器不同, G1 将整个 Java 堆划分为多个大小相等的独立区域(Region), 虽然还保留有新生代和老年代的概念, 但新生代和老年代不再是物理隔离的了,它们都是一部分 Region(不需要连续)的集合.如：\n![img](https://alightyoung.gitee.io/static/img/18.png)\n\n每块区域既有可能属于 O 区、也有可能是 Y 区, 因此不需要一次就对整个老年代/新生代回收. 而是当线程并发寻找可回收的对象时, 有些区块包含可回收的对象要比其他区块多很多. 虽然在清理这些区块时 G1 仍然需要暂停应用线程, 但可以用相对较少的时间优先回收垃圾较多的 Region. 这种方式保证了 G1 可以在有限的时间内获取尽可能高的收集效率.\n\nG1 的新生代收集跟 ParNew 类似: 存活的对象被转移到一个/多个 Survivor Regions. 如果存活时间达到阀值, 这部分对象就会被提升到老年代.如图：\n![img](https://alightyoung.gitee.io/static/img/19.png)\n\n其特定是：\n\n-   一整块堆内存被分为多个 Regions.\n-   存活对象被拷贝到新的 Survivor 区或老年代.\n-   年轻代内存由一组不连续的 heap 区组成, 这种方法使得可以动态调整各代区域尺寸.\n-   Young GC 会有 STW 事件, 进行时所有应用程序线程都会被暂停.\n-   多线程并发 GC.\n\nG1 老年代 GC 特点如下:\n\n并发标记阶段\n\n1. 在与应用程序并发执行的过程中会计算活跃度信息.\n2. 这些活跃度信息标识出那些 regions 最适合在 STW 期间回收(which regions will be best to reclaim during an evacuation pause).\n3. 不像 CMS 有清理阶段.\n\n再次标记阶段\n\n1. 使用 Snapshot-at-the-Beginning(SATB)算法比 CMS 快得多.\n2. 空 region 直接被回收.\n\n拷贝/清理阶段(Copying/Cleanup Phase)\n\n1. 年轻代与老年代同时回收.\n2. 老年代内存回收会基于他的活跃度信息.\n\n### JVM 优化\n\n#### JDK 常用 JVM 优化相关命令\n\n| bin       | 描述                                                                                       | 功能                                                                        |\n| --------- | ------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------- |\n| jps       | 打印 Hotspot VM 进程                                                                       | VMID、JVM 参数、main()函数参数、主类名/Jar 路径                             |\n| jstat     | 查看 Hotspot VM 运行时信息                                                                 | 类加载、内存、GC[可分代查看]、JIT 编译命令格式：jstat -gc 10340250 20       |\n| jinfo     | 查看和修改虚拟机各项配置                                                                   | -flag name=value                                                            |\n| jmap      | heapdump: 生成 VM 堆转储快照、查询 finalize 执行队列、Java 堆和永久代详细信息              | jmap-dump:live,format=b,file=heap.bin[VMID]                                 |\n| jstack    | 查看 VM 当前时刻的线程快照: 当前 VM 内每一条线程正在执行的方法堆栈集合                     | Thread.getAllStackTraces()提供了类似的功能                                  |\n| javap     | 查看经 javac 之后产生的 JVM 字节码代码                                                     | 自动解析.class 文件, 避免了去理解 class 文件格式以及手动解析 class 文件内容 |\n| jcmd      | 一个多功能工具, 可以用来导出堆, 查看 Java 进程、导出线程信息、 执行 GC、查看性能相关数据等 | 几乎集合了 jps、jstat、jinfo、jmap、jstack 所有功能                         |\n| jconsole  | 基于 JMX 的可视化监视、管理工具                                                            | 可以查看内存、线程、类、CPU 信息, 以及对 JMX MBean 进行管理                 |\n| jvisualvm | JDK 中最强大运行监视和故障处理工具                                                         | 可以监控内存泄露、跟踪垃圾回收、执行时内存分析、CPU 分析、线程分析…         |\n\n##### jps\n\njps -l：显示线程 id 和执行线程的主类名\njps -v：显示线程 id 和执行线程的主类名和 JVM 配置信息\n\n##### jstat\n\njstat -参数 线程 id 执行时间（单位毫秒） 执行次数\n\njstat -gc 4488 30 10\n\n![](https://s2.ax1x.com/2019/11/22/MTlnI0.png)\n\n-   SXC -survivor 初始空间大小，单位字节。\n-   SXU - survivor 使用空间大小， 单位字节。\n-   EC - eden 初始空间大小\n-   EU - eden 使用空间大小\n-   OC - old 初始空间大小\n-   OU - old 使用空间大小\n-   PC - permanent 初始空间大小\n-   PU - permanent 使用空间大小\n-   YGC - youngGC 收集次数\n-   YGCT - youngGC 收集使用时长， 单位秒\n-   FGC - fullGC 收集次数\n-   FGCT - fullGC 收集使用时长\n-   GCT - 总计收集使用总时长 YGCT+FGCT\n\n##### Java VisualVM\n\n一个 JDK 内置的图形化 VM 监视管理工具\n\n##### visualgc 插件\n\nJava VisualVM 中使用的插件\n\n#### JVM 常见参数\n\n配置方式：java [options] MainClass [arguments]\n\noptions - JVM 启动参数。 配置多个参数的时候，参数之间使用空格分隔。\n\n参数命名： 常见为 -参数名\n\n参数赋值： 常见为 -参数名=参数值 | -参数名:参数值\n\n##### 内存设置\n\n-   -Xms:初始堆大小，JVM 启动的时候，给定堆空间大小。\n-   -Xmx:最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。\n-   -Xmn：设置年轻代大小。整个堆大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为 64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun 官方推荐配置为整个堆的 3/8。\n-   -Xss： 设置每个线程的 Java 栈大小。JDK5.0 以后每个线程 Java 栈大小为 1M，以前每个线程堆栈大小为 256K。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。\n-   -XX:NewSize=n:设置年轻代大小\n-   -XX:NewRatio=n:设置年轻代和年老代的比值。如:为 3，表示年轻代与年老代比值为 1：3，年轻代占整个年轻代+年老代和的 1/4\n-   -XX:SurvivorRatio=n:年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。如：3，表示 Eden：Survivor=3：2，一个 Survivor 区占整个年轻代的 1/5\n-   -XX:MaxPermSize=n:设置持久代大小\n-   -XX:MaxTenuringThreshold：设置垃圾最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。\n\n##### 内存设置经验分享\n\nJVM 中最大堆大小有三方面限制：相关操作系统的数据模型（32-bt 还是 64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32 位系统 下，一般限制在 1.5G~2G；64 为操作系统对内存无限制。\n\nTomcat 配置方式： 编写 catalina.bat|catalina.sh，增加 JAVA_OPTS 参数设置。windows\n和 linux 配置方式不同。windows - set \"JAVA_OPTS=%JAVA_OPTS% 自定义参数\"；linux -\nJAVA_OPTS=\"$JAVA_OPTS 自定义参数\"\n\n常见设置：\n\n-   -Xmx3550m -Xms3550m -Xmn2g -Xss128k 适合开发过程的测试应用。要求物理内存大于 4G。\n-   -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4\n-   -XX:MaxPermSize=160m -XX:MaxTenuringThreshold=0 适合高并发本地测试使用。且大数据对象相对较多（如 IO 流）环境： 16G 物理内存，高并发服务，重量级对象中等（线程池，连接池等），常用对象\n    比例为 40%（运行过程中产生的对象 40%是生命周期较长的）\n-   -Xmx10G -Xms10G -Xss1M -XX:NewRatio=3 -XX:SurvivorRatio=4 -XX:MaxPermSize=2048m\n-   -XX:MaxTenuringThreshold=5\n\n##### 收集器设置\n\n收集器配置的时候，次收集器和全收集器必须匹配。\n\n-   -XX:+UseSerialGC:设置串行收集器，年轻带收集器， 次收集器\n-   -XX:+UseParallelGC:设置并行收集器\n-   -XX:+UseParNewGC:设置年轻代为并行收集。可与 CMS 收集同时使用。JDK5.0 以上，JVM 会根据系统配置自行设置，所以无需再设置此值。\n-   -XX:+UseParallelOldGC:设置并行年老代收集器，JDK6.0 支持对年老代并行收集。\n-   -XX:+UseConcMarkSweepGC:设置年老代并发收集器，测试中配置这个以后，-XX:NewRatio 的配置失效，原因不明。所以，此时年轻代大小最好用-Xmn 设置。\n-   -XX:+UseG1GC:设置 G1 收集器\n\n##### 垃圾回收统计信息\n\n类似日志的配置信息。会有控制台相关信息输出。 商业项目上线的时候，不允许使用。\n一定使用 loggc\n\n-   -XX:+PrintGC\n-   -XX:+Printetails\n-   -XX:+PrintGCTimeStamps\n-   -Xloggc:filename\n\n##### 并行收集器设置\n\n-   -XX:ParallelGCThreads=n:设置并行收集器收集时最大线程数使用的 CPU 数。并行收集线程数。\n-   -XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间，单位毫秒。可以减少 STW 时间。\n-   -XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为 1/(1+n)并发收集器设置\n-   -XX:+CMSIncrementalMode:设置为增量模式。适用于单 CPU 情况。\n-   -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的 Survivor 区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。\n-   -XX:CMSFullGCsBeforeCompaction=n：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次 GC 以后对内存空间进行压缩、整理。\n-   -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可\n    以消除碎片\n\n##### 收集器设置经验分享\n\n关于收集器的选择 JVM 给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。\n\n默认情况下，JDK5.0 以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0 以后，JVM 会根据当前系统配置进行判断。\n\n常见配置：\n\n并行收集器主要以到达一定的吞吐量为目标，适用于科学计算和后台处理等。\n\n> -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20\n> 使用 ParallelGC 作为并行收集器， GC 线程为 20（CPU 核心数 `>=` 20 时），内存问题根据硬件配置具体提供。建议使用物理内存的 80%左右作为 JVM 内存容量。\n\n> -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20\n> -XX:+UseParallelOldGC\n> 指定老年代收集器，在 JDK5.0 之后的版本，ParallelGC 对应的全收集器就是 ParallelOldGC。可以忽略\n\n> -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100\n> 指定 GC 时最大暂停时间。单位是毫秒。每次 GC 最长使用 100 毫秒。可以尽可能提高工作线程的执行资源。\n\n> -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100\n> -XX:+UseAdaptiveSizePolicy\n> UseAdaptiveSizePolicy 是提高年轻代 GC 效率的配置。次收集器执行效率。并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域、互联网领域等。\n\n> -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20-XX:+UseConcMarkSweepGC -XX:+UseParNewGC\n> 指定年轻代收集器为 ParNew，年老代收集器 ConcurrentMarkSweep，并发 GC 线程数为 20（CPU 核心 `>=` 20），并发 GC 的线程数建议使用（CPU 核心数+3）/4 或 CPU 核心数【不推荐使用】。\n\n> -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC\n> -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection\n> CMSFullGCsBeforeCompaction=5 执行 5 次 GC 后，运行一次内存的整理。UseCMSCompactAtFullCollection 执行老年代内存整理。可以避免内存碎片，提高 GC 过程中的效率，减少停顿时间。\n\n##### 简单总结\n\n**年轻代大小选择**\n\n响应时间优先的应用：尽可能设大，直到接近系统的最低响应时间限制（根据实际情况选择）。在此种情况下，年轻代收集发生的频率也是最小的。同时，减少到达年老代的对象。\n\n吞吐量优先的应用：尽可能的设置大，可能到达 Gbit 的程度。因为对响应时间没有要求，垃圾收集可以并行进行，一般适合 8CPU 以上的应用。\n\n**年老代大小选择**\n\n响应时间优先的应用：年老代使用并发收集器，所以其大小需要小心设置，一般要考虑并发会话率和会话持续时间等一些参数。如果堆设置小了，可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了，则需要较长的收集时间。最优化的方案，一般需要参考以下数据获得：并发垃圾收集信息持久代并发收集次数传统 GC 信息花在年轻代和年老代回收上的时间比例减少年轻代和年老代花费的时间，一般会提高应用的效率\n\n吞吐量优先的应用：一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代。原因是，这样可以尽可能回收掉大部分短期对象，减少中期的对象，而年老代存放长期存活对象。\n\n较小堆引起的碎片问题，因为年老代的并发收集器使用标记、清除算法，所以不会对堆进行压缩。当收集器回收时，他会把相邻的空间进行合并，这样可以分配给较大的对象。但是，当堆空间较小时，运行一段时间以后，就会出现“碎片”，如果并发收集器找不到足够的空间，那么并发收集器将会停止，然后使用传统的标记、整理方式进行回收。如果出现“碎片”，可能需要进行如下配置：\n\n-XX:+UseCMSCompactAtFullCollection：使用并发收集器时，开启对年老代的压缩。\n-XX:CMSFullGCsBeforeCompaction=0：上面配置开启的情况下，这里设置多少次 Full GC\n后，对年老代进行压缩\n\n### over\n","\r\n### 简介\r\n《Java 开发手册》起源里阿里，最开始还是叫《阿里巴巴Java开发手册》，不过后来公开之后很多社区开发者也参与到该手册的完善中，所以最后改成了《Java 开发手册》。该手册涉及的面很多，总的来说分成了7大块——**编程规约**、**异常日志**、**单元测试**、**安全规约**、**MySQL 数据库**、**工程结构**、**设计规约**，十分详细。同时还有IDE插件[Java开发规约IDE插件](https://github.com/alibaba/p3c)，感兴趣可以自行了解。\r\n\r\n- [手册官网传送门](https://developer.aliyun.com/special/tech-java)。\r\n\r\n    - [华山版手册传送门pdf文件](https://alightyoung.gitee.io/static/pdf/Java-huashanxinban.pdf)\r\n    - 版本代号：1.5.0\r\n    - 更新日期：2019.06.19 \r\n    - 制定团队：阿里巴巴与 Java 社区开发者\r\n\r\n### over\r\n传送门真省事 - -\r\n\r\n\r\n\r\n\r\n","\n### 网络编程（Socket）概念\n\n>首先注意，Socket 不是 Java 中独有的概念，而是一个语言无关标准。任何可以实现网络编程的编程语言都有 Socket。\n\n#### Socket\n网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。\n\n建立网络通信连接至少要一个**端口号**。socket 本质是编程接口(API)，对 **TCP/IP** 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口\n\nHTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的进程通信机制，取后一种意思。通常也称作\"套接字\"，用于描述 IP 地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在Internet 上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个 Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。\n\n#### Socket 连接步骤\n根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：**服务器监听**，**客户端请求**，**连接确认**。【如果包含**数据交互**+**断开连接**，那么一共是五个步骤】\n\n1. 服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。\n\n2. 客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。\n\n3. 连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。\n![img](https://alightyoung.gitee.io/static/img/25.png)\n\n#### Java 中的 Socket\n在 java.net 包是网络编程的基础类库。其中 ServerSocket 和 Socket 是网络编程的基础类型。ServerSocket 是服务端应用类型。Socket 是建立连接的类型。当连接建立成功后，服务器和客户端都会有一个 Socket 对象示例，可以通过这个 Socket 对象示例，完成会话的所有操作。对于一个完整的网络连接来说，Socket 是平等的，没有服务器客户端分级情况。\n\n### 同步&异步\n同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发 IO 操作并等待或者轮询的去看 IO 操作是否就绪，而异步是指用户进程触发 IO 操作以后便开始做自己的事情，而当 IO 操作已经完成的时候会得到 IO 完成的通知。以银行取款为例：\n\n同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 IO 时，Java 自己处理 IO 读写）\n\n异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步 IO 时，Java 将 IO 读写委托给 OS 处理，需要将数据缓冲区地址和大小传给 OS(银行卡和密码)，OS 需要支持异步 IO操作 API）。\n\n### 阻塞&非阻塞\n阻塞和非阻塞是针对于进程在访问数据的时候，根据 IO 操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。以银行取款为例：阻塞 ： ATM 排队取款，你只能等待（使用阻塞 IO 时，Java 调用会一直阻塞到读写完成才返回）；非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞 IO 时，如果不能读写 Java 调用会马上返回，当 IO 事件分发器通知可读写时再继续进行读写，不断循环直到读写完成）。\n\n### BIO 编程\nBlocking IO： 同步阻塞的编程方式。\n\nBIO 编程方式通常是在 JDK1.4 版本之前常用的编程方式。编程实现过程为：首先在服务端启动一个 ServerSocket 来监听网络请求，客户端启动 Socket 发起网络请求，默认情况下ServerSocket 会建立一个线程来处理此请求，如果服务端没有线程可用，客户端则会阻塞等待或遭到拒绝。且已经建立好的连接，在通讯过程中，是同步的。在并发处理效率上比较低。大致结构如下：\n![img](https://alightyoung.gitee.io/static/img/26.png)\n同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。\n\nBIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，但程序直观简单易理解。\n\n使用线程池机制改善后的 BIO 模型图如下:\n![img](https://alightyoung.gitee.io/static/img/27.png)\n\n### NIO 编程\nUnblocking IO（New IO）： 同步非阻塞的编程方式。\n\nNIO 本身是基于事件驱动思想来完成的，其主要想解决的是 BIO 的大并发问题，NIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。\n\nNIO 的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。\n\n在 NIO 的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC 连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有 BIO 一样的问题。\n![img](https://alightyoung.gitee.io/static/img/28.png)\n\n同步非阻塞，服务器实现模式为一个请求一个通道，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 I/O 请求时才启动一个线程进行处理。\n\nNIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程复杂，JDK1.4 开始支持。\n\n### AIO 编程\nAsynchronousIO： 异步非阻塞的编程方式\n\n与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。在 JDK1.7 中，这部分内容被称作 NIO.2，主要在 java.nio.channels 包下增加了下面四个异步通道：\n\n- AsynchronousSocketChannel\n- AsynchronousServerSocketChannel\n- AsynchronousFileChannel\n- AsynchronousDatagramChannel\n\n异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的 I/O 请求都是由 OS先完成了再通知服务器应用去启动线程进行处理\n\nAIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK7 开始支持。\n\n\n\n","\r\n### Netty简介\r\nNetty 是由 JBOSS 提供的一个 java 开源框架。Netty 提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。\r\n\r\n也就是说，Netty 是一个基于 NIO 的客户、服务器端编程框架，使用 Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。Netty 相当简化和流线化了网络应用的编程开发过程，例如，TCP 和 UDP 的 socket 服务开发。\r\n\r\n“快速”和“简单”并不用产生维护或性能上的问题。Netty 是一个吸收了多种协议的实现经验，这些协议包括FTP,SMTP,HTTP，各种二进制，文本协议，并经过相当精心设计的项目，最终，Netty 成功的找到了一种方式，在保证易于开发的同时还保证了其应用的性能，稳定性和伸缩性。\r\n\r\nNetty 从 4.x 版本开始，需要使用 JDK1.6 及以上版本提供基础支撑。\r\n\r\n在设计上：针对多种传输类型的统一接口 - 阻塞和非阻塞；简单但更强大的线程模型；真正的无连接的数据报套接字支持；链接逻辑支持复用\r\n\r\n在性能上：比核心 Java API 更好的吞吐量，较低的延时；资源消耗更少，这个得益于共享池和重用；减少内存拷贝\r\n\r\n在健壮性上：消除由于慢，快，或重载连接产生的 OutOfMemoryError；消除经常发现在 NIO 在高速网络中的应用中的不公平的读/写比\r\n\r\n在安全上：完整的 SSL / TLS 和 StartTLS 的支持且已得到大量商业应用的真实验证,如：Hadoop 项目的 Avro（RPC 框架）、Dubbo、Dubbox等 RPC 框架。\r\n\r\n### Netty 架构\r\n![img](https://alightyoung.gitee.io/static/img/20.png)\r\n\r\n\r\n### Netty线程模型\r\n\r\n![img](https://alightyoung.gitee.io/static/img/21.jpg)\r\n\r\n### 线程模型详解\r\nNetty 中支持单线程模型，多线程模型，主从多线程模型。\r\n\r\n#### Reactor单线程模型\r\n是指所有的I/O操作都在同一个NIO线程上完成，职责如下\r\n\r\n- 作为NIO服务端，接收客户端TCP连接\r\n- 作为NIO客户端，向服务端发起TCP连接\r\n- 读取对端请求或者应答消息\r\n- 向对端发送请求或者应答消息\r\n\r\n![img](https://alightyoung.gitee.io/static/img/22.jpg)\r\n\r\n在一些小容量场景下，可以使用多线程模型，但对于高负载场景下并不适用，原因如下：\r\n\r\n- 一个NIO线程同时处理成百上千的连接，性能上无法保证。\r\n- NIO线程负载过重，处理速度会越来越慢，会导致大量客户端连接超时\r\n- 一旦NIO线程跑飞，或者死循环，会导致整个系统的不可用\r\n\r\n#### Reactor多线程模型\r\n\r\n![img](https://alightyoung.gitee.io/static/img/23.jpg)\r\n\r\n与单线程模型最大的区别是，有一组NIO来处理I/O请求，特点如下\r\n\r\n- 有一个NIO线程——Acceptor线程用户监听客户端的连接\r\n- 有一个NIO线程池负责I/O的读写操作，该线程池可以是基于JDK的线程池。\r\n\r\n#### 主从Reactor多线程模型\r\n\r\n![img](https://alightyoung.gitee.io/static/img/24.jpg)\r\n\r\n如果并发百万的客户端连接，在Reactor多线程模型下只有一个NIO的Acceptor线程处理客户端连接会有性能问题。主从Reactor线程模型的特点是：服务端用于接收客户端的连接不再是一个单独的NIO线程，而是一个NIO的Acceptor线程池。Acceptor接收到客户端的TCP连接请求处理完成后，将新创建的ChannelSocket注册到I/O线程池(sub reactor线程池)上的某一个线程上，由I/O负责后续的I/O读写操作。\r\n\r\n### 快速入门\r\n[4.x版本传送门](https://netty.io/wiki/user-guide-for-4.x.html#wiki-h2-3)\r\n\r\n### 流数据的传输处理\r\n在基于流的传输里比如 TCP/IP，接收到的数据会先被存储到一个 socket 接收缓冲里。不幸的是，基于流的传输并不是一个数据包队列，而是一个字节队列。即使你发送了 2 个独立的数据包，操作系统也不会作为 2 个消息处理而仅仅是作为一连串的字节而言。因此这是不能保证你远程写入的数据就会准确地读取。所以一个接收方不管他是客户端还是服务端，都应该把接收到的数据整理成一个或者多个更有意思并且能够让程序的业务逻辑更好理解的数据。\r\n\r\n在处理流数据粘包拆包时，可以使用下述处理方式：\r\n\r\n- 使用定长数据处理，如：每个完整请求数据长度为 8 字节等。（FixedLengthFrameDecoder）\r\n- 使用特殊分隔符的方式处理，如：每个完整请求数据末尾使用’\\0’作为数据结束标记。（DelimiterBasedFrameDecoder）\r\n- 使用自定义协议方式处理，如：http 协议格式等。\r\n- 使用 POJO 来替代传递的流数据，如：每个完整的请求数据都是一个 RequestMessage对象，在 Java 语言中，使用 POJO 更符合语种特性，推荐使用。\r\n\r\n\r\n\r\n\r\n","\n\u003CBadge text=\"简单\" type=\"tip\"/> 原题链接：[https://leetcode-cn.com/problems/two-sum/](https://leetcode-cn.com/problems/two-sum/)\n\n## 题目描述\n\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n\n你可以按任意顺序返回答案。\n\n:::details{text=\"示例 1\"}\n输入：nums = [2,7,11,15], target = 9\n\n输出：[0,1]\n\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n:::\n\n:::details{text=\"示例 2\"}\n输入：nums = [3,2,4], target = 6\n\n输出：[1,2]\n:::\n\n:::details{text=\"示例 3\"}\n输入：nums = [3,3], target = 6\n\n输出：[0,1]\n:::\n\n:::details{text=\"提示\"}\n\n- `2 \u003C= nums.length \u003C= 104`\n- `-109 \u003C= nums[i] \u003C= 109`\n- `-109 \u003C= target \u003C= 109`\n- `只会存在一个有效答案`\n\n进阶：你可以想出一个时间复杂度小于 O(n2) 的算法吗？\n:::\n\n## Java题解\n\n### 解法一：暴力法\n\n暴力法很简单，遍历每个元素 x，并查找是否存在一个值与 target - x 相等的目标元素。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n       for(int i=0;i\u003Cnums.length;i++){\n           for(int j = i+1;j\u003Cnums.length;j++){\n               if(nums[i]+nums[j]==target){\n                return new int[]{i,j};\n               }\n           }\n       }\n        return null;\n    }\n}\n```\n**复杂度**\n\n$$\nx = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\n$$\n\n- 时间复杂度：$O(n^2)$，对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 $O(n)$ 的时间。因此时间复杂度为 $O(n^2)$。\n- 空间复杂度：$O(1)$。\n\n### 解法二：两遍哈希表\n为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。\n\n通过以空间换取速度的方式，我们可以将查找时间从 O(n) 降低到 O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。\n\n一个简单的实现使用了两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。注意，该目标元素不能是 nums[i] 本身！\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map\u003CInteger, Integer> map = new HashMap\u003C>();\n        for (int i = 0; i \u003C nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i \u003C nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```\n\n\n**复杂度分析：**\n\n- 时间复杂度：O(n)，\n我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。\n\n- 空间复杂度：O(n)，\n所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。\n\n### 方法三：一遍哈希表\n事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map\u003CInteger, Integer> map = new HashMap\u003C>();\n        for (int i = 0; i \u003C nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}\n```\n**复杂度分析：**\n\n- 时间复杂度：O(n)，\n我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1) 的时间。\n\n- 空间复杂度：O(n)，\n所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素。\n\n## 总结\n不得不感叹一下，一遍哈希表绝了！\n\n","\n\u003CBadge text=\"中等\" type=\"warning\"/>\n原题链接：[https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)\n\n## 题目描述\n\n给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。\n\n:::details{text=\"示例 1\"}\n输入: s = \"abcabcbb\"\n\n输出: 3\n\n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。\n:::\n\n:::details{text=\"示例 2\"}\n输入: s = \"bbbbb\"\n\n输出: 1\n\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n:::\n\n:::details{text=\"示例 3\"}\n输入: s = \"pwwkew\"\n\n输出: 3\n\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n\n请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n:::\n\n:::details{text=\"示例 4\"}\n输入: s = \"\"\n\n输出: 0\n:::\n\n:::details{text=\"提示\"}\n`0 \u003C= s.length \u003C= 5 * 104`\n\ns 由英文字母、数字、符号和空格组成\n:::\n\n## Java题解\n\n### 方法一 暴力法\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        int ans = 0;\n        for (int i = 0; i \u003C n; i++)\n            for (int j = i + 1; j \u003C= n; j++)\n                if (allUnique(s, i, j)) ans = Math.max(ans, j - i);\n        return ans;\n    }\n\n    public boolean allUnique(String s, int start, int end) {\n        Set\u003CCharacter> set = new HashSet\u003C>();\n        for (int i = start; i \u003C end; i++) {\n            Character ch = s.charAt(i);\n            if (set.contains(ch)) return false;\n            set.add(ch);\n        }\n        return true;\n    }\n}\n```\n\n### 方法二 滑动窗口\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length();\n        Set\u003CCharacter> set = new HashSet\u003C>();\n        int ans = 0, i = 0, j = 0;\n        while (i \u003C n && j \u003C n) {\n            // try to extend the range [i, j]\n            if (!set.contains(s.charAt(j))){\n                set.add(s.charAt(j++));\n                ans = Math.max(ans, j - i);\n            }\n            else {\n                set.remove(s.charAt(i++));\n            }\n        }\n        return ans;\n    }\n}\n```\n\n### 方法三：优化的滑动窗口\n\n```java\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        Map\u003CCharacter, Integer> map = new HashMap\u003C>(); // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j \u003C n; j++) {\n            if (map.containsKey(s.charAt(j))) {\n                i = Math.max(map.get(s.charAt(j)), i);\n            }\n            ans = Math.max(ans, j - i + 1);\n            map.put(s.charAt(j), j + 1);\n        }\n        return ans;\n    }\n}\n```\n```java\n// int [26] 用于字母 ‘a’ - ‘z’ 或 ‘A’ - ‘Z’\n// int [128] 用于ASCII码\n// int [256] 用于扩展ASCII码\npublic class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        int[] index = new int[128]; // current index of character\n        // try to extend the range [i, j]\n        for (int j = 0, i = 0; j \u003C n; j++) {\n            i = Math.max(index[s.charAt(j)], i);\n            ans = Math.max(ans, j - i + 1);\n            index[s.charAt(j)] = j + 1;\n        }\n        return ans;\n    }\n}\n```\n\n## 总结\n该题最大的收获，可能就是了解到了滑动窗口的概念吧。\n\n还有就是即使是暴力法，也可能出现考虑不周全导致复杂度增加的可能，比如这样：\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int max=1;\n        if(s.length()==0) {\n            max=0;\n            return max;\n        }else{\n            for(int i=0;i\u003Cs.length();i++){\n                for(int j=i+1;j\u003Cs.length();j++){\n                    if(allUnique(s,i,j)) max=Math.max(max,j-i+1);\n                }\n            }\n            return max;\n        }\n    }\n    public boolean allUnique(String s, int start, int end) {\n        Set\u003CCharacter> set = new HashSet\u003C>();\n        for(int i=start;i\u003C=end;i++){\n            char ch = s.charAt(i);\n            if (set.contains(ch)) return false;\n            set.add(ch);\n        }\n        return true;\n    }\n}\n```\n8说了，算法是真的🐂🍺！\n\n\n\n","\r\n### 简介\r\n单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。\r\n\r\n#### 优点\r\n- 提高用户效率\r\n- 提高开发人员的效率\r\n- 简化管理\r\n#### 缺点\r\n- 不利于重构\r\n- 无人看守桌面\r\n\r\n### 常见的单点登录框架\r\n\r\n1. [XXL-SSO](https://www.xuxueli.com/xxl-sso/)\r\n2. [CAS](https://www.apereo.org/projects/cas)（Central Authentication Service）\r\n> 非乐观锁里的CAS(compare and swap)\r\n\r\n#### xxlsso\r\n\r\n大概了解了一下之后，发现cas需要配置http证书，为了方便，所以选择了xxlsso作为单点登录的入门。想参考[官方文档](https://www.xuxueli.com/xxl-sso/)的也可以直接看。\r\n\r\n因为单点登录的场景基本是在分布式环境下，所以了解单点登录之前需要对分布式开发有所了解。\r\n\r\n##### 源码\r\n\r\n[gitee仓库](https://gitee.com/xuxueli0323/xxl-sso/releases)，跑入门demo可以先clone下来。了解一下流程\r\n\r\n##### 要求\r\n\r\n1. jdk:1.7+\r\n2. redis:4.0+\r\n\r\n##### demo结构\r\n```yml\r\n- xxl-sso-server：中央认证服务，支持集群\r\n- xxl-sso-core：Client端依赖\r\n- xxl-sso-samples：单点登陆Client端接入示例项目\r\n    - xxl-sso-web-sample-springboot：基于Cookie接入方式，供用户浏览器访问，springboot版本\r\n    - xxl-sso-token-sample-springboot：基于Token接入方式，常用于无法使用Cookie的场景使用，如APP、Cookie被禁用等，springboot版本\r\n```\r\n##### 部署\r\n> 1.配置认证中心\r\n没什么好说的，把xxlsso-server跑起来先，记得把application.properties的redis地址改成自己的\r\n\r\n> 2.配置client\r\n上面demo结构很清楚了，基于cookie就把web集成到自己的项目中，基于token就换成token的那个demo(细节参考[官方文档](https://www.xuxueli.com/xxl-sso/))\r\n\r\n##### 架构\r\n\r\n![架构图](https://alightyoung.gitee.io/static/img/4.png)\r\n\r\n**登录流程分析**\r\n> 用户于Client端应用访问受限资源时，将会自动 redirect 到 SSO Server 进入统一登录界面\r\n用户登录成功之后将会为用户分配 SSO SessionId 并 redirect 返回来源Client端应用，同时附带分配的 SSO SessionId\r\n在Client端的SSO Filter里验证 SSO SessionId 无误，将 SSO SessionId 写入到用户浏览器Client端域名下 cookie 中\r\nSSO Filter验证 SSO SessionId 通过，受限资源请求放行\r\n\r\n**注销流程分析**\r\n> 用户与Client端应用请求注销Path时，将会 redirect 到 SSO Server 自动销毁全局 SSO SessionId，实现全局销毁\r\n然后，访问接入SSO保护的任意Client端应用时，SSO Filter 均会拦截请求并 redirect 到 SSO Server 的统一登录界面\r\n\r\n**基于Cookie，相关概念**\r\n\r\n> 登陆凭证存储：登陆成功后，用户登陆凭证被自动存储在浏览器Cookie中\r\nClient端校验登陆状态：通过校验请求Cookie中的是否包含用户登录凭证判断\r\n\r\n系统角色模型：\r\n- SSO Server：认证中心，提供用户登陆、注销以及登陆状态校验等功能\r\n- Client应用：受SSO保护的Client端Web应用，为用户浏览器访问提供服务\r\n- 用户：发起请求的用户，使用浏览器访问\r\n\r\n**基于Token，相关概念**\r\n\r\n> 登陆凭证存储：登陆成功后，获取到登录凭证（xxl_sso_sessionid=xxx），需要主动存储，如存储在 localStorage、Sqlite 中\r\nClient端校验登陆状态：通过校验请求 Header参数 中的是否包含用户登录凭证（xxl_sso_sessionid=xxx）判断；因此，发送请求时需要在 Header参数 中设置登陆凭证\r\n\r\n系统角色模型：\r\n- SSO Server：认证中心，提供用户登陆、注销以及登陆状态校验等功能\r\n- Client应用：受SSO保护的Client端Web应用，为用户请求提供接口服务\r\n- 用户：发起请求的用户，如使用Android、IOS、桌面客户端等请求访问\r\n\r\n**未登录状态请求处理**\r\n\r\n基于Cookie，未登录状态请求：\r\n\r\n- 页面请求：redirect 到SSO Server登录界面\r\n- JSON请求：返回未登录的JSON格式响应数据\r\n\r\n    - 数据格式：\r\n\r\n        - code：501 错误码\r\n        - msg：sso not login\r\n\r\n基于Token，未登录状态请求：\r\n\r\n- 返回未登录的JSON格式响应数据\r\n\r\n    - 数据格式：\r\n\r\n        - code：501 错误码\r\n        - msg：sso not login\r\n\r\ntodo...","\n## 简介\n\nSpringBoot 是由 Pivotal 团队在 2013 年开始研发、2014 年 4 月发布第一个版本的全新开源的轻量级框架。它基于 Spring4.0 设计，不仅继承了 Spring 框架原有的优秀特性，而且还通过简化配置来进一步简化了 Spring 应用的整个搭建和开发过程。另外 SpringBoot 通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。\n\n:::tip\nIDE：Intellij IDEA\n:::\n\n## hello world\n\n直接使用 IDEA 新建 Spring Initializr，然后和创建 maven 项目一样修改 group 和 artifact，type 为 maven project（默认就是），值得一提的是可以直接使用 jar 方式发布到生产环境，所以 packaging 可以选择 jar，然后 next，会要求选择依赖，这里先勾选个 web->spring web，以后需要可以追加，之后 next-finish。\n\n然后找到 src/main/java/包名/里面应该应该会有一个这样的文件\n\n```java\npackage com.alight.springbootdemo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class SpringBootDemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDemoApplication.class, args);\n    }\n\n}\n```\n\n可以直接在里面写 controller 像这样：\n\n```java\npackage com.alight.springbootdemo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@SpringBootApplication\npublic class SpringBootDemoApplication {\n    @RequestMapping(\"/\")\n    String home() {\n        return \"Hello World!\";\n    }\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootDemoApplication.class, args);\n    }\n\n}\n```\n\n然后打开浏览器 访问[localhost:8080](http://localhost:8080)\n\n然后它就输出了 hello world，so cool。\n\n## 创建可执行 Jar\n\n通过创建可以在生产环境中运行的完全独立的可执行 jar 文件来结束示例。可执行 jar（有时称为“fat jars”）是包含您的已编译类以及代码需要运行的所有 jar 依赖项的归档文件。\n\n:::tip\n**可执行 Jar 和 Java**\n\nJava 没有提供加载嵌套 jar 文件（jar 中本身包含的 jar 文件）的标准方法。如果您要分发独立的应用程序，则可能会出现问题。\n为了解决这个问题，许多开发人员使用 uber jars。uber jar 将来自应用程序所有依赖项的所有类打包到单个存档中。这种方法的问题在于，很难查看应用程序中包含哪些库。如果在多个 jar 中使用相同的文件名（但具有不同的内容），也可能会产生问题。\nSpring Boot 采用了另一种方法，实际上允许您直接嵌套 jar。\n\n要创建可执行 jar，我们需要将添加`spring-boot-maven-plugin`到`pom.xml`。为此，请在该`dependencies`部分下方插入以下行：\n:::\n\n```xml\n\u003Cbuild>\n    \u003Cplugins>\n        \u003Cplugin>\n            \u003CgroupId>org.springframework.boot\u003C/groupId>\n            \u003CartifactId>spring-boot-maven-plugin\u003C/artifactId>\n        \u003C/plugin>\n    \u003C/plugins>\n\u003C/build>\n```\n\n如果刚才是使用上述方式创建的项目，则应该会自动添加该插件\n\n在项目根目录输入`mvn package`\n\n此时，如果查看 target 目录，则应该看到 spring-boot-demo-0.0.1-SNAPSHOT.jar。该文件的大小应为 10 MB 左右。如果您想窥视内部，可以使用`jar tvf`\n\n```\n$ jar tvf target / spring-boot-demo-0.0.1-SNAPSHOT.jar\n```\n\n您还应该在 target 目录中看到一个更小的文件 spring-boot-demo-0.0.1-SNAPSHOT.jar.original。这是 Maven 在 Spring Boot 重新打包之前创建的原始 jar 文件。\n\n要运行该应用程序，请使用以下 java -jar 命令：\n\n```\n$ java -jar target / spring-boot-demo-0.0.1-SNAPSHOT.jar\n```\n\n和以前一样，要退出该应用程序，请按 ctrl-c。\n\n## 格式化 JSON 时间\n\n在 REST API 中，返回的时间（json）将会是标准时间，加上时区等一大串字符，可读性会比较差。通常情况下，我们希望返回一个可读性比较强的时间，因此需要一些简单的配置。\n\n```yaml\nspring\n  jackson:\n    date-format: yyyy-MM-dd HH:mm:ss\n    time-zone: GMT+8\n```\n\n通过以上配置，返回的时间格式可读性明显提升。\n\n## Hot Swap\n\n:::warning\n弃坑，并不好用，经常出现更新不及时等其他问题。\n\n总结：不如手动重新启动省心 - -\n:::\n\n厌倦了在 idea 每次修改代码后都需要重新启动了？\n\nok，是时候使用热插拔（有的时候也有人叫热交换，热部署，whatever，总之都差不多）来简化你的开发了。（当你觉得花了太多时间在等待时，你就应该考虑了解新技术来简化这个过程了）\n\n环境依然是 springboot+idea\n\n首先你需要导入 spring-boot-devtools，没有加上版本是因为通常都配置了 spring-boot-starter-parent\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>org.springframework.boot\u003C/groupId>\n    \u003CartifactId>spring-boot-devtools\u003C/artifactId>\n    \u003Coptional>true\u003C/optional>\n    \u003Cscope>true\u003C/scope>\n\u003C/dependency>\n```\n\n同时还需加上插件配置\n\n```xml\n\u003Cplugin>\n    \u003CgroupId>org.springframework.boot\u003C/groupId>\n    \u003CartifactId>spring-boot-maven-plugin\u003C/artifactId>\n    \u003Cconfiguration>\n        \u003C!--如果要使用构建插件从Maven或Gradle重新启动，则必须将forking设置保留为enabled-->\n        \u003Cfork>true\u003C/fork>\n    \u003C/configuration>\n\u003C/plugin>\n```\n\n之后打开 IDEA 设置，搜索 compiler 找到`Build project automatically`勾选。\n\n再然后在 IDEA 中使用快捷键 `Ctrl+Shift+Alt+/`，点击`Registry...`，找到 `compiler.automake.allow.when.app.running`，勾选--->close。\n\n重启进行测试，发现功能正常生效，但是每次修改都需等待片刻（目测 5s+）才能自动重新部署。\n\n:::danger\n注意，如果修改导致代码出现错误而导致应用自动退出，则仍需要手动重启。\n:::\n\n:::tip\n配合浏览器 livereload 插件食用效果更佳\n:::\n\n:::details{text=\"更多参考\"}\n\n[https://www.jetbrains.com/help/idea/spring-boot.html#application-update-policies](https://www.jetbrains.com/help/idea/spring-boot.html#application-update-policies)\n\n[https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-devtools](https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-devtools)\n:::\n\n## PathVariable\n\n路径参数可以说是十分常见的功能了。\n\n这里简单贴个 demo\n\n```java\n@GetMapping(\"products/{id}\")\n@ApiOperation(\"通过id获取指定产品信息\")\npublic Product getOne(@PathVariable String id){\n    return ProductService.getById(id);\n}\n```\n\n## 全局异常捕获\n\n创建一个如下所示的配置类即可，可自行添加特殊捕获处理的异常\n\n```java\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(Exception.class) // 可换成更细粒度的异常捕获\n    public ResponseEntity error(Exception e) {\n        e.printStackTrace();\n        return ResponseEntityFactory.build(HttpStatus.BAD_REQUEST, e.getCause().getMessage());\n    }\n\n}\n```\n\n404 异常捕获(未存在的 url)需要添加以下配置\n\n`application.yml`\n\n```yaml\nspring:\n    mvc:\n        throw-exception-if-no-handler-found: true # non-existed url will throw exception\n```\n\n然后自定义 error 控制器\n\n```java\n@RestController\n@RequestMapping(\"/\")\npublic class BaseController implements ErrorController {\n\n    @RequestMapping(\"error\")\n    public ResponseEntity error() {\n        // return anything you want\n        return ResponseEntityFactory.build(HttpStatus.NOT_FOUND);\n    }\n\n    @Override\n    public String getErrorPath() {\n        return \"error\";\n    }\n}\n```\n\n## 参数校验\n\n在 Spring Boot 2.3 1 前，`spring-boot-starter-web`自带`spring-boot-starter-validation`，如果是没有自带的话，则需要自己添加\n\n_pom.xml_\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>org.springframework.boot\u003C/groupId>\n    \u003CartifactId>spring-boot-starter-validation\u003C/artifactId>\n\u003C/dependency>\n```\n\n在 controler 中需要校验的参数前加上 `@valid` 注解\n\n```java\n@PostMapping(\"products\")\npublic ResponseEntity insert(@Valid Products products) {\n    ...\n}\n```\n\n:::tip\n除了实体类，单个参数也可以直接使用该注解并加上想应约束注解即可\n:::\n\n然后在相关**实体类**加上相应的注解进行约束即可\n\n:::details{text=\"常见的注解\"}\n| 注解 | 描述 |\n| --------------------------- | ----------------------------- |\n| @Null | 必须为 Null |\n| @NotNull | 不能为 Null |\n| @AssertTrue | 必须为 True |\n| @AssertFalse | 必须为 false |\n| @Min(value) | 数字类型的最小值 |\n| @Max(value) | 数字类型的最大值 |\n| @DecimalMin(value) | 数字类型的最小值 |\n| @DecimalMax(value) | 数字类型的最大值 |\n| @Size(max=, min=) | 字符或者集合的大小区间 |\n| @Digits (integer, fraction) | 数字取值区间 |\n| @Past | 必须是过去的时间 |\n| @Future | 必须是将来的时间 |\n| @Pattern(regex=,flag=) | 正则匹配 |\n| @NotBlank(message =) | 字符串非 Null，且 trim 之后大于 0 |\n| @Email | 邮件地址 |\n| @Length(min=,max=) | 字符串长度范围 |\n| @NotEmpty | 字符串非空 |\n| @Range(min=,max=,message=) | 元素范围限制 |\n:::\n\n## 统一返回结果\n\nSpring 自带的 ReponseEntity+HttpStatus 十分好用。\n\n:::details{text=\"备份一个 RepsoneEntityFactory\"}\n```java\npublic class ResponseEntityFactory {\n\n    private ResponseEntityFactory() {\n    }\n\n    public static ResponseEntity build(HttpStatus httpStatus, Object data) {\n        Map resultMap = null;\n        if (data instanceof Map) {\n            resultMap = (Map) data;\n        } else {\n            resultMap = new HashMap();\n            resultMap.put(\"data\", data);\n        }\n        resultMap.put(\"code\", httpStatus.value());\n        resultMap.put(\"msg\", httpStatus.getReasonPhrase());\n        return new ResponseEntity(resultMap, httpStatus);\n    }\n\n    public static ResponseEntity build(HttpStatus httpStatus, String msg, Object data) {\n        Map resultMap = null;\n        if (data instanceof Map) {\n            resultMap = (Map) data;\n        } else {\n            resultMap = new HashMap();\n            resultMap.put(\"data\", data);\n        }\n        resultMap.put(\"code\", httpStatus.value());\n        resultMap.put(\"msg\", msg);\n        return new ResponseEntity(resultMap, httpStatus);\n    }\n\n    public static ResponseEntity build(HttpStatus httpStatus) {\n        Map\u003CString, Object> resultMap = new HashMap\u003C>();\n        resultMap.put(\"code\", httpStatus.value());\n        resultMap.put(\"msg\", httpStatus.getReasonPhrase());\n        return new ResponseEntity(resultMap, httpStatus);\n    }\n\n    public static ResponseEntity build(HttpStatus httpStatus, String msg) {\n        Map\u003CString, Object> resultMap = new HashMap\u003C>();\n        resultMap.put(\"code\", httpStatus.value());\n        resultMap.put(\"msg\", msg);\n        return new ResponseEntity(resultMap, httpStatus);\n    }\n}\n```\n:::\n\n## 日志系统\n\nSpringBoot 默认采 Logback 进行日志记录，并且默认输出 info 级别的日志到控制台。\n\n**日志级别**分为以下几个，`ERROR`，`WARN`，`INFO`，`DEBUG`，`FATAL`，`OFF`，`TRACE`.日志等级越高，输出的日志越多，比如在 info 级别下，会同时输出 info、warn、error 三个级别的日志。切换等级只需要在`application.xml`配置文件指定`logging.level.root = xxx`即可（yaml 同理）。\n\nfor example：\n\n```properties\nlogging.level.root=warn\nlogging.level.org.springframework.web=debug\nlogging.level.org.hibernate=error\n```\n\n:::tip\nTRACE 级别可以追踪到 web 容器的日志\n:::\n\n:::warning\nLogback 没有 FATAL 等级\n:::\n\n**文件日志**默认是没有打开的（默认输出到控制台），需要手动在配置文件指定`logging.file.name`，它可以是一个绝对路径，也可以是相对路径。\n\n默认情况下只会保存 7 天日志，相关的配置为`logging.file.max-history`。\n\n默认情况下日志文件的大小限制为 10MB，相关的配置为`logging.file.max-size`。\n\n`logging.file.total-size-cap`：该属性用于限制压缩文件的总大小。（隔天启动发现前一天的日志被放进`.gz`压缩包。）\n\n`logging.file.clean-history-on-start`：清除历史日志在应用启动时。\n\n:::warning\n日志的配置文件与实际的日志基础结构无关。因此，Spring Boot 不会管理特定的配置文件（例如 Logback 的`logback.configurationFile`）。\n:::\n\n**日志分组**\n\n举个例子，将 tomcat 的日志归到一组，包名需要自己配置，设置日志级别为 TRACE.\n\n```properties\nlogging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat\nlogging.level.tomcat=TRACE\n```\n\nSpringBoot 默认包含了 web 和 sql 组，他们包含的包如下所示：\n\n| **Name** | **Loggers**                                                                                                                                                                                                     |\n| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| web      | `org.springframework.core.codec`, `org.springframework.http`, `org.springframework.web`, `org.springframework.boot.actuate.endpoint.web`, `org.springframework.boot.web.servlet.ServletContextInitializerBeans` |\n| sql      | `org.springframework.jdbc.core`, `org.hibernate.SQL`, `org.jooq.tools.LoggerListener`                                                                                                                           |\n\n**日志关闭钩子**（Log Shutdown Hook），可以让你在启动程序结束立即关闭日志记录。\n\n```properties\nlogging.register-shutdown-hook=true\n```\n\n**自定义日志配置文件**，Logback 的自定义配置文件名为`logback-spring.xml`，更多参考[boot-features-custom-log-configuration](https://docs.spring.io/spring-boot/docs/2.3.10.RELEASE/reference/html/spring-boot-features.html#boot-features-custom-log-configuration)\n\n:::details{text=\"仿 springboot 默认日志格式\"}\n\n1. 添加 pid 转换器\n\n`ProcessIdConverter`\n\n```java\npublic class ProcessIdConverter extends ClassicConverter {\n\n    @Override\n    public String convert(ILoggingEvent iLoggingEvent) {\n        return ManagementFactory.getRuntimeMXBean().getName().split(\"@\")[0];\n    }\n}\n\n```\n\n2. 注册 pid key\n\n```xml\n\u003CconversionRule conversionWord=\"pid\"\n                    converterClass=\"xyz.ayay.servicebase.config.ProcessIdConverter\" />\n```\n\n3. 修改 pattern\n\n```\n%yellow(%date{yyyy-MM-dd HH:mm:ss.SSS})  %highlight(%-5level) %magenta(%pid) --- [%15.15thread]  %-60.60cyan(%logger{40}) : %m%n\n```\n\n:::\n\n同时 Spring 默认提供了大量的**Logback 扩展**，详情参考[boot-features-logback-extensions](https://docs.spring.io/spring-boot/docs/2.3.10.RELEASE/reference/html/spring-boot-features.html#boot-features-logback-extensions)\n\n:::tip\n具体在 SpringBoot 中，只需要在类头使用`@Slf4j`注解，就可以在类中使用 log.xxx 记录日志了\n:::\n","\r\n### 安装启动\r\n安装直接去官网下载然后解压即可\r\n\r\nwindows正常就是通过bin目录下的`.\\activemq start`命令即可启动（5.10以前不用加start）\r\n\r\nLinux则是`./activemq start`\r\n\r\n然后可以通过`localhost:8161/admin`访问web控制台，默认用户名密码都是admin。\r\n\r\n### 发送测试\r\n```java\r\nimport javax.jms.Connection;\r\nimport javax.jms.ConnectionFactory;\r\nimport javax.jms.DeliveryMode;\r\nimport javax.jms.Destination;\r\nimport javax.jms.MessageProducer;\r\nimport javax.jms.Session;\r\nimport javax.jms.TextMessage;\r\n\r\nimport org.apache.activemq.ActiveMQConnectionFactory;\r\n\r\npublic class Sender {\r\n\r\n    public static final String USERNAME = ActiveMQConnectionFactory.DEFAULT_USER;\r\n\r\n    public static final String PASSWORD = ActiveMQConnectionFactory.DEFAULT_PASSWORD;\r\n\r\n    public static final String URL = \"tcp://127.0.0.1:61616\";\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 第一步：建立ConnectionFactory工厂对象，需要填入用户名，密码，以及连接的地址。默认tcp://127.0.0.1:61616\r\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, URL);\r\n\r\n        // 第二部：通过ConnectionFactory工厂对象我们创建一个Connection连接\r\n        // 并且调用Connection的start启动连接， Connection默认是关闭的。\r\n        Connection connection = connectionFactory.createConnection();\r\n        connection.start();\r\n\r\n        // 第三部：通过Connection对象创建Session会话（上下文环境对象），用于接受消息\r\n        // 参数配置1为是否启用事物，参数配置2为签收模式，一般设置为自动签收。\r\n        Session session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);\r\n\r\n        // 第四部： 通过Session创建Destination，指的是一个客户端用来指定生产消息目标和消息来源的对象\r\n        // 在ptp模式中，Destination被称做为Queue（队列），在Pub/Sub模式下，Destination被称作Topic（主题）\r\n        Destination destination =  session.createQueue(\"helloworld-queue\");\r\n\r\n        // 第五步：我们需要通过Session对象创建消息的发送和接受对象，（生产者和消费者）MessageProducer/MessageConsumer\r\n        MessageProducer producer = session.createProducer(destination);\r\n\r\n        // 第六步：我们可以使用MessageProducer的setDeliveryMode方法为其设置持久化特性和非持久化特性（DeliveryMode）\r\n        producer.setDeliveryMode(DeliveryMode.PERSISTENT);\r\n\r\n        // 第七部：最后我们使用jms规范的TextMessage形式创建数据（通过Session对象），\r\n        // 并用MessageProducer的send方法发送数据，同理客户端使用receive方法进行接受数据。\r\n        TextMessage message = session.createTextMessage(\"producer hello word!\");\r\n        producer.send(message);\r\n\r\n        // 最后不要忘了关闭资源。\r\n        if (connection != null) {\r\n            connection.close();\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n### 接收测试\r\n```java\r\nimport javax.jms.Connection;\r\nimport javax.jms.ConnectionFactory;\r\nimport javax.jms.Destination;\r\nimport javax.jms.MessageConsumer;\r\nimport javax.jms.Session;\r\nimport javax.jms.TextMessage;\r\n\r\nimport org.apache.activemq.ActiveMQConnectionFactory;\r\n\r\npublic class Receiver {\r\n\r\n    public static final String USERNAME = ActiveMQConnectionFactory.DEFAULT_USER;\r\n\r\n    public static final String PASSWORD = ActiveMQConnectionFactory.DEFAULT_PASSWORD;\r\n\r\n    public static final String URL = \"tcp://127.0.0.1:61616\";\r\n\r\n    public static void main(String[] args) throws Exception {\r\n\r\n        // 第一步：建立ConnectionFactory工厂对象，需要填入用户名，密码，以及连接的地址。默认tcp://127.0.0.1:61616\r\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(USERNAME, PASSWORD, URL);\r\n\r\n        // 第二部：通过ConnectionFactory工厂对象我们创建一个Connection连接\r\n        // 并且调用Connection的start启动连接， Connection默认是关闭的。\r\n        Connection connection = connectionFactory.createConnection();\r\n        connection.start();\r\n\r\n        // 第三部：通过Connection对象创建Session会话（上下文环境对象），用于接受消息\r\n        // 参数配置1为是否启用事物，参数配置2为签收模式，一般设置为自动签收。\r\n        Session session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);\r\n\r\n        // 第四部： 通过Session创建Destination，指的是一个客户端用来指定生产消息目标和消息来源的对象\r\n        // 在ptp模式中，Destination被称做为Queue（队列），在Pub/Sub模式下，Destination被称作Topic（主题）\r\n        // 到此处为止，和生产端的代码一样\r\n        Destination destination =  session.createQueue(\"helloworld-queue\");\r\n\r\n        // 第五步：创建MessageConsumer对象\r\n        MessageConsumer consumer = session.createConsumer(destination);\r\n\r\n        // 第六步：接受message\r\n        TextMessage message = (TextMessage) consumer.receive();\r\n        System.out.println(message.getText());\r\n\r\n        // 最后不要忘了关闭资源。\r\n        if (connection != null) {\r\n            connection.close();\r\n        }\r\n    }\r\n\r\n}\r\n\r\n```\r\n**接受结果**\r\n>producer hello word!\r\n\r\n### 最后\r\n至此，就是ActiveMQ的基本使用，至于其他特性可以参考[官方文档](http://activemq.apache.org/components/classic/documentation)。\r\n","\r\n### 单例模式\r\n\r\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\r\n\r\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\r\n\r\n**注意：**\r\n\r\n- 1、单例类只能有一个实例。\r\n- 2、单例类必须自己创建自己的唯一实例。\r\n- 3、单例类必须给所有其他对象提供这一实例。\r\n\r\n\r\n#### 介绍\r\n\r\n**意图:** 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\r\n**主要解决：** 一个全局使用的类频繁地创建与销毁。\r\n**何时使用：** 当您想控制实例数目，节省系统资源的时候。\r\n**如何解决：** 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\r\n**关键代码：** 构造函数是私有的。\r\n**应用实例：**\r\n\r\n- 1、一个班级只有一个班主任。\r\n- 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\r\n- 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\r\n\r\n**优点：** \r\n- 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\r\n- 2、避免对资源的多重占用（比如写文件操作）。   \r\n\r\n**缺点：** 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\r\n\r\n**使用场景：** \r\n- 1、要求生产唯一序列号。\r\n- 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\r\n- 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\r\n\r\n\u003Cfont size='2'> **注意事项：** getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\u003C/font>\r\n\r\n#### 实现\r\n我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。   \r\nSingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。\r\n\r\n![img](https://alightyoung.gitee.io/static/img/32.jpg)\r\n\r\n**步骤 1**\r\n\r\n创建一个 Singleton 类。\r\n```java\r\npublic class SingleObject {\r\n \r\n   //创建 SingleObject 的一个对象\r\n   private static SingleObject instance = new SingleObject();\r\n \r\n   //让构造函数为 private，这样该类就不会被实例化\r\n   private SingleObject(){}\r\n \r\n   //获取唯一可用的对象\r\n   public static SingleObject getInstance(){\r\n      return instance;\r\n   }\r\n \r\n   public void showMessage(){\r\n      System.out.println(\"Hello World!\");\r\n   }\r\n}\r\n```\r\n\r\n**步骤 2**\r\n\r\n从 singleton 类获取唯一的对象。\r\n``` java\r\npublic class SingletonPatternDemo {\r\n   public static void main(String[] args) {\r\n \r\n      //不合法的构造函数\r\n      //编译时错误：构造函数 SingleObject() 是不可见的\r\n      //SingleObject object = new SingleObject();\r\n \r\n      //获取唯一可用的对象\r\n      SingleObject object = SingleObject.getInstance();\r\n \r\n      //显示消息\r\n      object.showMessage();\r\n   }\r\n}\r\n```\r\n\r\n**步骤 3**\r\n\r\n执行程序，输出结果：\r\n``` java\r\nHello World!\r\n```\r\n\r\n### 单例模式的几种实现方式\r\n\r\n单例模式的实现有多种方式，如下所示：\r\n\r\n#### 1、懒汉式，线程不安全\r\n\r\n**是否 Lazy 初始化：** 是\r\n**是否多线程安全：** 否\r\n**实现难度：** 易\r\n**描述：** 这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。\r\n> 实例\r\n``` java\r\npublic class Singleton {  \r\n    private static Singleton instance;  \r\n    private Singleton (){}  \r\n  \r\n    public static Singleton getInstance() {  \r\n    if (instance == null) {  \r\n        instance = new Singleton();  \r\n    }  \r\n    return instance;  \r\n    }  \r\n}\r\n```\r\n\r\n接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。\r\n\r\n#### 2、懒汉式，线程安全\r\n\r\n**是否 Lazy 初始化：** 是\r\n**是否多线程安全：** 是\r\n**实现难度：** 易\r\n**描述：** 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。\r\n优点：第一次调用才初始化，避免内存浪费。\r\n缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。\r\ngetInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\r\n\r\n``` java\r\npublic class Singleton {  \r\n    private static Singleton instance;  \r\n    private Singleton (){}  \r\n    public static synchronized Singleton getInstance() {  \r\n    if (instance == null) {  \r\n        instance = new Singleton();  \r\n    }  \r\n    return instance;  \r\n    }  \r\n}\r\n```\r\n\r\n#### 3、饿汉式\r\n\r\n**是否 Lazy 初始化：** 否\r\n**是否多线程安全：** 是\r\n**实现难度：** 易\r\n**描述：** 这种方式比较常用，但容易产生垃圾对象。\r\n优点：没有加锁，执行效率会提高。\r\n缺点：类加载时就初始化，浪费内存。\r\n它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。\r\n\r\n```java\r\npublic class Singleton {  \r\n    private static Singleton instance = new Singleton();  \r\n    private Singleton (){}  \r\n    public static Singleton getInstance() {  \r\n    return instance;  \r\n    }  \r\n}\r\n```\r\n\r\n#### 4、双检锁/双重校验锁（DCL，即 double-checked locking）\r\n\r\n**JDK 版本：** JDK1.5 起\r\n**是否 Lazy 初始化：** 是\r\n**是否多线程安全：** 是\r\n**实现难度：** 较复杂\r\n**描述：** 这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。\r\n\r\n```java\r\npublic class Singleton {  \r\n    private volatile static Singleton singleton;  \r\n    private Singleton (){}  \r\n    public static Singleton getSingleton() {  \r\n    if (singleton == null) {  \r\n        synchronized (Singleton.class) {  \r\n        if (singleton == null) {  \r\n            singleton = new Singleton();  \r\n        }  \r\n        }  \r\n    }  \r\n    return singleton;  \r\n    }  \r\n}\r\n```\r\n\r\n#### 5、登记式/静态内部类\r\n\r\n**是否 Lazy 初始化：** 是\r\n**是否多线程安全：** 是\r\n**实现难度：** 一般\r\n**描述：** 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。\r\n这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。\r\n\r\n```java\r\npublic class Singleton {  \r\n    private static class SingletonHolder {  \r\n    private static final Singleton INSTANCE = new Singleton();  \r\n    }  \r\n    private Singleton (){}  \r\n    public static final Singleton getInstance() {  \r\n    return SingletonHolder.INSTANCE;  \r\n    }  \r\n}\r\n```\r\n\r\n#### 6、枚举\r\n\r\n**JDK 版本：** JDK1.5 起\r\n\r\n**是否 Lazy 初始化：** 否\r\n\r\n**是否多线程安全：** 是\r\n\r\n**实现难度：** 易\r\n\r\n**描述：** 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。\r\n这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。\r\n不能通过 reflection attack 来调用私有构造方法。\r\n\r\n```java\r\npublic enum Singleton {  \r\n    INSTANCE;  \r\n    public void whateverMethod() {  \r\n    }  \r\n}\r\n```\r\n\r\n**经验之谈：** 一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。","\r\n### Github三方登录简述\r\n\r\n- ~~第一步先去github完成OAuth APP 的注册，注册好之后会看到Client ID和Client Secret。~~\r\n- 第一步可以先了解一下[OAuth2.0](https://www.baidu.com/s?wd=oauth2.0)\r\n- 测试代码已上传（简单实现 为防止CSRF还需要一些增加state进行安全校验 测试代码未补充） 细节参考git仓库代码 [传送门](https://gitee.com/AlightYoung/sample/tree/master/Java/github-login-demo)","\r\n### 反向代理\r\n\r\n这个功能可能最为常见,只需要在server 的location最后加上一个proxy_pass属性，然后nginx就可以帮你转发到你想转发到的其他网络地址，或者本地的其他端口（例如监听本地80端口转发到8080端口，监听本地80到baidu首页），十分简便。\r\n\r\n### 负载均衡\r\ntodo...","\n\n:::tip\n推荐knife4j\n:::\n\n### Knife4j\nKnife4j的前身是swagger-bootstrap-ui，前身swagger-bootstrap-ui是一个纯swagger-ui的ui皮肤项目。\n\n随着时间的推移，项目开始从一个Swagger的UI方案进化为一个为Swagger接口文档服务的通用性解决方案，因此改名为Knife4j。\n\n下面记录了Knife4j与SpringBoot的集成，细节参考[官方文档](https://doc.xiaominfo.com/knife4j/)\n\n`pom.xml`：项目依赖\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>com.github.xiaoymin\u003C/groupId>\n    \u003CartifactId>knife4j-spring-boot-starter\u003C/artifactId>\n    \u003Cversion>3.0.2\u003C/version>\n\u003C/dependency>\n```\n\n`Knife4jConfiguration`：配置类\n\n```java\n@Configuration\n@EnableSwagger2\npublic class Knife4jConfiguration {\n\n    @Bean(value = \"defaultApi2\")\n    public Docket defaultApi2() {\n        Docket docket=new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(new ApiInfoBuilder()\n                        .description(\"default description\")\n                        .termsOfServiceUrl(\"url\")\n                        .contact(new Contact(\"name\",\"url\",\"email\"))\n                        .version(\"1.0\")\n                        .build())\n                .groupName(\"default group name\")\n                .select()\n                // base package of controller\n                .apis(RequestHandlerSelectors.basePackage(\"com.xxx.xxx.controller\"))\n                .paths(PathSelectors.any())\n                .build();\n        return docket;\n    }\n}\n```\n\n**Controller注解说明**\n\n1. `@Api(tags = \"xx模块\")`：Controller解释，标注在Controller头部。\n2. `@ApiImplicitParam(name = \"\",value = \"\",required = true)`：API参数解释，标注在Controller方法上。\n3. `@ApiOperation(value = \"\")`：API解释，标注在Controller方法上。\n\n**实体类注解说明**\n\n1. `@ApiModel`：作用于类上，解释实体类\n2. `@ApiModelProperty`：用于属性上，解释属性\n\n最后，启动项目，打开`http://localhost:{your server port}/doc.html`查看效果即可。\n\n\n---\n\n\n### Swagger\n\nSwagger是一个开放源代码软件框架，由大型工具生态系统支持，可帮助开发人员设计，构建，记录和使用RESTful Web服务。尽管大多数用户通过Swagger UI工具识别Swagger，但是Swagger工具集包括对自动文档，代码生成和测试用例生成的支持。\n\n至于有人考虑swagger对代码的入侵性，这个就见仁见智了。此处提供一个简单的demo以供简单集成参考 [gitee仓库地址](https://gitee.com/AlightYoung/sample/tree/master/Java/springboot-with-swagger)\n\n:::details{text=\"zuul环境下与swagger的整合\"}\nzuul启动类加上@EnableSwagger2Doc注解\n\n直接在启动类下编写配置\n```java\n@Component\n@Primary\nclass DocumentationConfig implements SwaggerResourcesProvider {\n    @Override\n    public List\u003CSwaggerResource> get() {\n        List resources = new ArrayList\u003C>();\n        // 通过服务别名获取swagger api\n        resources.add(swaggerResource(\"app-alight-member\", \"/app-alight-member/v2/api-docs\", \"2.0\"));\n        resources.add(swaggerResource(\"app-alight-weixin\", \"/app-alight-weixin/v2/api-docs\", \"2.0\"));\n        return resources;\n    }\n\n    private SwaggerResource swaggerResource(String name, String location, String version) {\n        SwaggerResource swaggerResource = new SwaggerResource();\n        swaggerResource.setName(name);\n        swaggerResource.setLocation(location);\n        swaggerResource.setSwaggerVersion(version);\n        return swaggerResource;\n    }\n```\n:::\n","\r\n### 环境\r\n\r\n- 阿里云 ECS 2c 4g\r\n- CentOS Linux release 7.7.1908 (Core)\r\n- 非生产环境，已开启全部端口\r\n\r\n以下是官方建议\r\n\r\n**GitLab Installation**\r\n\r\nWe strongly recommend downloading the Omnibus package installation since it is quicker to install, easier to upgrade, and it contains features to enhance reliability not found in other methods. We also strongly recommend at least 4GB of free RAM to run GitLab.\r\n\r\n\r\n### gitlab私服搭建\r\n\r\n#### 安装和配置必要的依赖项\r\n\r\n在CentOS 7（和RedHat / Oracle / Scientific Linux 7）上，以下命令还将在系统防火墙中打开HTTP，HTTPS和SSH访问。\r\n```bash\r\nsudo yum install -y curl policycoreutils-python openssh-server\r\nsudo systemctl enable sshd\r\nsudo systemctl start sshd\r\n\r\nsudo firewall-cmd --permanent --add-service=http\r\nsudo firewall-cmd --permanent --add-service=https\r\nsudo systemctl reload firewalld\r\n```\r\n接下来，安装Postfix发送通知电子邮件。如果要使用其他解决方案发送电子邮件，请跳过此步骤并在安装GitLab之后配置外部SMTP服务器。\r\n```bash\r\nsudo yum install postfix\r\nsudo systemctl enable postfix\r\nsudo systemctl start postfix\r\n```\r\n> 注：此处在`systemctl start postfix`发生一个错误\r\n>> Job for postfix.service failed because the control process exited with error code. See \"systemctl status postfix.service\" and \"journalctl -xe\" for details.\r\n\r\n>个人解决办法\r\n执行systemctl status postfix.service,发现Failed to start Postfix Mail Transport Agent.然后修改配置文件`vim /etc/postfix/main.cf` 原本此处为`inet_protocols = all`，修改成以下，问题得以解决\r\n>>`inet_protocols = ipv4`\r\n`inet_interfaces = all`\r\n\r\n~~在Postfix安装过程中，可能会出现一个配置屏幕。选择“ Internet网站”，然后按Enter。使用服务器的外部DNS作为“邮件名”，然后按Enter。如果出现其他屏幕，请继续按Enter接受默认设置。~~\r\n\r\n#### 添加GitLab软件包存储库并安装软件包\r\n\r\n添加GitLab软件包存储库。这里面就有个选择了,社区版或者企业版\r\n\r\n官方是这么建议的\r\n\r\n如果您有兴趣使用GitLab，即使您不确定是否会订阅GitLab Enterprise Edition许可证 ，我们也建议您 下载并安装GitLab Enterprise Edition。您仍然可以使用GitLab社区版的所有功能，而无需许可证或注册。\r\n\r\n所以至于你想安装什么版本 自行选择 以下都会有注释\r\n\r\n\r\n```bash\r\n# 企业版就是gitlab-ee，应该很好区分\r\ncurl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash\r\n# 社区版gitlab-ce\r\ncurl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash\r\n```\r\n接下来，安装GitLab软件包。将https://gitlab.example.com更改为您要访问GitLab实例的URL。安装将自动配置并在该URL上启动GitLab。\r\n\r\n对于https://URL，GitLab将自动通过Let's Encrypt请求证书，这需要入站HTTP访问和有效的主机名。您也可以使用自己的证书或仅使用http://。\r\n\r\n这里我为了方便直接用http加上外网ip了，可以自己根据需求调整\r\n\r\n```bash\r\n# 企业版\r\nsudo EXTERNAL_URL=\"https://gitlab.example.com\" yum install -y gitlab-ee\r\n# 社区版\r\nsudo EXTERNAL_URL=\"https://gitlab.example.com\" yum install -y gitlab-ce\r\n```\r\n这里不出意外的话，要下载好久，我的安装大小为1.6g。静待片刻...\r\n\r\n其实也可以不使用官方地址下载，比如配置清华源，速度应该能快上不少，[传送门](https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/)\r\n\r\n#### 浏览到主机名并登录\r\n\r\n简单来说，在安装完成之后，理论上就可以直接输入http://ip进行访问，初次需要设置密码，默认用户名为root，然后即可以登录到gitlab的web管理界面了，之后的大家就都知道了，不多赘述。\r\n\r\n#### 配置\r\n\r\n至于配置，比如修改端口号(默认80)，可以去修改配置文件`/etc/gitlab/gitlab.rb`，具体百度，这里不贴了。\r\n\r\ngitlab-ctl常用命令\r\n\r\n1.  重新加载配置并启动\r\n`sudo gitlab-ctl reconfigure`\r\n2. 重启gitlab\r\n`sudo gitlab-ctl restart`\r\n3. 查看gitlab运行状态\r\n`sudo gitlab-ctl status`\r\n4. 停止gitlab服务\r\n`sudo gitlab-ctl stop`\r\n5. 查看gitlab运行日志\r\n`sudo gitlab-ctl tail`\r\n\r\n更多gitlab-ctl用法直接输入gitlab-ctl，下面都会列举出来。\r\n\r\n#### 最后\r\n\r\n以上内容很多都是官方文档机翻过来的，其实官方文档非常详细，提供了很多很多的安装文档，还有docker的安装方式，但是我不喜欢docker，就没有用docker安装了，有兴趣的或者看完该文章仍没有解决问题的，可以直接参考官方文档。[传送门](https://about.gitlab.com/install/)","\r\n### 分页查询\r\n\r\n分页查询是前后端都常见的一个功能，大致可以分为物理分页和逻辑分页。\r\n\r\n物理物业：物理分页依赖的是某一物理实体，这个物理实体就是数据库，比如MySQL的limit offset关键字，就可以查询出一个指定的区间。\r\n\r\n逻辑分页：逻辑分页就是一次性将数据全部查出来，进行逻辑划分页数与每页的数量。\r\n\r\n#### 物理vs逻辑\r\n\r\n##### 1.数据库压力\r\n\r\n物理分页每次都访问数据库，逻辑分页只访问一次数据库，物理分页对数据库造成的负担大。\r\n\r\n##### 2.服务器负担\r\n\r\n逻辑分页一次性将数据读取到内存，占用了较大的内容空间，物理分页每次只读取一部分数据，占用内存空间较小。\r\n\r\n#####  3.实时性\r\n\r\n逻辑分页一次性将数据读取到内存，数据发生改变，数据库的最新状态不能实时反映到操作中，实时性差。物理分页每次需要数据时都访问数据库，能够获取数据库的最新状态，实时性强。\r\n\r\n##### 4.适用场合\r\n\r\n逻辑分页主要用于数据量不大、数据稳定的场合，物理分页主要用于数据量较大、更新频繁的场合。\r\n\r\n#### 实现方式\r\n\r\n具体参考代码，后端采用pagehelper（物理），前端采用bootstraptable（逻辑），当让你也可以不使用加载全部数据的逻辑分页，也可以指定数据进行数据展示，看需求吧。\r\n\r\n代码参考----[传送门](https://gitee.com/AlightYoung/sample/tree/master/Java/pagination)\r\n\r\n","\r\n### spring security\r\nSpring Security是一个功能强大且高度可定制的身份验证和访问控制框架。它是用于保护基于Spring的应用程序的实际标准。\r\n\r\nSpring Security是一个框架，致力于为Java应用程序提供身份验证和授权。与所有Spring项目一样，Spring Security的真正强大之处在于可以轻松扩展以满足自定义要求。\r\n\r\n#### 简单认证授权\r\n\r\n这里提供了一个简单的demo，环境是springboot+security+mybatis的一个简单的认证授权demo，[git仓库](https://gitee.com/AlightYoung/sample/tree/master/Java/springboot2-security5-mybatis)","\r\n### Mybatis Generator\r\n\r\n#### 介绍\r\nMyBatis生成器（MBG）是MyBatis MyBatis的代码生成器。它将为MyBatis的所有版本生成代码。它将对一个（或多个）数据库表进行内部检查，并将生成可用于访问表的工件。这减轻了设置对象和配置文件以与数据库表进行交互的麻烦。MBG试图对简单CRUD（创建，检索，更新，删除）的大部分数据库操作产生重大影响。您仍将需要手工编写SQL和对象代码以进行联接查询或存储过程。\r\n\r\n#### 简单配置及效果\r\n大致步骤：\r\n- 导入maven插件\r\n```xml\r\n\u003Cplugin>\r\n    \u003CgroupId>org.mybatis.generator\u003C/groupId>\r\n    \u003CartifactId>mybatis-generator-maven-plugin\u003C/artifactId>\r\n    \u003Cversion>1.4.0\u003C/version>\r\n    \u003Cdependencies>\r\n        \u003Cdependency>\r\n            \u003CgroupId>mysql\u003C/groupId>\r\n            \u003CartifactId>mysql-connector-java\u003C/artifactId>\r\n            \u003Cversion>5.1.47\u003C/version>\r\n        \u003C/dependency>\r\n        \u003Cdependency>\r\n            \u003CgroupId>org.mybatis.generator\u003C/groupId>\r\n            \u003CartifactId>mybatis-generator-maven-plugin\u003C/artifactId>\r\n            \u003Cversion>1.4.0\u003C/version>\r\n        \u003C/dependency>\r\n        \u003Cdependency>\r\n            \u003CgroupId>org.mybatis.generator\u003C/groupId>\r\n            \u003CartifactId>mybatis-generator-core\u003C/artifactId>\r\n            \u003Cversion>1.4.0\u003C/version>\r\n        \u003C/dependency>\r\n    \u003C/dependencies>\r\n    \u003Cexecutions>\r\n        \u003Cexecution>\r\n            \u003Cid>Generate MyBatis Artifacts\u003C/id>\r\n            \u003Cphase>package\u003C/phase>\r\n            \u003Cgoals>\r\n                \u003Cgoal>generate\u003C/goal>\r\n            \u003C/goals>\r\n        \u003C/execution>\r\n    \u003C/executions>\r\n    \u003Cconfiguration>\r\n        \u003C!--允许移动生成的文件 -->\r\n        \u003Cverbose>true\u003C/verbose>\r\n        \u003C!-- 是否覆盖 -->\r\n        \u003Coverwrite>false\u003C/overwrite>\r\n        \u003C!-- 自动生成的配置 -->\r\n        \u003CconfigurationFile>\r\n            src/main/resources/mybatis-generator.xml\r\n        \u003C/configurationFile>\r\n    \u003C/configuration>\r\n\u003C/plugin>\r\n```\r\n- mbg配置文件\r\n```xml\r\n\u003C?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n\u003C!DOCTYPE generatorConfiguration\r\n        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\r\n\u003CgeneratorConfiguration>\r\n    \u003C!--mysql 连接数据库jar 这里选择自己本地位置-->\r\n    \u003CclassPathEntry\r\n            location=\"/Users/alight/.m2/repository/mysql/mysql-connector-java/5.1.47/mysql-connector-java-5.1.47.jar\"/>\r\n    \u003Ccontext id=\"testTables\" targetRuntime=\"MyBatis3\">\r\n        \u003CcommentGenerator>\r\n            \u003C!-- 是否去除自动生成的注释 true：是 ： false:否 -->\r\n            \u003Cproperty name=\"suppressAllComments\" value=\"true\"/>\r\n        \u003C/commentGenerator>\r\n        \u003C!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->\r\n        \u003CjdbcConnection driverClass=\"com.mysql.jdbc.Driver\"\r\n                        connectionURL=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\" userId=\"root\"\r\n                        password=\"123456\">\r\n        \u003C/jdbcConnection>\r\n        \u003C!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和\r\n           NUMERIC 类型解析为java.math.BigDecimal -->\r\n        \u003CjavaTypeResolver>\r\n            \u003Cproperty name=\"forceBigDecimals\" value=\"false\"/>\r\n        \u003C/javaTypeResolver>\r\n\r\n        \u003C!-- targetProject:生成表实体类的位置 -->\r\n        \u003CjavaModelGenerator targetPackage=\"com.example.demo.entity\"\r\n                            targetProject=\"src/main/java\">\r\n            \u003C!-- enableSubPackages:是否让schema作为包的后缀 -->\r\n            \u003Cproperty name=\"enableSubPackages\" value=\"false\"/>\r\n            \u003C!-- 从数据库返回的值被清理前后的空格 -->\r\n            \u003Cproperty name=\"trimStrings\" value=\"true\"/>\r\n        \u003C/javaModelGenerator>\r\n        \u003C!-- targetProject:mapper映射文件生成的位置\r\n           如果maven工程只是单独的一个工程，targetProject=\"src/main/java\"\r\n           若果maven工程是分模块的工程，targetProject=\"所属模块的名称\"，例如：\r\n           targetProject=\"ecps-manager-mapper\"，下同-->\r\n        \u003CsqlMapGenerator targetPackage=\"mapper\"\r\n                         targetProject=\"src/main/resources\">\r\n            \u003C!-- enableSubPackages:是否让schema作为包的后缀 -->\r\n            \u003Cproperty name=\"enableSubPackages\" value=\"false\"/>\r\n        \u003C/sqlMapGenerator>\r\n        \u003C!-- targetPackage：mapper接口生成的位置 -->\r\n        \u003CjavaClientGenerator type=\"XMLMAPPER\"\r\n                             targetPackage=\"com.example.demo.mapper\"\r\n                             targetProject=\"src/main/java\">\r\n            \u003C!-- enableSubPackages:是否让schema作为包的后缀 -->\r\n            \u003Cproperty name=\"enableSubPackages\" value=\"false\"/>\r\n        \u003C/javaClientGenerator>\r\n        \u003C!-- 指定数据库表  多个表示,可用多个table标签-->\r\n        \u003Ctable tableName=\"t_user\"\r\n               enableCountByExample=\"false\"\r\n               enableUpdateByExample=\"false\"\r\n               enableDeleteByExample=\"false\"\r\n               enableSelectByExample=\"false\"\r\n               selectByExampleQueryId=\"false\">\r\n        \u003C/table>\r\n        \u003Ctable tableName=\"t_user_roles\"/>\r\n    \u003C/context>\r\n\u003C/generatorConfiguration>\r\n```\r\n- 运行maven插件即可\r\n![img3](https://alightyoung.gitee.io/static/img/3.png)\r\n\r\n- 效果\r\n![img2](https://alightyoung.gitee.io/static/img/2.png)\r\n\r\n代码参考:[git仓库](https://gitee.com/AlightYoung/sample/tree/master/Java/springboot&mbg)\r\n\r\n","\r\n\r\n## Centos 7\r\n\r\n### 环境\r\n\r\n- 阿里云ecs\r\n- centos7.7\r\n\r\n### 安装配置\r\n\r\n- 新建 `/etc/yum.repos.d/mysql-community.repo`\r\n- 把这些内容复制到上面的repo文件里\r\n\r\n```properties\r\n[mysql-connectors-community]\r\nname=MySQL Connectors Community\r\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-connectors-community-el7-x86_64/\r\nenabled=1\r\ngpgcheck=1\r\ngpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql\r\n\r\n[mysql-tools-community]\r\nname=MySQL Tools Community\r\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-tools-community-el7-x86_64/\r\nenabled=1\r\ngpgcheck=1\r\ngpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql\r\n\r\n[mysql-5.6-community]\r\nname=MySQL 5.6 Community Server\r\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-5.6-community-el7-x86_64/\r\nenabled=0\r\ngpgcheck=1\r\ngpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql\r\n\r\n[mysql-5.7-community]\r\nname=MySQL 5.7 Community Server\r\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-5.7-community-el7-x86_64/\r\nenabled=1\r\ngpgcheck=1\r\ngpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql\r\n\r\n[mysql-8.0-community]\r\nname=MySQL 8.0 Community Server\r\nbaseurl=https://mirrors.tuna.tsinghua.edu.cn/mysql/yum/mysql-8.0-community-el7-x86_64/\r\nenabled=1\r\ngpgcheck=1\r\ngpgkey=https://repo.mysql.com/RPM-GPG-KEY-mysql\r\n```\r\n\r\n这里说一下，如果准备下5.7版本，就把8.0的enabled改为0,我这里装的是5.7\r\n\r\n- 执行 `yum makecache & yum repolist all | grep mysql` \r\n应该就能看到 MySQL 5.7 Community Server(还有5.6 和8.0的版本)\r\n\r\n- 执行 `yum -y install mysql-community-server`\r\n一会应该就能安装完，因为上面配置的是清华的源，速度还是可以的。\r\n\r\n- 安装好之后，执行 `systemctl start mysqld.service `\r\n\r\n- 然后是`systemctl status mysqld.service`\r\n正常应该是能看到active/running字眼的\r\n\r\n- 获取数据库安装时生成的临时密码 `grep \"password\" /var/log/mysqld.log`\r\n如果执行命令后，没有输出信息，执行`rm -rf /var/lib/mysql`，重启msyql服务 `systemctl restart mysqld`,然后再次获取试试。\r\n\r\n- 使用临时密码登录mysql\r\n`mysql -u root -p`--->输入临时密码--->登录到mysql cli。\r\n\r\n- 修改密码\r\n`ALTER USER 'root'@'localhost' IDENTIFIED BY 'new password';`\r\n这边测试已经有安全策略了，像123456的密码已经不能通过了，建议改个稍微复杂点的。\r\n不想改的话可以修改密码安全策略\r\n`set global validate_password_policy=LOW;`\r\n`set global validate_password_length=6; `\r\n\r\n然后发现可以设置123456成功了\r\n\r\n之后`quit`命令退出，测试新密码能否登录即可。\r\n\r\n- `grant all privileges on *.* to root@\"%\" identified by \"new password\";`\r\n该命令用于生成一个可以远程登录的root用户,然后navicat远程登录测试一下就行了。\r\n\r\n- 至于配置文件，在`/etc/my.cnf`\r\n\r\n差不多就这些了。\r\n\r\n\r\n## Ubuntu 20.04\r\n\r\n- 环境：腾讯云轻量服务器\r\n- mysql  Ver 8.0.27-0ubuntu0.20.04.1 for Linux on x86_64 ((Ubuntu))\r\n- 时间：2021/11/17\r\n\r\n``` shell\r\n# install\r\nsudo apt install mysql-server\r\n# server will auto running after installed\r\n# temporary user and password: /etc/mysql/debian.cnf， also can check /var/log/mysql/error.log\r\n# login to mysql client and setting root password and remote user \r\n\r\n# update root password to 123456, you can change it to other if you would like\r\nuse mysql;\r\n# the default plugin\r\nalter user 'root'@'localhost' identified with mysql_native_password by '123456';\r\nupdate user set host = '%' where user = 'root' and host = 'localhost'\r\nflush privileges;\r\nflush hostsl\r\n\r\n# check it\r\n# select user, host, authentication_string, plugin from mysql.user;\r\n\r\n# some useful command\r\n# status\r\nmysql> status\r\nsudo service mysql status\r\nsudo ss -tap | grep mysql\r\n# restart \r\nsudo service mysql restart\r\n# log\r\nsudo journalctl -u mysql\r\n```\r\n\r\n***note bind-address*** on /etc/mysql/mysql.conf.d/mysqld.cnf if existed\r\n\r\n``` shell\r\n[mysql]\r\n# bind-address          = 127.0.0.1\r\n# mysqlx-bind-address   = 127.0.0.1\r\n```\r\n","\r\n### 环境准备\r\n\r\n- centos7本地虚拟机\r\n- 3g内存\r\n- jdk1.8\r\n- MySQL 5.7\r\n\r\n### 前言\r\n\r\n以下内容只有最简单的本地测试教程，不包括很多细节，如果是准备解决一些细节性问题，还是参考[官方文档](https://github.com/ctripcorp/apollo/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E9%83%A8%E7%BD%B2%E6%8C%87%E5%8D%97)\r\n\r\n### 数据库创建\r\n\r\n首先需要部署两个数据库。\r\n\r\n官方提供了sql文件，直接导入就行了。\r\n\r\n创建apolloportaldb的sql文件\r\n[apolloportaldb.sql](https://github.com/ctripcorp/apollo/blob/master/scripts/sql/apolloportaldb.sql)\r\n\r\n创建apolloconfigdb的sql文件\r\n[apolloconfigdb.sql](https://github.com/ctripcorp/apollo/blob/master/scripts/sql/apolloconfigdb.sql)\r\n\r\n### 获取安装包\r\n\r\n这里放已经打包好的安装的，官方还提供了源码构建方式\r\n\r\n[下载地址](https://github.com/ctripcorp/apollo/releases)\r\n\r\n这里主要下载这三个文件\r\n```xml\r\napollo-adminservice-*.*.*-github.zip\r\napollo-configservice-*.*.*-github.zip\r\napollo-portal-*.*.*-github.zip\r\n```\r\n\r\n接下来就要解压修改配置文件\r\n\r\n这三个文件夹里面都有`config/application-github.properties`,里面需要配置数据库链接，用户名，密码，改成自己的就行了。\r\n\r\n还有个`meta service`没配置(portal里面)，因为主要是本地测试，我就没改，需要的可以看官方文档。\r\n\r\n### 部署\r\n\r\n部署其实挺简单的（不配置jvm参数什么的）,丢到服务器里去就行了。\r\n\r\n刚才的三个文件夹，里面都有`scripts`\r\n\r\n里面都有`startup.sh`和`shutdown.sh`\r\n\r\n但是sftp丢进去可能没有execute权限，在`scripts`下执行`chmod +x s*`就行了。\r\n\r\n这三个进程跑起来就可以通过ip：8080看到eureka的web界面，ip：8070进入apollo的web管理界面，默认用户名是apollo，密码是admin，之后的创建配置文件，和springcloud的整合就不多赘述了。\r\n\r\nover！","\r\n### 前言\r\n\r\n这里提供两种方式安装\r\n- 通过yum进行安装（无需配置环境变量）\r\n- 通过tar.gz压缩格式进行安装（需手动配置环境变量）\r\n\r\n### 通过yum安装\r\n\r\n这里说一下废话。\r\n\r\n修改默认yum源为阿里的yum源（如已配置可以跳过）\r\n\r\n详细移步 [官方说明](https://developer.aliyun.com/mirror/centos)\r\n\r\n查找具体包名\r\n`yum search jdk`\r\n\r\n安装openjdk8\r\n`yum install -y java-1.8.0-openjdk-devel.x86_64`\r\n\r\n查看环境是否生效\r\n`java -version`\r\n`javac -version`\r\n\r\n### 通过压缩包安装\r\n\r\n1. 把之前在oracle官方下载的压缩包上传到服务器上，也可以用openjdk\r\n2. `tar zxvf 包名` 进行解压，之后`rm 包名`删掉压缩包\r\n3. 编辑用户目录下的.bashrc\r\n以下是我的模板,这里我把包直接解压到了`/root`下，这个根据自己需求变动\r\n```bash\r\nexport JAVA_HOME=\"/root/jdk1.8.0_241\"\r\nexport PATH=\"$PATH:$JAVA_HOME/bin/\"\r\n```\r\n4. 使配置文件生效`source ~/.bashrc`\r\n\r\n之后同样可以查看版本看有没有生效。\r\n\r\n","\r\n## SQL语句 \r\n\r\n```sql\r\n/* 查询数据库 ‘mammothcode’ 所有表注释 */\r\nSELECT TABLE_NAME,TABLE_COMMENT FROM information_schema.TABLES WHERE table_schema='mammothcode';\r\n```\r\n\r\n```sql\r\n/* 查询数据库 ‘mammothcode’ 下表 ‘t_adminuser’ 所有字段注释 */\r\nSELECT COLUMN_NAME,column_comment FROM INFORMATION_SCHEMA.Columns WHERE table_name='t_adminuser' AND table_schema='mammothcode'\r\n```\r\n\r\n```sql\r\n/* 一次性查询数据库 \"mammothcode\" 下表注释以及对应表字段注释*/\r\nSELECT t.TABLE_NAME,t.TABLE_COMMENT,c.COLUMN_NAME,c.COLUMN_TYPE,c.COLUMN_COMMENT FROM information_schema.TABLES t,INFORMATION_SCHEMA.Columns c WHERE c.TABLE_NAME=t.TABLE_NAME AND t.`TABLE_SCHEMA`='mammothcode'\r\n```\r\n","\r\n### 时间戳/date/string转换\r\n\r\n```java\r\n// 获取当前时间戳\r\nlong l = System.currentTimeMillis(); // l=1589854992924\r\n// 时间戳转date\r\nDate date = new Date(l); // date=Tue May 19 10:23:12 CST 2020\r\n// \"yyyy-MM-dd hh:mm:ss\"格式转date\r\nString s = \"2020-01-01 00:00:00\";\r\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\r\nDate parse = sdf.parse(s);// parse=Wed Jan 01 00:00:00 CST 2020\r\n// date获取时间戳\r\nlong time = parse.getTime(); // time=1577808000000\r\n// date输出指定格式\r\nString format = sdf.format(parse);//format=2020-01-01 00:00:00\r\n// calendar 实现date增加一天\r\nDate stratTime = simpleDateFormat.parse(\"2020-01-01\");\r\nCalendar calendar = Calendar.getInstance();\r\ncalendar.setTime(stratTime);\r\n// 也可增加年/月\r\ncalendar.add(Calendar.DAY_OF_WEEK,1);\r\nDate endTime = calendar.getTime();\r\n```\r\n顺带记录两个空值判断写法\r\n```java\r\nInteger a = Optional.ofNullable(null).orElse(new Integer(1)); // a=1\r\nInteger a = getA()==null?1:getA();\r\n```\r\n\r\n\r\n","\r\n### 容器\r\nJava的容器/集合大致可以分为array,list,map,set\r\n\r\n#### Array排序\r\n```java\r\nint[] arr = {5,2,66,3,7};\r\nArrays.sort(arr);\r\n// print 2 3 5 7 66\r\n```\r\n\r\n#### List/Set排序\r\n\r\n```java\r\n// 基本类型\r\nCollections.sort(list);\r\n// 对象\r\nList\u003CUser> userList = new ArrayList();\r\nuserList.sort(Comparator.comparing(user::getCreateTime));\r\n//这里的写法需要jdk8+ 可以根据任何字段进行自然排序\r\n// set排序考虑放到treeSet或者转成list\r\n```\r\n\r\n#### Map排序\r\n\r\n```java\r\n// 以下方法均可让map的entry/key/value按照自然排序输出 对象的话可以再考虑使用以上list排序的方式进行再排\r\nMap.entrySet();\r\nMap.keySet();\r\nMap.valueSet();\r\n```\r\n\r\n","\n简单的说 Node.js 就是运行在服务端的 JavaScript。\n\nNode.js 是一个基于Chrome JavaScript 运行时建立的一个平台。\n\nNode.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。\n\n#### 环境安装\n\n这个不多说了,打开[官网](https://nodejs.org/zh-cn/)就知道了\n\n安装完之后可以查看一下是否成功\n\n```bash\n# 查看node版本\nnode -v\n# 查看npm版本\nnpm -v\n```\n\n\n\n#### node & npm\n\n在安装完环境之后,先初步了解一下`node`和`npm`\n\n一般来说`node`用来进入node的JavaScript环境(REPL),可以在终端中测试JavaScript,或者直接`node index.js`去执行一段js.\n\n而`npm`则是个包管理器,简单地说,你可以用它下载安装一些别人发布的包.你还可以去启动一个项目.\n\n> 一般来说npm的仓库源是国外的,所以一般来说我们会替换源来改善下载的速度,这里安利一下nrm,它可以轻易的切换仓库使用的源\n\n```bash\n# 安装\nnpm install -g nrm\n# 使用说明\n# 查看源可选项\nnrm ls\n# 大概会出现一下这些\n* npm -----  https://registry.npmjs.org/\n  yarn ----- https://registry.yarnpkg.com\n  cnpm ----  http://r.cnpmjs.org/\n  taobao --  https://registry.npm.taobao.org/\n  nj ------  https://registry.nodejitsu.com/\n  skimdb -- https://skimdb.npmjs.com/registry\n# 切换到taobao源\nnrm use taobao\n# 提示以下则说明成功\nRegistry has been set to: https://registry.npm.taobao.org/\n# 换回原来的源\nnrm use npm\n```\n\n#### REPL\n\n(Read Eval Print Loop:交互式解释器)\n\n也就是上面说的`node`指令进入的JavaScript环境\n\n它可以执行以下任务：\n\n- **读取** - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。\n- **执行** - 执行输入的数据结构\n- **打印** - 输出结果\n- **循环** - 循环操作以上步骤直到用户两次按下 **ctrl-c** 按钮退出。\n\n**Example**\n\n```bash\n$ node\n> let a = 1\nundefined\n> console.log(a)\n1\n```\n\n##### REPL 命令\n\n- `ctrl + c` - 退出当前终端。\n- `ctrl + c 按下两次` - 退出 Node REPL。\n- `ctrl + d` - 退出 Node REPL.\n- `向上/向下 键` - 查看输入的历史命令\n- `tab ` - 列出当前命令\n- `.help` - 列出使用命令\n- `.break` - 退出多行表达式\n- `.clear` - 退出多行表达式\n- `.save filename` - 保存当前的 Node REPL 会话到指定文件\n- `.load filename` - 载入当前 Node REPL 会话的文件内容。\n\n#### 模块系统\n\nrequire常用来导入当前工程下node_modules中的模块\n\n```javascript\n// 导入读取文件模块\nvar fs = require(\"fs\");\nvar data = fs.readFileSync('input.txt');\n```\n\n#### 最后\n\n不用好奇为啥没有了,因为很多东西的内容都可以单独写一篇博客了,深入看的话,官方文档绝对是不二选择(推荐有基础的情况下看)\n\n现在你可以去了解api和各种模块了,感兴趣的话还可以了解一下express/koa.值得一提的是,如果你是前端开发者,想实现一些功能简单的后端的话,node.js绝对满足你的要求.\n\n---\n\n贴一下当时用express写的demo,当时不会es6,写了很多回调地狱 T_T\n\n```javascript\n//express_demo.js 文件\nvar url = require('url');\nvar ejs = require('ejs');\nvar querystring = require('querystring');\nconst express = require('express');\nconst fs = require('fs');\nconst util = require('util');\nvar mysql = require('mysql');\n\nconst app = express();\n\nvar connection = mysql.createConnection({\n    host: 'localhost',\n    user: 'root',\n    password: 'pwd',\n    database: 'databaseName'\n});\nconnection.connect();\n\n// 静态文件配置 多个需重复添加\n// app.use(express.static('css'));\n\n// render引擎\napp.set('views', 'views');\napp.set('view engine', 'html');\napp.engine('html', ejs.renderFile)\n// index\napp.get(['/', '/index'], function (req, res) {\n    res.sendFile(__dirname+'/views/index.html');\n})\n// 跳转page\napp.get('/page/:pageId', function (req, res) {\n    const page = 'page' + req.params.pageId;\n    const file = 'views/'+page+'.html';\n    fs.access(file, fs.constants.F_OK | fs.constants.W_OK, (err) => {\n        if (err) {\n            res.render('pnf');\n        }else{\n            res.render(page);\n        }\n    });\n})\napp.use(function (req, res, next) {\n    res.status(404).send(\"404 Not Found\")\n})\n// 获取所有用户列表\napp.get('/getalluser', function (req, res) {\n    connection.query('select * from user', function (error, results) {\n        if (error) throw error;\n        res.send(util.inspect(results, true));\n    });\n})\n// 查询指定客户信息\napp.get('/getuser', function (req, res) {\n    const params = url.parse(req.url, true).query;\n    const addSql = 'select * from user where id = ?';\n    const addSqlParams = [params.id];\n    connection.query(addSql, addSqlParams, function (error, result) {\n        if (error) throw error;\n        res.send(util.inspect(result, true));\n    });\n})\n// 新增用户\napp.post('/adduser', function (req, res) {\n    // 定义了一个post变量，用于暂存请求体的信息\n    let body = '';\n    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中\n    req.on('data', function (chunk) {\n        body += chunk;\n    });\n    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。\n    req.on('end', function () {\n        body = querystring.parse(body);\n        const addSql = 'insert into user(`name`,head_image,phone,pwd,email,create_time) values(?,?,?,?,?,now())';\n        const addSqlParams = [body.name, body.headImage, body.phone, body.pwd, body.email];\n        connection.query(addSql, addSqlParams, function (err, result) {\n            if (err) {\n                return result;\n            }\n            res.send('insert success');\n        });\n    });\n})\n// 修改用户\napp.put('/updateuser', function (req, res) {\n    // 定义了一个post变量，用于暂存请求体的信息\n    let body = '';\n    // 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中\n    req.on('data', function (chunk) {\n        body += chunk;\n    });\n    // 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。\n    req.on('end', function () {\n        body = querystring.parse(body);\n        if (!body.id) {\n            res.send('参数错误');\n            return;\n        }\n        const addSql = 'select * from user where id = ?';\n        const addSqlParams = [body.id];\n        connection.query(addSql, addSqlParams, function (error, result) {\n            if (error) throw error;\n            let resultElement = result[0];\n            if (body.name) {\n                resultElement.name = body.name;\n            }\n            if (body.headImage) {\n                resultElement.head_image = body.headImage;\n            }\n            if (body.phone) {\n                resultElement.phone = body.phone;\n            }\n            if (body.pwd) {\n                resultElement.pwd = body.pwd;\n            }\n            if (body.email) {\n                resultElement.email = body.email;\n            }\n            const modSql = 'update user set name = ?,head_image = ?,phone = ?,pwd = ?,email =? where id = ?';\n            const modSqlParams = [resultElement.name, resultElement.head_image, resultElement.phone, resultElement.pwd, resultElement.email, resultElement.id];\n            connection.query(modSql, modSqlParams, function (err, result) {\n                if (err) {\n                    return result;\n                }\n                res.send('update success ' + result.affectedRows + ' row');\n            });\n        });\n    });\n})\n// 删除用户\napp.delete('/deleteuser', function (req, res) {\n    console.log('-------------------------------');\n    let body = '';\n    req.on('data', function (chunk) {\n        body += chunk;\n    })\n    req.on('end', function () {\n        body = querystring.parse(body);\n        if (!body.id) {\n            res.send('参数错误');\n            return;\n        }\n        const deleteSql = 'delete from user where id = ?';\n        const deleteParams = [body.id];\n        connection.query(deleteSql, deleteParams, function (error, result) {\n            if (error) return;\n            res.send('delete success ' + result.affectedRows + ' row');\n        })\n\n    })\n\n})\n// 开启服务\nconst server = app.listen(8081, function () {\n\n    const host = server.address().address;\n    const port = server.address().port;\n\n    console.log(\"应用实例，访问地址为 http://%s:%s\", host, port)\n\n});\n```\n","\r\n#### let&const\r\n\r\n| 关键字 | 是否可重复声明 | 定义变/常量 |   作用域   |\r\n| :----: | :------------: | :---------: | :--------: |\r\n|  let   |       否       |     变      | 块级作用域 |\r\n| const  |       否       |     常      | 块级作用域 |\r\n\r\n#### 箭头函数\r\n\r\n```javascript\r\nlet double = function(a){\r\n    return 2*a;\r\n}\r\n// 等价于\r\nlet double = (a)=>{\r\n    return 2*a;\r\n}\r\n// 当参数只有一个可以省略括号\r\nlet double = a=>{\r\n    return 2*a;\r\n}\r\n// 当返回只有一个可以省略花括号+return\r\nlet double = a=>2*a\r\n```\r\n\r\n#### 函数-参数\r\n\r\n##### RestParameter\r\n\r\n```javascript\r\n// 1.收集参数\r\nfunction alert(a,b,...args){\r\n\talert(args);\r\n}\r\nshow(1,2,3,4,5) // alert 3,4,5\r\n// RestParameter必须是最后一个参数\r\n\r\n// 2. 数组展开\r\nlet show = (a,b,c)=>{\r\n    alert(a);\r\n    alert(b);\r\n    alert(c);\r\n}\r\n// show(1,2,3);\r\n//等价于\r\nlet arr = [1,2,3];\r\nshow(...arr);\r\n```\r\n\r\n##### 默认参数\r\n\r\n```javascript\r\nlet show = (a,b=10,c=5)=>{\r\n\treturn a+b+c;\r\n}\r\nshow(1); // 16\r\n```\r\n\r\n#### 解构赋值\r\n\r\n>- 左右两边结构必须一致\r\n>- 右边为实际参数\r\n>- 声明与赋值不可拆开\r\n\r\n```javascript\r\nlet arr = [1,2,3];\r\na= arr[0];\r\na= arr[1];\r\na= arr[2];\r\n// 等价于\r\nlet[a,b,c] = [1,2,3];\r\n// 其他类型只需两边结构保持一致即可\r\n```\r\n\r\n#### 数组\r\n\r\n>1. map\r\n>2. reduce\r\n>3. filter\r\n>4. forEach\r\n\r\n```javascript\r\n// map 映射\r\nlet arr = [1,2,3];\r\nlet res = arr.map(item=>item>=2?'good':'bad');// bad good good\r\n// reduce 汇总\r\nlet res = arr.reduce((temp,item,index)=>temp+item); // 求和 6\r\nlet res = res/arr.length // 平均数  2\r\n// filter\r\nlet res = arr.filter(item=>{\r\n    if(item>2){\r\n        return true;\r\n    }else{\r\n        return false;\r\n    }\r\n}) // 3\r\n// forEach\r\narr.forEach((item,index)=>{\r\n    console.log(item,index);\r\n}) // 1 0 ,2 1,3 2\r\n```\r\n\r\n#### 字符串\r\n\r\n>1. startsWith --- 判断地址协议\r\n>2. endsWith --- 判断文件类型\r\n>3. 模板字符串 `` --- 两个反单引号\r\n\r\n#### 面向对象\r\n\r\n```javascript\r\nclass User{\r\n    constructor(name,pwd){\r\n        this.name = name;\r\n        this.pwd = pwd;\r\n    }\r\n    showName(){alert(this.name);}\r\n    showPwd(){alert(this.pwd);}\r\n}\r\nlet u1 = new User('name','pwd');\r\nu1.showName(); // name\r\nu1.showPwd(); // pwd\r\n// 继承\r\nclass Vip extends User{\r\n    constructor(name,pwd,level){\r\n        super(name,pwd);\r\n        this.level = level;\r\n    }\r\n    showLevel(){alert(this.level);}\r\n}\r\nlet v1 = new Vip('name','pwd','level');\r\nv1.showLevel(); // level\r\n```\r\n\r\n#### JSON\r\n\r\n>```javascript\r\n>// 转换字符串\r\n>let json = {a:1,b:2}\r\n>let url = 'localhost/get?data='+encodeURIComponent(JSON.stringify(json));\r\n>// 解析\r\n>let jsonstr = '{\"a\":1,\"b\":2}';\r\n>JSON.parse(jsonstr);\r\n>// 当json名字值一样可以省 略值\r\n>let a = 1;\r\n>let b = 2;\r\n>let json = {a:a,b:b}\r\n>// 等价于\r\n>let json = {a,b}\r\n>let json = {\r\n>    a:1;\r\n>    show:function(){...}\r\n>\t// 简写\r\n>\tshow(){...}\r\n>}\r\n>```\r\n\r\n#### Promise\r\n\r\n```javascript\r\nlet p = new Promise((resolve,reject)=>{\r\n    // 异步代码 在请求成功调用resolve 失败调用reject\r\n    $.ajax({\r\n        url:'arr.txt',\r\n        dataType:'json',\r\n        success(arr){\r\n            resolve(arr);\r\n        },\r\n        error(err){\r\n            reject(err);\r\n        }\r\n    })\r\n})\r\np.then(function(arr){\r\n    console.log(arr);\r\n},function(err){\r\n    console.log(err);\r\n})\r\n// 多异步结果判断\r\nlet p1 = new Promise((resolve,reject)=>{\r\n    // 异步代码 在请求成功调用resolve 失败调用reject\r\n    ...\r\n});\r\nlet p2 = new Promise((resolve,reject)=>{\r\n    // 异步代码 在请求成功调用resolve 失败调用reject\r\n   ...\r\n})\r\nPromise.all([p1,p2]).then(res=>{},err=>{});\r\n// 竞争资源\r\nPromise.race(\r\n\t// 多异步操作 取最先返回的信息\r\n);\r\n```\r\n\r\n#### Generator\r\n\r\n```javascript\r\n// 生成器函数 在function和方法名之间加个*号\r\nfunction* showGenerator(){\r\n    alert(1);\r\n    yield;\r\n    alert(2);\r\n}\r\n// 返回一个对象 通过next()执行下一步 遇到yield暂停 默认不执行\r\nlet genObj = showGenerator();\r\ngenObj.next(); // alert(1)\r\ngenObj.next(); // alert(2)\r\n\r\n// yield 传参\r\nfunction* showGenerator(){\r\n    console.log(1);\r\n    let a = yield;\r\n    console.log(a); // 2\r\n    console.log(2);\r\n}\r\nlet genObj = showGenerator();\r\ngenObj.next(1);\r\ngenObj.next(2);\r\n\r\n// yield返回中间结果\r\nfunction* showGenerator(){\r\n    let a = 1;\r\n    yield a;\r\n    a = 2*a;\r\n    return a;\r\n}\r\nlet genObj = showGenerator();\r\nlet res1 = genObj.next(); // value:1 done:false\r\nlet res2 = genObj.next(); // value:2 done:true\r\n```\r\n\r\n#### Async --- Generator 函数的语法糖。\r\n\r\n使用Generator 读取两个文件\r\n\r\n```javascript\r\nconst fs = require('fs');\r\n\r\nconst readFile = function (fileName) {\r\n  return new Promise(function (resolve, reject) {\r\n    fs.readFile(fileName, function(error, data) {\r\n      if (error) return reject(error);\r\n      resolve(data);\r\n    });\r\n  });\r\n};\r\n// gen函数\r\nconst gen = function* () {\r\n  const f1 = yield readFile('/etc/fstab');\r\n  const f2 = yield readFile('/etc/shells');\r\n  console.log(f1.toString());\r\n  console.log(f2.toString());\r\n};\r\n// async函数\r\nconst asyncReadFile = async function () {\r\n  const f1 = await readFile('/etc/fstab');\r\n  const f2 = await readFile('/etc/shells');\r\n  console.log(f1.toString());\r\n  console.log(f2.toString());\r\n};\r\n```","\r\n> Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\r\n\r\n#### HelloWorld\r\n\r\n```html\r\n\u003C!--导入js-->\r\n\u003Cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\">\u003C/script>\r\n\u003C!--html-->\r\n\u003Cdiv id=\"app\">\r\n  {{ message }}\r\n\u003C/div>\r\n\u003C!--js-->\r\n\u003Cscript>\r\n    let app = new Vue({\r\n        el: '#app',\r\n        data: {\r\n            message: 'Hello Vue!'\r\n        }\r\n    })\r\n\u003C/script>\r\n```\r\n\r\n>Hello Vue!\r\n\r\n#### 条件和循环\r\n\r\n- v-if\r\n- v-for\r\n\r\nExample\r\n\r\n```html\r\n\u003Cp v-if=\"seen\">test\u003C/p>\r\n\u003Col>\r\n  \u003Cli v-for=\"todo in todos\">\r\n    {{ todo.msg }}\r\n  \u003C/li>\r\n\u003C/ol>\r\n\u003C!--js-->\r\n\u003Cscript>\r\n    let app = new Vue({\r\n        el: '#app',\r\n        data: {\r\n            seen:true,\r\n            todos:[\r\n                {\r\n                    id:1,\r\n                    msg:'1的待办'\r\n                }\r\n            ]\r\n        }\r\n    })\r\n\u003C/script>\r\n```\r\n\r\nv-for迭代对象属性\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Ch1>对象属性迭代\u003C/h1>\r\n    \u003Cdiv v-for=\"(value, key) in obj\">\r\n        {{ key }} : {{ value }}\r\n    \u003C/div>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            obj: {\r\n                id:'id',\r\n                title: \"title\"\r\n            },\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n\r\n\r\n#### 表单数据绑定\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cp>input {{input}}\u003C/p>\r\n    \u003Cinput v-model=\"input\">\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            input: ''\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n 表单复选框绑定\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cp>check {{check}}\u003C/p>\r\n    \u003Clabel for=\"a\">a\u003C/label>\r\n    \u003Cinput type=\"checkbox\" id=\"a\" v-model=\"check\" value=\"a\">\r\n    \u003Clabel for=\"b\">b\u003C/label>\r\n    \u003Cinput type=\"checkbox\" id=\"b\" v-model=\"check\" value=\"b\">\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            check: []\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n 表单单选按钮\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cp>sex {{sex}}\u003C/p>\r\n    \u003Cinput type=\"radio\" id=\"male\" value=\"男\" v-model=\"sex\">\r\n    \u003Clabel for=\"male\">男\u003C/label>\r\n    \u003Cbr>\r\n    \u003Cinput type=\"radio\" id=\"female\" value=\"女\" v-model=\"sex\">\r\n    \u003Clabel for=\"female\">女\u003C/label>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            sex:'',\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n下拉框\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cp>select {{select}}\u003C/p>\r\n    \u003Cselect v-model=\"select\" style=\"width:210px;\">\r\n        \u003Coption value=\"1\">a\u003C/option>\r\n        \u003Coption value=\"2\">b\u003C/option>\r\n        \u003Coption value=\"3\">c\u003C/option>\r\n        \u003Coption value=\"4\">d\u003C/option>\r\n        \u003Coption value=\"5\">e\u003C/option>\r\n    \u003C/select>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            select:'',\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n\r\n\r\n#### 事件\r\n\r\nv-on为页面元素绑定各种事件。（keydown, keyup, click, dbclick, load, etd.）\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cp>点击了：{{clickNum}}\u003C/p>\r\n    \u003Cbutton v-on:click=\"btnClick('1')\">1\u003C/button>\r\n    \u003Cbutton @click=\"btnClick('2')\">2\u003C/button>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            clickNum: ''\r\n        },\r\n        methods: {num\r\n            btnClick: function(num){\r\n                this.clickNum = num;\r\n            },\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n####  组件\r\n\r\n定义一个可复用的代码块\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n  \u003Col>\r\n    \u003Ctodo v-for=\"todo in todos\" v-bind:todo=\"todo\">\u003C/todo>\r\n  \u003C/ol>\r\n\u003C/div>\r\n\u003Cscript>\r\n// 定义全局组件\r\nVue.component('todo', {\r\n  props: ['todo'],\r\n  template: '\u003Cli>{{ todo }}\u003C/li>'\r\n});\r\n// 定义组件\r\nlet todoComponent = '\u003Cli>{{todo}}\u003C/li>'\r\nvar myApp = new Vue({\r\n    el: '#myApp',\r\n    data: {\r\n    todos: [\r\n        'todo1',\r\n        'todo2',\r\n        'todo3'\r\n    ]\r\n  },\r\n    // 局部组件\r\n    components: {\r\n        'todo': todoComponent\r\n    },\r\n    \r\n});\r\n\u003C/script>\r\n```\r\n\r\n#### 过滤器\r\n\r\n格式化变量内容的输出。（日期格式化，字母大小写，数字再计算等等）\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cp>{{message}}\u003C/p>\r\n    \u003Cp>{{message | upMsg }}\u003C/p>\r\n    \u003Cp>{{num}}=({{num | topercentage}})。\u003C/p>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            msg: 'hello world',\r\n            num: 0.6\r\n        },\r\n        filters: {\r\n            upMsg: function(value){\r\n                return value.toUpperCase();\r\n            },\r\n            topercentage: function(value){\r\n                return value * 100 + '%';\r\n            },\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n####  计算属性\r\n\r\n处理元数据，便于进行二次利用\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    {{num}}{{twoNum}}\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            num: 1\r\n        },\r\n        computed: {\r\n            twoNum: function(){\r\n                return this.num * 2;\r\n            }\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\nsetter : 设置计算属性，同步更新元数据的值\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    num:{{num}}\r\n    \u003Cbr>\r\n    price:{{price}}\r\n    \u003Cbutton @click=\"btnClick(200)\">price+200--->num+1\u003C/button>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            num: 1\r\n        },\r\n        computed: {\r\n            price: {\r\n                get:function () {\r\n                    return this.num * 200\r\n                },\r\n                set:function (price) {\r\n                    this.num = price / 200\r\n                }\r\n            }\r\n        },\r\n        methods:{\r\n            btnClick:function (price) {\r\n                this.price += 200;\r\n            }\r\n        }\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n####  观察属性\r\n\r\n与computed属性类似，用于观察变量的变化，然后进行相应的处理。\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cp>{{price}}\u003C/p>\r\n    \u003Cbutton @click=\"btnClick(1)\">num+1\u003C/button>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            num: 0,\r\n            price:0,\r\n        },\r\n        watch: {\r\n            num: function(newVal, oldVal){\r\n                this.price = 200 * newVal;\r\n            },\r\n        },\r\n        methods: {\r\n            btnClick: function(n){\r\n                this.num += n;\r\n            },\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n#### Class绑定\r\n\r\n```html\r\n\u003Cstyle>\r\n    .red{\r\n        color: red;\r\n    }\r\n    .blue{\r\n        color: blue;\r\n    }\r\n\u003C/style>\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cdiv v-bind:class=\"{red:isRed}\">red\u003C/div>\r\n    \u003Cdiv :class=\"{blue:isBlue}\">blue\u003C/div>\r\n    \u003Cbutton @click=\"btnClick\">true/false\u003C/button>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            isRed: true,\r\n            isBlue: true,\r\n        },\r\n        methods: {\r\n            btnClick: function(){\r\n                this.isRed = !this.isRed;\r\n                this.isBlue = !this.isBlue;\r\n            },\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n绑定对象\r\n\r\n```html\r\n\u003Cstyle>\r\n    .red{\r\n        color: red;\r\n    }\r\n\u003C/style>\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Cdiv :class=\"color\">color\u003C/div>\r\n    \u003Cbutton @click=\"btnClick\">true/false\u003C/button>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            color:{\r\n                red:true\r\n            }\r\n        },\r\n        methods: {\r\n            btnClick: function(){\r\n                this.color.red = !this.color.red;\r\n            },\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n####  条件渲染\r\n\r\n- v-if\r\n- v-else-if\r\n- v-else\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Ch1 v-if=\"score == 0\">socre==0\u003C/h1>\r\n    \u003Ch1 v-else-if=\"score \u003C 2\">{{score}},score\u003C2\u003C/h1>\r\n    \u003Ch1 v-else-if=\"score \u003C= 4\">{{score}},score\u003C=4\u003C/h1>\r\n    \u003Ch1 v-else>{{score}}, score==5\u003C/h1>\r\n    \u003Cbutton @click=\"btnClick\">get random score\u003C/button>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n        data: {\r\n            score: 0\r\n        },\r\n        methods: {\r\n            btnClick: function(){\r\n                this.score = Math.round(Math.random() * 5);\r\n            },\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n####  元素显示\r\n\r\n- v-show\r\n\r\nv-show设置的标记在html DOM中不会消失(if是删除dom,show是改变display)\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Ch1 v-show=\"isShow\">show\u003C/h1>\r\n    \u003Cbutton @click=\"btnClick\">change show\u003C/button>\r\n\u003C/div>\r\n\u003Cscript>\r\n    var myApp = new Vue({\r\n        el: '#myApp', \r\n        data: {\r\n            isShow: true\r\n        },\r\n        methods: {\r\n            btnClick: function(){\r\n                this.isShow = !this.isShow;\r\n            },\r\n        },\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n####  表单修饰符\r\n\r\n- .lazy\r\n- .number\r\n- .trim\r\n\r\n#####  .lazy\r\n\r\n用户输入内容时不做绑定数据的更新处理，在控件的onchange事件中更新绑定的变量。\r\n\r\n```html\r\n用户名：\u003Cinput v-model.lazy=\"username\">\r\n```\r\n\r\n#####  .number\r\n\r\n将用户输入的内容转换为数值类型，如果用户输入非数值的时候，则返回NaN。\r\n\r\n```html\r\n年龄：\u003Cinput v-model.number=\"age\" type=\"number\">\r\n```\r\n\r\n##### .trim\r\n\r\n自动去掉用户输入内容两端的空格。\r\n\r\n```html\r\n意见：\u003Cinput v-model.trim=\"content\">\r\n```\r\n\r\n#### 插槽\r\n\r\n>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 [Web Components 规范草案](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md)，将 `\u003Cslot>` 元素作为承载分发内容的出口。\r\n\r\n```html\r\n\u003Cdiv id=\"myApp\">\r\n    \u003Calert-box>111\u003C/alert-box>\r\n\u003C/div>\r\n\u003Cscript>\r\n    Vue.component('alert-box', {\r\n        template: `\r\n    \u003Cdiv class=\"demo-alert-box\">\r\n      \u003Cstrong>后面是插槽内容--->\u003C/strong>\r\n      \u003Cslot>\u003C/slot>\r\n    \u003C/div>\r\n  `\r\n    })\r\n    var myApp = new Vue({\r\n        el: '#myApp',\r\n    });\r\n\u003C/script>\r\n```\r\n\r\n```\r\n后面是插槽内容---> 111\r\n```\r\n\r\n#### 最后\r\n\r\n按照惯例,最后附上[官方文档](https://cn.vuejs.org/v2/guide/index.html)","\r\n在了解Vue Router之前,先简单介绍以下Vue CLI.\r\n\r\nVue CLI 是一个基于 Vue.js 进行快速开发的完整系统.在3.0之后提供了ui管理页面,你可以借此轻松创建一个基于vue的项目脚手架并进行管理.\r\n\r\n#### 创建项目\r\n\r\n在创建项目之前,你需要先安装vue cli.\r\n\r\n```bash\r\nnpm install -g @vue/cli\r\n# 查看版本\r\nvue --version\r\n```\r\n\r\n安装完成之后,便可以进行项目的初始化\r\n\r\n```bash\r\nvue create hello-world\r\n# or\r\nvue ui #推荐 基于ui还可以进行项目的启动,管理与监控\r\n```\r\n\r\n然后就可以先熟悉一下项目结构\r\n\r\n>src/下的结构\r\n>\r\n>components 功能组件\r\n>\r\n>router 路由配置\r\n>\r\n>store vuex的store配置\r\n>\r\n>view 页面组件\r\n\r\n接下来你就可以在router/index.js进行路由的相关配置\r\n\r\n#### 路由配置\r\n\r\n通过vue cli默认会生成该路由配置\r\n\r\n```javascript\r\nimport Vue from 'vue'\r\nimport VueRouter from 'vue-router'\r\nimport Home from '../views/Home.vue'\r\n\r\nVue.use(VueRouter)\r\n\r\n  const routes = [\r\n  {\r\n    path: '/',\r\n    name: 'Home',\r\n    component: Home\r\n  },\r\n  {\r\n    path: '/about',\r\n    name: 'About',\r\n    // route level code-splitting\r\n    // this generates a separate chunk (about.[hash].js) for this route\r\n    // which is lazy-loaded when the route is visited.\r\n    component: () => import(/* webpackChunkName: \"about\" */ '../views/About.vue')\r\n  }\r\n]\r\n\r\nconst router = new VueRouter({\r\n  mode: 'history',\r\n  base: process.env.BASE_URL,\r\n  routes\r\n})\r\n\r\nexport default router\r\n```\r\n\r\n通过配置routers,即可实现路由到的组件.\r\n\r\n然后再app.vue配置router view用于渲染具体路由的组件,以下是默认生成的`app.vue`\r\n\r\n```vue\r\n\u003Ctemplate>\r\n  \u003Cdiv id=\"app\">\r\n    \u003Cdiv id=\"nav\">\r\n      \u003Crouter-link to=\"/\">Home\u003C/router-link> |\r\n      \u003Crouter-link to=\"/about\">About\u003C/router-link>\r\n    \u003C/div>\r\n    \u003Crouter-view/>\r\n  \u003C/div>\r\n\u003C/template>\r\n\r\n\u003Cstyle>\r\n#app {\r\n  font-family: Avenir, Helvetica, Arial, sans-serif;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n  text-align: center;\r\n  color: #2c3e50;\r\n}\r\n\r\n#nav {\r\n  padding: 30px;\r\n}\r\n\r\n#nav a {\r\n  font-weight: bold;\r\n  color: #2c3e50;\r\n}\r\n\r\n#nav a.router-link-exact-active {\r\n  color: #42b983;\r\n}\r\n\u003C/style>\r\n```\r\n\r\n至此,一个最简单的路由功能便实现了\r\n\r\n继续深入了解--->[官方文档](https://router.vuejs.org/zh/guide/)","\r\n#### 基本概念\r\n\r\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。简单的说,就是定义了一个管理全局组件数据的容器,并且是全局单例的,如果你对Spring的IOC有所了解的话,那应该很好理解.\r\n\r\n#### state\r\n\r\nstate:简单的说,就是需要全局共享的数据 eg\r\n\r\n```javascript\r\n// vuex/index.js\r\nimport Vue from 'vue';\r\nimport Vuex from 'vuex';\r\n\r\nVue.use(Vuex);\r\nexport default new Vuex.Store({\r\n  state:{\r\n    username:'alight',\r\n  }\r\n})\r\n// main.js\r\nimport store from  './vuex';\r\nVue.use(ElementUI);\r\nnew Vue({\r\n  el: '#app',\r\n  render: h => h(App),\r\n  router,\r\n  store\r\n});\r\n```\r\n\r\n组件中如何获取store的数据\r\n\r\n```vue\r\n\u003C!--通过store直接获取具体的state-->\r\n\u003Ctemplate>\r\n  \u003Cdiv>\r\n    {{$store.state.username}} \u003C!--alight-->\r\n  \u003C/div>\r\n\u003C/template>\r\n\u003C!--通过mapState-->\r\n\u003Ctemplate>\r\n  \u003Cdiv>\r\n    {{username}},{{age}} \u003C!--alight,18-->\r\n  \u003C/div>\r\n\u003C/template>\r\n\r\n\u003Cscript>\r\n  import {mapState} from 'vuex'\r\n  export default {\r\n    name: \"test\",\r\n    computed: {\r\n      ...mapState(['username', 'age'])\r\n    }\r\n  }\r\n\u003C/script>\r\n```\r\n\r\n#### Mutation\r\n\r\n更改 Vuex 的 store 中的state的唯一方法是提交 mutation。\r\n\r\n定义mutation方法\r\n\r\n```javascript\r\nexport default new Vuex.Store({\r\n\r\n  state:{\r\n    username:'zh',\r\n    age:18,\r\n    count:0\r\n  },\r\n  mutationns:{\r\n    addN(state,n){\r\n      state.count+=n\r\n    }\r\n  }\r\n })\r\n```\r\n\r\n调用mutation方法以及传递参数\r\n\r\n```vue\r\n\u003Ctemplate>\r\n  \u003Cdiv>\r\n    {{count}}\r\n    \u003Cel-button @click=\"addCount\">add count\u003C/el-button>\r\n  \u003C/div>\r\n\u003C/template>\r\n\r\n\u003Cscript>\r\n  import {mapState} from 'vuex'\r\n\r\n  export default {\r\n    name: \"test\",\r\n    computed: {\r\n      ...mapState(['count'])\r\n    },\r\n    methods:{\r\n      addCount(){\r\n        this.$store.commit('addN',3);\r\n      }\r\n    }\r\n  }\r\n\u003C/script>\r\n```\r\n\r\n通过mapMutations触发mutation\r\n\r\n```javascript\r\nimport { mapMutations } from 'vuex'\r\n\r\nexport default {\r\n  // ...\r\n  methods: {\r\n    ...mapMutations([\r\n      'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\r\n\r\n      // `mapMutations` 也支持载荷：\r\n      'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`\r\n    ]),\r\n    ...mapMutations({\r\n      add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')`\r\n    })\r\n  }\r\n}\r\n```\r\n\r\n>#### Mutation 必须是同步函数\r\n>\r\n>一条重要的原则就是要记住 **mutation 必须是同步函数**。为什么？请参考下面的例子：\r\n>\r\n>```javascript\r\n>mutations: {\r\n>  someMutation (state) {\r\n>    api.callAsyncMethod(() => {\r\n>      state.count++\r\n>    })\r\n>  }\r\n>}\r\n>```\r\n>\r\n>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。\r\n\r\n#### Action\r\n\r\nAction 类似于 mutation，不同在于：\r\n\r\n- Action 提交的是 mutation，而不是直接变更状态。\r\n- Action 可以包含任意**异步操作**。\r\n\r\n```javascript\r\nconst store = new Vuex.Store({\r\n  state: {\r\n    count: 0\r\n  },\r\n  mutations: {\r\n    increment (state,n) {\r\n      state.count+=n\r\n    }\r\n  },\r\n  actions: {\r\n    // Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象\r\n    increment (context,n) {\r\n      context.commit('increment',n)\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n```javascript\r\n// 触发action\r\nthis.$store.dispath('addAsync',5)\r\n// 使用 mapActions触发\r\nimport { mapActions } from 'vuex'\r\nexport default {\r\n  // ...\r\n  methods: {\r\n      ...mapActions([\r\n          'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\r\n\r\n          // `mapActions` 也支持载荷：\r\n          'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`\r\n      ]),\r\n      ...mapActions({\r\n          add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\r\n      })\r\n  }\r\n}\r\n```\r\n\r\n#### Getter\r\n\r\n> Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。\r\n\r\n```javascript\r\nconst store = new Vuex.Store({\r\n  state: {\r\n    todos: [\r\n      { id: 1, text: '...', done: true },\r\n      { id: 2, text: '...', done: false }\r\n    ]\r\n  },\r\n  getters: {\r\n    doneTodos: state => {\r\n      return state.todos.filter(todo => todo.done)\r\n    }\r\n  }\r\n})\r\n```\r\n\r\n#####  通过属性访问\r\n\r\n```javascript\r\nstore.getters.doneTodos // -> [{ id: 1, text: '...', done: true }]\r\n```\r\n\r\n##### 通过方法访问\r\n\r\n```javascript\r\ngetters: {\r\n  // ...\r\n  getTodoById: (state) => (id) => {\r\n    return state.todos.find(todo => todo.id === id)\r\n  }\r\n}\r\n```\r\n\r\n```javascript\r\nstore.getters.getTodoById(2) // -> { id: 2, text: '...', done: false }\r\n```\r\n\r\n\r\n\r\n##### mapGetters\r\n\r\n```javascript\r\nimport { mapGetters } from 'vuex'\r\n\r\nexport default {\r\n  // ...\r\n  computed: {\r\n  // 使用对象展开运算符将 getter 混入 computed 对象中\r\n    ...mapGetters([\r\n      'doneTodosCount',\r\n      'anotherGetter',\r\n      // ...\r\n    ])\r\n  }\r\n}\r\n```\r\n\r\n#### Module\r\n\r\n> 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\r\n>\r\n> 为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\r\n\r\n```javascript\r\nconst moduleA = {\r\n  state: () => ({ ... }),\r\n  mutations: { ... },\r\n  actions: { ... },\r\n  getters: { ... }\r\n}\r\n\r\nconst moduleB = {\r\n  state: () => ({ ... }),\r\n  mutations: { ... },\r\n  actions: { ... }\r\n}\r\n\r\nconst store = new Vuex.Store({\r\n  modules: {\r\n    a: moduleA,\r\n    b: moduleB\r\n  }\r\n})\r\n\r\nstore.state.a // -> moduleA 的状态\r\nstore.state.b // -> moduleB 的状态\r\n```\r\n\r\n... ...\r\n\r\n[官方文档](https://vuex.vuejs.org/zh/)\r\n\r\n","\r\n毛玻璃（磨砂玻璃、半透明）特效在苹果的生态中一直十分常见，事实上你现在也能在非常多的地方看到这个特效，因为它确实是个很cool的设计（苹果的设计i了i了）。随着浏览器对css的支持越来越完善，当今你已经可以利用css在最新的浏览器中实现毛玻璃的效果了。\r\n\r\n#### 步骤\r\n\r\n首先你需要一个盒子载体\r\n\r\n```html\r\n\u003Cbody>\r\n    \u003Cbox>box content\u003C/box>\r\n\u003C/body>\r\n```\r\n\r\n然后可以开启css进行点缀\r\n\r\n```css\r\n*{\r\n    margin: 0;\r\n    padding: 0;\r\n}\r\nbody{\r\n    width: 100%;\r\n    height: 100vh;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n    background-image: url(\"bg.jpg\");\r\n    background-size: cover;\r\n    background-attachment: fixed;\r\n}\r\nbox{\r\n    width: 500px;\r\n    height: 300px;\r\n    padding: 2rem;\r\n    color: #f9f9f9;\r\n    background-color: rgba(0, 0, 0, .1);\r\n    box-shadow: 0 2px 4px rgba(255, 255, 255, .12), 0 0 6px rgba(255, 255, 255, .04);\r\n    border-radius: 10px;\r\n    box-sizing: border-box;\r\n    backdrop-filter: blur(20px);\r\n}\r\n```\r\n\r\n装饰之后大概就是这么一个效果，好康就完了！\r\n\r\n\u003Cimg src=\"https://alightyoung.gitee.io/static/img/36.png\"/>\r\n\r\n\r\n\r\n这里值得一说的是`background-attachment`和`backdrop-filter`。\r\n\r\n`background-attachment` CSS 属性决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。\r\n\r\n`backdrop-filter` CSS 属性可以让你为一个元素后面区域添加图形效果（如模糊或颜色偏移）。 因为它适用于元素*背后*的所有元素，为了看到效果，必须使元素或其背景至少部分透明。\r\n\r\n说到`backdrop-filter`就顺带说一下`filter`，因为它们的效果差不多，只是作用的元素不同，backdrop-filter只会影响元素背后的内容，而`filter`是作用于自身（也就是会影响内容的显示）\r\n\r\n\r\n\r\n所以此处的核心在于使背景颜色透明(rgba)的同时，再通过backdrop-filter使背后的图片模糊处理，从而达到一个毛玻璃的效果。\r\n\r\n\r\n\r\n#### 最后\r\n\r\n今天也是不务正业的一天 over。\r\n\r\n","\r\n### Sass简介\r\n\r\nSass 是一种 CSS 的预编译语言。它提供了 变量（variables）、嵌套（nested rules）、 [混合（mixins）]、 函数（functions）等功能，并且完全兼容 CSS 语法。Sass 能够帮助复杂的样式表更有条理， 并且易于在项目内部或跨项目共享设计。\r\n\r\n#### Sass和Less\r\n\r\nSass和Less都属于CSS预处理器。但是Sass比Less要更加强大。\r\n\r\n#### Sass与Scss\r\n\r\nScss 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。可以简单理解为Scss是Sass的一个升级版本，完全兼容sass之前的功能，又有了些新增能力。语法形式上有些许不同。\r\n\r\n### 变量\r\n\r\n`sass`让人们受益的一个重要特性就是它为`css`引入了变量。你可以把反复使用的`css`属性值 定义成变量，然后通过变量名来引用它们，而无需重复书写这一属性值。或者，对于仅使用过一 次的属性值，你可以赋予其一个易懂的变量名，让人一眼就知道这个属性值的用途。\r\n\r\n#### 变量声明\r\n\r\n`sass`变量的声明和`css`属性的声明很像：\r\n\r\n```scss\r\n$highlight-color: #F90;\r\n```\r\n\r\n#### 变量引用\r\n\r\n凡是`css`属性的标准值（比如说1px或者bold）可存在的地方，变量就可以使用。`css`生成时，变量会被它们的值所替代。之后，如果你需要一个不同的值，只需要改变这个变量的值，则所有引用此变量的地方生成的值都会随之改变。\r\n\r\n```scss\r\n$highlight-color: #F90;\r\n.selected {\r\n  border: 1px solid $highlight-color;\r\n}\r\n\r\n//编译后\r\n\r\n.selected {\r\n  border: 1px solid #F90;\r\n}\r\n```\r\n\r\n### 嵌套CSS 规则\r\n\r\nscss写法\r\n\r\n```scss\r\n#content {\r\n  article {\r\n    h1 { color: #333 }\r\n    p { margin-bottom: 1.4em }\r\n  }\r\n  aside { background-color: #EEE }\r\n}\r\n```\r\n\r\n==>\r\n\r\n```css\r\n /* 编译后 */css\r\n#content article h1 { color: #333 }\r\n#content article p { margin-bottom: 1.4em }\r\n#content aside { background-color: #EEE }\r\n```\r\n\r\n#### 父选择器的标识符&\r\n\r\n&会被解释为父选择器\r\n\r\n```scss\r\narticle a {\r\n  color: blue;\r\n  &:hover { color: red }\r\n}\r\n```\r\n\r\n==>\r\n\r\n```css\r\narticle a { color: blue }\r\narticle a:hover { color: red }\r\n```\r\n\r\n#### 群组选择器的嵌套\r\n\r\n```scss\r\nnav, aside {\r\n  a {color: blue}\r\n}\r\n```\r\n\r\n==>\r\n\r\n```css\r\nnav a, aside a {color: blue}\r\n```\r\n\r\n#### 子组合选择器和同层组合选择器：>、+和~\r\n\r\n```scss\r\narticle {\r\n  ~ article { border-top: 1px dashed #ccc }\r\n  > section { background: #eee }\r\n  dl > {\r\n    dt { color: #333 }\r\n    dd { color: #555 }\r\n  }\r\n  nav + & { margin-top: 0 }\r\n}\r\n```\r\n\r\n==>\r\n\r\n```css\r\narticle ~ article { border-top: 1px dashed #ccc }\r\narticle > footer { background: #eee }\r\narticle dl > dt { color: #333 }\r\narticle dl > dd { color: #555 }\r\nnav + article { margin-top: 0 }\r\n```\r\n\r\n#### 嵌套属性\r\n\r\nEg.1\r\n\r\n```scss\r\nnav {\r\n  border: {\r\n  style: solid;\r\n  width: 1px;\r\n  color: #ccc;\r\n  }\r\n}\r\n```\r\n\r\n==>\r\n\r\n```css\r\nnav {\r\n  border-style: solid;\r\n  border-width: 1px;\r\n  border-color: #ccc;\r\n}\r\n```\r\n\r\nEg.2\r\n\r\n```scss\r\nnav {\r\n  border: 1px solid #ccc {\r\n  left: 0px;\r\n  right: 0px;\r\n  }\r\n}\r\n```\r\n\r\n==>\r\n\r\n```css\r\nnav {\r\n  border: 1px solid #ccc;\r\n  border-left: 0px;\r\n  border-right: 0px;\r\n}\r\n```\r\n\r\n### 导入SASS文件\r\n\r\n`css`有一个特别不常用的特性，即`@import`规则，它允许在一个`css`文件中导入其他`css`文件。然而，后果是只有执行到`@import`时，浏览器才会去下载其他`css`文件，这导致页面加载起来特别慢。\r\n\r\n`sass`也有一个`@import`规则，但不同的是，`sass`的`@import`规则在生成`css`文件时就把相关文件导入进来。这意味着所有相关的样式被归纳到了同一个`css`文件中，而无需发起额外的下载请求。另外，所有在被导入文件中定义的变量和混合器均可在导入文件中使用。\r\n\r\n#### 使用SASS部分文件\r\n\r\n当通过`@import`把`sass`样式分散到多个文件时，你通常只想生成少数几个`css`文件。那些专门为`@import`命令而编写的`sass`文件，并不需要生成对应的独立`css`文件，这样的`sass`文件称为局部文件。对此，`sass`有一个特殊的约定来命名这些文件（`sass`局部文件的文件名以下划线开头。）\r\n\r\n举例来说，你想导入`themes/_night-sky.scss`这个局部文件里的变量，你只需在样式表中写`@import` `\"themes/night-sky\";`。\r\n\r\n####  默认变量值\r\n\r\n`sass`的`!default`标签,它很像`css`属性中`!important`标签的对立面，不同的是`!default`用于变量，含义是：如果这个变量被声明赋值了，那就用它声明的值，否则就用这个默认值。\r\n\r\n```scss\r\n$fancybox-width: 400px !default;\r\n.fancybox {\r\nwidth: $fancybox-width;\r\n}\r\n```\r\n\r\n在上例中，如果用户在导入你的`sass`局部文件之前声明了一个`$fancybox-width`变量，那么你的局部文件中对`$fancybox-width`赋值`400px`的操作就无效。如果用户没有做这样的声明，则`$fancybox-width`将默认为`400px`。\r\n\r\n#### 嵌套导入\r\n\r\n_blue-theme.scss\r\n\r\n```scss\r\naside {\r\n  background: blue;\r\n  color: white;\r\n}\r\n```\r\n\r\n把它导入到一个CSS规则内，如下所示：\r\n\r\n```scss\r\n.blue-theme {@import \"blue-theme\"}\r\n```\r\n\r\n==>\r\n\r\n```scss\r\n.blue-theme {\r\n  aside {\r\n    background: blue;\r\n    color: #fff;\r\n  }\r\n}\r\n```\r\n\r\n#### 原生的CSS导入\r\n\r\n由于`sass`兼容原生的`css`，所以它也支持原生的`CSS@import`。尽管通常在`sass`中使用`@import`时，`sass`会尝试找到对应的`sass`文件并导入进来，但在下列三种情况下会生成原生的`CSS@import`，尽管这会造成浏览器解析`css`时的额外下载：\r\n\r\n- 被导入文件的名字以`.css`结尾；\r\n- 被导入文件的名字是一个URL地址（比如http://www.sass.hk/css/css.css），由此可用谷歌字体API提供的相应服务；\r\n- 被导入文件的名字是`CSS`的url()值。\r\n\r\n这就是说，你不能用`sass`的`@import`直接导入一个原始的`css`文件，因为`sass`会认为你想用`css`原生的`@import`。但是，因为`sass`的语法完全兼容`css`，所以你可以把原始的`css`文件改名为`.scss`后缀，即可直接导入了。\r\n\r\n### 静默注释\r\n\r\n`sass`另外提供了一种不同于`css`标准注释格式`/* ... */`的注释语法，即静默注释，其内容不会出现在生成的`css`文件中\r\n\r\n```scss\r\nbody {\r\n  color: #333; // 这种注释内容不会出现在生成的css文件中\r\n  padding: 0; /* 这种注释内容会出现在生成的css文件中 */\r\n}\r\n```\r\n\r\n### 混合器\r\n\r\n混合器使用`@mixin`标识符定义。看上去很像其他的`CSS @`标识符，比如说`@media`或者`@font-face`。这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。\r\n\r\n\r\n\r\n定义混合器\r\n\r\n```scss\r\n@mixin rounded-corners {\r\n  -moz-border-radius: 5px;\r\n  -webkit-border-radius: 5px;\r\n  border-radius: 5px;\r\n}\r\n```\r\n\r\n引用混合器\r\n\r\n```scss\r\nnotice {\r\n  background-color: green;\r\n  border: 2px solid #00aa00;\r\n  @include rounded-corners;\r\n}\r\n```\r\n\r\n==>\r\n\r\n```css\r\n.notice {\r\n  background-color: green;\r\n  border: 2px solid #00aa00;\r\n  -moz-border-radius: 5px;\r\n  -webkit-border-radius: 5px;\r\n  border-radius: 5px;\r\n}\r\n```\r\n\r\n#### 给混合器传参\r\n\r\n混合器并不一定总得生成相同的样式。可以通过在`@include`混合器时给混合器传参，来定制混合器生成的精确样式。当`@include`混合器时，参数其实就是可以赋值给`css`属性值的变量。\r\n\r\n```scss\r\n@mixin link-colors($normal, $hover, $visited) {\r\n  color: $normal;\r\n  &:hover { color: $hover; }\r\n  &:visited { color: $visited; }\r\n}\r\n```\r\n\r\n当混合器被`@include`时，你可以把它当作一个`css`函数来传参。如果你像下边这样写：\r\n\r\n```\r\na {\r\n  @include link-colors(blue, red, green);\r\n}\r\n```\r\n\r\n==>\r\n\r\n```css\r\na { color: blue; }\r\na:hover { color: red; }\r\na:visited { color: green; }\r\n```\r\n\r\n当你@include混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，`sass`允许通过语法`$name: value`的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可：\r\n\r\n```scss\r\na {\r\n    @include link-colors(\r\n      $normal: blue,\r\n      $visited: green,\r\n      $hover: red\r\n  );\r\n}\r\n```\r\n\r\n#### 默认参数值\r\n\r\n为了在`@include`混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用`$name: default-value`的声明形式，默认值可以是任何有效的`css`属性值，甚至是其他参数的引用。\r\n\r\n### 选择器继承\r\n\r\n使用`sass`的时候，最后一个减少重复的主要特性就是选择器继承。基于`Nicole Sullivan`面向对象的`css`的理念，选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过`@extend`语法实现，如下代码:\r\n\r\n```scss\r\n//通过选择器继承继承样式\r\n.error {\r\n  border: 1px solid red;\r\n  background-color: #fdd;\r\n}\r\n.seriousError {\r\n  @extend .error;\r\n  border-width: 3px;\r\n}\r\n```\r\n\r\n`.seriousError`不仅会继承`.error`自身的所有样式，任何跟`.error`有关的组合选择器样式也会被`.seriousError`以组合选择器的形式继承，如下代码:\r\n\r\n```scss\r\n//.seriousError从.error继承样式\r\n.error a{  //应用到.seriousError a\r\n  color: red;\r\n  font-weight: 100;\r\n}\r\nh1.error { //应用到hl.seriousError\r\n  font-size: 1.2rem;\r\n}\r\n```\r\n\r\n如上所示，在`class=\"seriousError\"`的`html`元素内的超链接也会变成红色和粗体。\r\n\r\n#### 继承的高级用法\r\n\r\n略...感兴趣的参考[文档](https://www.sass.hk/guide/)\r\n\r\n### 最后\r\n\r\n至此，`sass`最基本部分已经介绍完了，通过这些基础知识，你已经可以尝试去使用sass来精简你的css了。","\n### picgo-简介\nPicGo: 一个用于快速上传图片并获取图片URL链接的工具\n\n利用picgo，你可以轻易的将本地或是网络的图片，上传到你的图床。本篇博客主要分享如何利用typora+ ~~gitee~~ github+picgo的方案实现个人图床，从此你再也不用担心博客图片突然失效了。\n\n:::danger\n**2020-10-29**\n\ngitee的外链有限制,大于~~1M~~（小文件可能也会）的图片无法访问(弃坑)\n\n推荐jsdelivr+github实现图床(速度基本1s内)\n\n详情见文末\n:::\n\n### picgo-安装\n\n[https://github.com/Molunerfinn/PicGo/releases](https://github.com/Molunerfinn/PicGo/releases)\n\n直接在官网下载对应系统的安装程序即可，安装之后打开\n\n因为gitee不在默认支持的图床里面，所以需要进行插件的下载，直接点击插件设置，搜索gitee,然后安装即可（需要nodejs环境，安装很简单）\n\n安装完成之后，需要在图床设置进行相关配置\n\n这里解释一下几个配置\n\n- owner：你的gitee的名称\n- repo：你用来存放图片的仓库名称（需要公开状态为public，并初始化master分支）\n- path：仓库下存放图片的目录，可不填\n- token：需要在gitee的头像hover->设置->私人令牌->生成新令牌进行生成，然后粘贴过来。\n- message：commit提交的信息，默认是测试\n\n全部配置完后，设为默认图床，他会自动上传个测试图片上去，没问题的话可以进入到typora环节\n\n### typora-配置\n\n在typora中，偏好设置->图像，设置上传服务为picgo\n\n之后只要你在typora编写博客时，只需要在插入图片后右键就会出现上传图片选项，点击之后直接上传到图床并修改图片url为图床中的url，十分便捷。\n\n至此，个人图床便搭建完成。\n\n\n### github+jsdelivr\n\n:::tip\n强烈推荐，Gitee 在大图片文件可能外链会被 403。\n:::\n\n1. 首先新建一个github repo,主分支为master,被main分支卡了一天(默认是找repo@master 如果是main得在自定义域名那加上@main)\n\n2. github生成 person access token\n\n3. picgo配置\n\n   ![image-20201029161923078](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201029161923078.png)\n\n","\n## 什么是数据结构\n\n数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。\n\n常见的数据结构有\n\n- 数组（Array）\n- 链表（Linked list）\n- 散列表（Hash）\n- 队列（Queue）\n- 树（Tree）\n- 栈（Stack）\n- 堆（Heap）\n- 图（Graph）\n\n## 数据的逻辑结构\n\n指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指数据元素之间的前后间关系，而与他们在计算机中的存储位置无关。逻辑结构包括：\n\n- 集合（数据结构中的元素之间除了“同属一个集合” 的相互关系外，别无其他关系）\n- 线性结构（数据结构中的元素存在一对一的相互关系）\n- 树形结构（数据结构中的元素存在一对多的相互关系）\n- 图形结构（数据结构中的元素存在多对多的相互关系）\n\n## 数据结构分类\n\n数据结构有很多种，一般来说，按照数据的逻辑结构对其进行简单的分类，包括**线性结构**和**非线性结构**两类。\n\n### 线性结构\n\n线性结构就是表中各个结点具有线性关系。如果从数据结构的语言来描述，线性结构应该包括如下几点：\n\n1. 线性结构是非空集。\n2. 线性结构有且仅有一个开始结点和一个终端结点。\n3. 线性结构所有结点都最多只有一个直接前趋结点和一个直接后继结点。\n\n线性表就是典型的线性结构，还有栈、队列和串等都属于线性结构。\n\n### 非线性结构\n\n非线性结构就是表中各个结点之间具有多个对应关系。如果从数据结构的语言来描述，非线性结构应该包括如下几点：\n\n1. 非线性结构是非空集。\n2. 非线性结构的一个结点可能有多个直接前趋结点和多个直接后继结点。\n\n在实际应用中，数组、广义表、树结构和图结构等数据结构都属于非线性结构。\n\n## 数组\n\n数组是一种聚合数据类型，它是将具有相同类型的若干变量有序地组织在一起的集合。数组可以说是最基本的数据结构，在各种编程语言中都有对应。一个数组可以分解为多个数组元素，按照数据元素的类型，数组可以分为整型数组、字符型数组、浮点型数组、指针数组和结构数组等。数组还可以有一维、二维以及多维等表现形式。\n\n\n## 链表\n\n链表是一种数据元素按照链式存储结构进行存储的数据结构，这种存储结构具有在物理上存在非连续的特点。链表由一系列数据结点构成，每个数据结点包括数据域和指针域两部分。其中，指针域保存了数据结构中下一个元素存放的地址。链表结构中数据元素的逻辑顺序是通过链表中的指针链接次序来实现的。\n\n\n### 跳表（skiplist）\n\n增加了向前指针的链表叫作跳表。跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，实质就是一种可以进行**二分查找**的有序链表。跳表在原有的有序链表上面增加了**多级索引**，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。\n\n\n## 散列表\n\n散列表源自于散列函数(Hash function)，其思想是如果在结构中存在关键字和T相等的记录，那么必定在F(T)的存储位置可以找到该记录，这样就可以不用进行比较操作而直接取得所查记录。\n\n\n## 队列\n\n队列和栈类似，也是一种特殊的**线性表**。和栈不同的是，队列只允许在表的一端进行插入操作，而在另一端进行删除操作。一般来说，进行插入操作的一端称为队尾，进行删除操作的一端称为队头。队列中没有元素时，称为空队列。\n\n\n## 树\n\n树是典型的**非线性结构**，它是包括，2个结点的有穷集合K。在树结构中，**有且仅有一个根结点**，该结点没有前驱结点。在树结构中的**其他结点**都**有且仅有一个前驱结点**，而且**可以有两个后继结点**，m≥0。\n\n\n## 栈\n\n栈是一种特殊的**线性表**，它只能在一个表的一个固定端进行数据结点的插入和删除操作。栈按照**后进先出**的原则来存储数据，也就是说，先插入的数据将被压入栈底，最后插入的数据在栈顶，读出数据时，从栈顶开始逐个读出。栈在汇编语言程序中，经常用于重要数据的现场保护。栈中没有数据时，称为空栈。\n\n\n## 堆\n\n堆是一种特殊的**树形数据结构**，一般讨论的堆都是**二叉堆**。堆的特点是**根结点**的值是所有结点中**最小**的**或**者**最大**的，并且根结点的两个子树也是一个堆结构。\n\n堆通常可以被看做一棵树的数组对象。\n堆的具体实现-般不通过指针域，而是通过构建一个一维数组与二叉树的父子结点进行对应,\n因此堆总是一颗完全二叉树。\n\n\n## 图\n\n图是另一种**非线性数据结构**。在图结构中，数据结点一般称为**顶点**，而**边**是**顶点**的**有序偶对**。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。\n\n\n## 结语\n\n至此，对于数据结构的基本概念你可能已经有了一定的理解\n\n更多数据结构的具体应用以及实现原理，可以找更加权威的资料进行详细学习。\n","\r\n## 简介\r\n\r\n算法（Algorithm）是指解题方案的准确而完整的描述，是**一系列解决问题的清晰指令**，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用**空间复杂度**与**时间复杂度**来衡量。\r\n\r\n## 特征\r\n\r\n一个算法应该具有以下五个重要的特征：\r\n\r\n### 有穷性（Finiteness）\r\n\r\n算法的有穷性是指算法必须能在执行有限个步骤之后终止\r\n\r\n### 确切性（Definiteness）\r\n\r\n算法的每一步骤必须有确切的定义\r\n\r\n### 输入项（input）\r\n\r\n一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件\r\n\r\n### 输出项（output）\r\n\r\n一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的\r\n\r\n### 可行性（Effectiveness）\r\n\r\n算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）\r\n\r\n## 分类\r\n\r\n算法可大致分为基本算法、数据结构的算法、数论与代数算法、计算几何的算法、图论的算法、动态规划以及数值分析、加密算法、排序算法、检索算法、随机化算法、并行算法，厄米变形模型，随机森林算法。\r\n\r\n算法可以宏泛的分为三类：\r\n\r\n一、有限的，确定性算法 这类算法在有限的一段时间内终止。他们可能要花很长时间来执行指定的任务，但仍将在一定的时间内终止。这类算法得出的结果常取决于输入值。\r\n\r\n二、有限的，非确定算法 这类算法在有限的时间内终止。然而，对于一个（或一些）给定的数值，算法的结果并不是唯一的或确定的。\r\n\r\n三、无限的算法 是那些由于没有定义终止定义条件，或定义的条件无法由输入的数据满足而不终止运行的算法。通常，无限算法的产生是由于未能确定的定义终止条件。\r\n\r\n## 方法\r\n\r\n### 递推法\r\n\r\n递推是序列计算机中的一种常用算法。它是按照一定的规律来计算序列中的每个项，通常是通过计算机前面的一些项来得出序列中的指定项的值。其思想是把一个复杂的庞大的计算过程转化为简单过程的多次重复，该算法利用了计算机速度快和不知疲倦的机器特点。\r\n\r\n### 递归法\r\n\r\n程序调用自身的编程技巧称为递归（recursion）。一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。\r\n\r\n**注意：**\r\n\r\n(1) 递归就是在过程或函数里调用自身;\r\n\r\n(2) 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。\r\n\r\n### 穷举法\r\n\r\n穷举法，或称为暴力破解法，其基本思路是：对于要解决的问题，列举出它的所有可能的情况，逐个判断有哪些是符合问题所要求的条件，从而得到问题的解。它也常用于对于密码的破译，即将密码进行逐个推算直到找出真正的密码为止。例如一个已知是四位并且全部由数字组成的密码，其可能共有10000种组合，因此最多尝试10000次就能找到正确的密码。理论上利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。因此有些人运用计算机来增加效率，有些人辅以字典来缩小密码组合的范围。\r\n\r\n### 贪心算法\r\n\r\n贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。\r\n\r\n用贪心法设计算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，它省去了为找最优解要穷尽所有可能而必须耗费的大量时间，它采用自顶向下,以迭代的方法做出相继的贪心选择,每做一次贪心选择就将所求问题简化为一个规模更小的子问题, 通过每一步贪心选择,可得到问题的一个最优解，虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪婪法不要回溯。\r\n\r\n贪婪算法是一种改进了的分级处理方法，其核心是根据题意选取一种量度标准，然后将这多个输入排成这种量度标准所要求的顺序，按这种顺序一次输入一个量，如果这个输入和当前已构成在这种量度意义下的部分最佳解加在一起不能产生一个可行解，则不把此输入加到这部分解中。这种能够得到某种量度意义下最优解的分级处理方法称为贪婪算法。\r\n\r\n对于一个给定的问题，往往可能有好几种量度标准。初看起来，这些量度标准似乎都是可取的，但实际上，用其中的大多数量度标准作贪婪处理所得到该量度意义下的最优解并不是问题的最优解，而是次优解。因此，选择能产生问题最优解的最优量度标准是使用贪婪算法的核心。\r\n\r\n一般情况下，要选出最优量度标准并不是一件容易的事，但对某问题能选择出最优量度标准后，用贪婪算法求解则特别有效。\r\n\r\n### 分治法\r\n\r\n分治法是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。\r\n\r\n分治法所能解决的问题一般具有以下几个特征：\r\n\r\n(1) 该问题的规模缩小到一定的程度就可以容易地解决；\r\n\r\n(2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；\r\n\r\n(3) 利用该问题分解出的子问题的解可以合并为该问题的解；\r\n\r\n(4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。\r\n\r\n### 动态规划法\r\n\r\n动态规划是一种在数学和计算机科学中使用的，用于求解包含重叠子问题的最优化问题的方法。其基本思想是，将原问题分解为相似的子问题，在求解的过程中通过子问题的解求出原问题的解。动态规划的思想是多种算法的基础，被广泛应用于计算机科学和工程领域。\r\n\r\n动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。不象前面所述的那些搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。动态规划程序设计往往是针对一种最优化问题，由于各种问题的性质不同，确定最优解的条件也互不相同，因而动态规划的设计方法对不同的问题，有各具特色的解题方法，而不存在一种万能的动态规划算法，可以解决各类最优化问题。因此读者在学习时，除了要对基本概念和方法正确理解外，必须具体问题具体分析处理，以丰富的想象力去建立模型，用创造性的技巧去求解。\r\n\r\n### 迭代法\r\n\r\n迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，跟迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题。迭代法又分为精确迭代和近似迭代。“二分法”和“牛顿迭代法”属于近似迭代法。迭代算法是用计算机解决问题的一种基本方法。它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。\r\n\r\n### 分支界限法\r\n\r\n分枝界限法是一个用途十分广泛的算法，运用这种算法的技巧性很强，不同类型的问题解法也各不相同。\r\n\r\n分支定界法的基本思想是对有约束条件的最优化问题的所有可行解（数目有限）空间进行搜索。该算法在具体执行时，把全部可行的解空间不断分割为越来越小的子集（称为分支），并为每个子集内的解的值计算一个下界或上界（称为定界）。在每次分支后，对凡是界限超出已知可行解值那些子集不再做进一步分支，这样，解的许多子集（即搜索树上的许多结点）就可以不予考虑了，从而缩小了搜索范围。这一过程一直进行到找出可行解为止，该可行解的值不大于任何子集的界限。因此这种算法一般可以求得最优解。\r\n\r\n与贪心算法一样，这种方法也是用来为组合优化问题设计求解算法的，所不同的是它在问题的整个可能解空间搜索，所设计出来的算法虽其时间复杂度比贪婪算法高，但它的优点是与穷举法类似，都能保证求出问题的最佳解，而且这种方法不是盲目的穷举搜索，而是在搜索过程中通过限界，可以中途停止对某些不可能得到最优解的子空间进一步搜索（类似于人工智能中的剪枝），故它比穷举法效率更高。\r\n\r\n### 回溯法\r\n\r\n回溯法（探索与回溯法）是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。\r\n\r\n其基本思想是，在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。\r\n\r\n## 结语\r\n\r\ncv结束，算法太难了。","\n## 前言\n\n突然闲的没事,从Mojave升级到Catalina,顺达记录一下.\n\n这里提示一下,黑苹果正常是需要硬件支持的,其次是efi(会自己改当没说),不过基本上都是需要iu,而且独显一般驱动不了,wifi 蓝牙也可能驱动不了,但是随便折腾一下,也勉强能用,折腾吧,前浪.\n\n以前记录双系统安装记录.仅供参考.\n\n## 准备\n\n- ~~8~~16g+U盘(catalina部分镜像8g不够,建议16g)\n- 镜像(推荐[黑果小兵](https://blog.daliansky.net/)下载,直接搜索版本号)\n- EFI支持镜像\n  - 这里说明一下,一般别人维护的efi文件,都有注明支持的镜像版本\n  - 至于efi支持以及对应的镜像版本,可以看看这个[repo](https://github.com/daliansky/Hackintosh)\n\n以下内容以小米air为例,其他自行变通.\n\n## 什么是EFI\n\n其实我也不知道,暂且理解成一个启动程序及一些配置文件,作用是引导系统分区.\n\n这里通过刚才那个repo,我进入到了具体的[efi仓库](https://github.com/jasper-wan/Xiaomi-Air-i5-7200U)\n\n这个仓库,可以看到,这个efi支持的镜像,支持的硬件,不管,先down下来.\n\n记得之后有效的是boot和clover这两个文件夹,到时要用\n\n## 具体步骤\n\n1. 在确定了镜像,efi并下载完成之后,下载一个[etcher](https://www.balena.io/etcher/)\n2. 利用etcher将镜像刷U盘\n3. 利用[DiskGenius](http://download.eassos.cn/DG5301066_x64.zip)工具,将U盘中的efi分区的文件替换成上面自己下载的efi文件,也就是之前提到的boot和clover两个文件夹.\n4. 空出一个分区,用于安装MacOS,利用windows的磁盘管理工具\n​\t具体操作不会的百度,建议是不低于60g的大小(这个应该都会)\n\n\n​对了,没记错的话,还需要将本地esp/efi分区扩展到200-300MB,上图可以看到我已经扩展到了299,这里再简单说一下使用dg进行esp扩容,不适用可以自行百度\n\n此时发现已经可以扩大了.\n\n建议是200+,但是最好**稍微**多点,所以我扩容到了299(自行抉择)\n\n5. 之后,你就可以插上U盘,进入bios(记得把Secure Boot Mode设置为false,每个机型bios不同,所以自行百度)设置U盘为启动首选项,不出意外可以看到clover菜单,有个选项是install MacOS,选他Enter.\n\n先选择磁盘工具,左上角显示所有设备\n\n\n找到你空出来的分区,将其抹掉.\n\n\n好了之后退出,进行macos的安装\n\n\n无脑过\n\n这里选择的是刚格式化好的分区.\n\n至此,第一阶段的安装就结束了,\n\n即将进入第二阶段的安装,我的情况是重启进入clover,此时多了个选项,除了install macos外还多出了个boot macos,选这个,然后又是漫长的等待,可能会重启数次,等就行了.\n\n最后,如果你看到设置向导就基本没问题了.\n\n\n到这个之后基本没问题了,过完之后,你就可以看到桌面了\n\n7. 最后,就是把U盘的esp中的clover引导复制到本地esp/efi(不会有人天天插着U盘引导吧)\n\n这个就是从u盘的efi中复制出来的clover,然后放到本地的example(U盘拔了,所以只有1张图)\n\n然后下载[bootice](https://bootice.en.softonic.com/),有的人喜欢用easy uefi也可以\n\n还记得刚才有个bios修改U盘为首选启动项的操作嘛,使用这个软件,可以直接修改\n\n此时我们要做的就是利用该软件挂载本地esp/efi分区,添加启动项,并设置为首选启动项.\n\n进行挂载\n\n然后进入uefi修改启动序列\n\n点击添加,弹出资源管理器,选择刚才挂载的本地esp分区,也就是e盘,中的clover下的.efi文件\n\n之后就会多出一个启动项,将其移动到顶部\n\n单击保存当前启动项设置,\n\n到分区管理删除盘符\n\n拔掉U盘\n\n正常引导\n\n结束!\n\n## 最后\n\n更多细节问题(深坑),可以去[黑果小兵](https://blog.daliansky.net/)博客逛逛.over.\n","\r\n\r\n## 源码\r\n昨天看到个非常花里胡哨的按钮效果，记录一下\r\n\r\n``` html\r\n\u003C!DOCTYPE html>\r\n\u003Chtml lang=\"en\">\r\n\r\n\u003Chead>\r\n    \u003Cmeta charset=\"UTF-8\">\r\n    \u003Cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    \u003Ctitle>Document\u003C/title>\r\n    \u003Cstyle>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n            box-sizing: border-box;\r\n        }\r\n\r\n        body {\r\n            width: 100vw;\r\n            height: 100vh;\r\n            display: flex;\r\n            justify-content: center;\r\n            align-items: center;\r\n            background-color: #222;\r\n        }\r\n\r\n        a {\r\n            text-transform: uppercase;\r\n            width: 400px;\r\n            height: 100px;\r\n            text-decoration: none;\r\n            font-size: 24px;\r\n            color: white;\r\n            text-align: center;\r\n            line-height: 100px;\r\n            position: relative;\r\n            border-radius: 50px;\r\n            background-image: linear-gradient(to right, #77A1D3, #79CBCA, #E684AE, #77A1D3);\r\n            background-size: 400%;\r\n            z-index: 1;\r\n        }\r\n\r\n        a:hover {\r\n            animation: streamer 4s infinite linear;\r\n        }\r\n\r\n        a::before {\r\n            content: '';\r\n            position: absolute;\r\n            top: -5px;\r\n            bottom: -5px;\r\n            left: -5px;\r\n            right: -5px;\r\n            border-radius: 50px;\r\n            /** half of height, the same as button */\r\n            background-image: linear-gradient(to right, #77A1D3, #79CBCA, #E684AE, #77A1D3);\r\n            background-size: 400%;\r\n            z-index: -1;\r\n            filter: blur(20px);\r\n        }\r\n\r\n        a:hover::before {\r\n            animation: streamer 4s infinite linear;\r\n        }\r\n\r\n        @keyframes streamer {\r\n            100% {\r\n                background-position: -400% 0;\r\n            }\r\n        }\r\n    \u003C/style>\r\n\u003C/head>\r\n\r\n\u003Cbody>\r\n    \u003Ca href=\"#\">button\u003C/a>\r\n\u003C/body>\r\n\r\n\u003C/html>\r\n```\r\n效果如下\r\n\r\n![](https://cdn.jsdelivr.net/gh/alightyoung/static/img/streamer.gif)\r\n\r\n\r\n","\r\n## 源码\r\n\r\n``` html\r\n\u003C!DOCTYPE html>\r\n\u003Chtml lang=\"en\">\r\n\u003Chead>\r\n    \u003Cmeta charset=\"UTF-8\">\r\n    \u003Cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    \u003Ctitle>Document\u003C/title>\r\n    \u003Cstyle>\r\n        *{\r\n            margin: 0;\r\n            padding: 0;\r\n        }\r\n        body{\r\n            height: 100vh;\r\n            display: flex;\r\n            justify-content: center;\r\n            align-items: center;\r\n            background-color: #222;\r\n        }\r\n        h1{\r\n            position: relative;\r\n            text-transform: uppercase;\r\n            color: #333;\r\n            font-size: 4rem;\r\n        }\r\n        h1::after{\r\n            position: absolute;\r\n            content: 'spotlight';\r\n            left: 0;\r\n            top:0;\r\n            color: transparent;\r\n            background-image:linear-gradient(to right,#E64845,#E68545,#E6CB45,#A5E645,#45E668,#45ABE6,#C845E6) ;\r\n            /* background-clip: text; */\r\n            -webkit-background-clip: text; /* works on chrome */\r\n            clip-path: circle(2rem at 0% 50%);\r\n            animation: move 5s infinite cubic-bezier(.58,.13,.4,.87);\r\n        }\r\n\r\n        @keyframes move{\r\n            0%{\r\n                clip-path: circle(2rem at 0% 50%);\r\n            }\r\n            50%{\r\n                clip-path: circle(2rem at 100% 50%);\r\n            }\r\n            100%{\r\n                clip-path: circle(2rem at 0% 50%);\r\n            }\r\n        }\r\n    \u003C/style>\r\n\u003C/head>\r\n\u003Cbody>\r\n    \u003Ch1>spotlight\u003C/h1>\r\n\u003C/body>\r\n\u003C/html>\r\n```\r\n\r\n![spotlight](https://cdn.jsdelivr.net/gh/alightyoung/static/img/spotlight.gif)","\n#### vscode\n\n软件的下载安装不多说 放个链接 [https://code.visualstudio.com/docs/?dv=win](https://code.visualstudio.com/docs/?dv=win)\n\n下载之后安装`c/c++`以及`code runner`插件\n\n#### mingw64\n\n:::tip\n测试环境下载的是8.1的`x86_64-posix-seh`版本\n:::\n\n![image-20201107112410016](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201107112410016.png)\n\n链接 [https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/](https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/)\n\n下完放到你觉得合适的地方,然后配置好环境变量(右键此电脑->属性->高级系统设置->环境变量->系统环境变量中的Path->编辑->新增->`${你电脑上mingw的目录}/bin`)\n\n配完后在cmd输入`gcc -v`测试一下\n\n如果你不想体验clang的话,此刻便可以打开vscode,写一个c程序进行测试了(前提是装好了插件)\n\n![image-20201107114407473](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201107114407473.png)\n\n![image-20201107114318486](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201107114318486.png)\n\n#### clang\n\n地址 [https://releases.llvm.org/download.html](https://releases.llvm.org/download.html)\n\n![image-20201107114545259](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201107114545259.png)\n\n安装的时候记得加上环境变量(省的自己再配置)\n\n![image-20201107114857037](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201107114857037.png)\n\n安装好了同样可以打开cmd 执行`clang -v`测试以下\n\n好了之后需要修改以下vscode的code runner插件c语言运行配置\n\n直接打开json配置文件\n\n![image-20201107131845814](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201107131845814.png)\n\n```json\n// 方便复制贴一下\n\"c\": \"cd $dir && clang $fileName -o $fileNameWithoutExt --target=x86_64-pc-windows-gnu && $dir$fileNameWithoutExt\",\n```\n\n复制原来的一份,红框部分是修改之后的运行命令\n\n之后再运行一下`test.c`文件\n\n![image-20201107132105517](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201107132105517.png)\n\n完事了!\n\n#### 官方文档\n\n如果你需要debug等其他功能的话 ,可以参考一下官方的文档\n\n[https://code.visualstudio.com/docs/cpp/config-mingw](https://code.visualstudio.com/docs/cpp/config-mingw)\n","\r\n> 建议采取hls分片（或者其他视频播放方案），体验会好很多。\r\n\r\n#### 源起\r\n\r\n突然想写一个视频站玩玩，正好也能挂pc给局域网设备观看（正经人谁用手机存一堆电影啊），所以开始了踩坑之旅。\r\n\r\n贴张最后的效果图\r\n\r\n![image-20201122145047889](https://cdn.jsdelivr.net/gh/alightyoung/static/img/image-20201122145047889.png)\r\n\r\n勉强能看 - -（适配是不可能的，这辈子都不可能）\r\n\r\n#### 技术\r\n\r\n虽说是朴实无华的页面，但是对于一个前端渣来说还是写了挺久（菜哭）\r\n\r\n技术其实没啥，主要是videojs的基本使用，页面怎么高兴怎么写\r\n\r\n视频列表文件获取是node（express）写的一个接口（写个小接口真方便- -）\r\n\r\n最后为了方便静态资源也是放在了express下\r\n\r\n觉得性能差的也可以用nginx之类也行（反正我放了- -）\r\n\r\n#### 源码\r\n\r\n有兴趣的可以自己拉代码\r\n\r\n[https://gitee.com/AlightYoung/video-player](https://gitee.com/AlightYoung/video-player)\r\n\r\nreadme已经写的很详细\r\n\r\n#### 最后\r\n\r\n又是不务正业的一天- -","\r\n#### 介绍 \r\n\r\nJDK是一个复杂的软件项目。 构建它需要一定的技术，**相当数量的对外部软件的依赖关系**以及**相当强大的硬件**。 如果您只是想使用JDK而不是自己构建它，那么本文不适合您。 有关安装预构建好不同平台的JDK的一些方法，请参见例如[OpenJDK安装](http://openjdk.java.net/install)。 \r\n\r\n#### 流程预览\r\n\r\n1. 获取源代码\r\n\r\n   ```bash\r\n   git clone https://git.openjdk.java.net/jdk/\r\n   ```\r\n\r\n2. 进行配置检查\r\n\r\n   ```bash\r\n   bash configure\r\n   ```\r\n\r\n   如果由于缺少相关性（对工具链，构建工具，外部库或引导JDK）而导致配置失败，则大多数情况下它会提出有关如何解决平台问题的建议。 按照说明进行操作，然后尝试再次运行bash configure。 \r\n\r\n3. 进行编译\r\n\r\n   ```bash\r\n   make images\r\n   ```\r\n\r\n4. 验证新构建的JDK\r\n\r\n   ```bash\r\n   ./build/*/images/jdk/bin/java -version\r\n   ```\r\n\r\n5. 运行基本测试\r\n\r\n   ```bash\r\n   make run-test-tier1\r\n   ```\r\n\r\n>看起来虽然并不复杂，但是实际上只看这个的话会有很多错误\r\n\r\n#### 获取源代码 \r\n\r\n此次编译的版本是[jdk16u repo](https://github.com/openjdk/jdk16u)\r\n\r\n```bash\r\ngit clone https://github.com/openjdk/jdk16u.git\r\n```\r\n\r\n**一些建议**\r\n\r\n-  使用Linux可以避免很多问题（测试环境Ubuntu 20.04）\r\n-  **不要**让路径包含中文，空格符，或者目录很深，以免带来不必要的麻烦\r\n- **建议**在SSD上进行编译\r\n- **建议**8核CPU及8G以上内存\r\n\r\n#### Boot JDK\r\n\r\n构建JDK需要一个预先存在的JDK。 这称为“启动JDK”。\r\n\r\n经验法则是，推荐Boot JDK的版本为N-1,\r\n\r\n所以这里下载OpenJDK 15作为Boot JDK\r\n\r\n```bash\r\nsudo apt-get install openjdk-15-jdk\r\n```\r\n\r\n#### 外部库\r\n\r\n缺少一些外部库会在配置时直接出错，这里按照文档建议下载了这些库\r\n\r\n**FreeType**\r\n\r\n```bash\r\nsudo apt-get install libfreetype6-dev\r\n```\r\n\r\n如果配置时出错考虑主动指定参数  `--with-freetype-include=\u003Cpath>` & `--with-freetype-lib=\u003Cpath>` \r\n\r\n**CUPS**\r\n\r\n```bash\r\nsudo apt-get install libcups2-dev\r\n```\r\n\r\n如果配置时出错考虑主动指定参数  `--with-cups=\u003Cpath>` \r\n\r\n**X11**\r\n\r\n```bash\r\nsudo apt-get install libx11-dev libxext-dev libxrender-dev libxrandr-dev libxtst-dev libxt-dev\r\n```\r\n\r\n如果配置时出错考虑主动指定参数  `--with-x=\u003Cpath>`\r\n\r\n**ALSA**\r\n\r\n```bash\r\nsudo apt-get install libasound2-dev\r\n```\r\n\r\n如果配置时出错考虑主动指定参数  `--with-alsa=\u003Cpath>`\r\n\r\n**libffi**\r\n\r\n```bash\r\nsudo apt-get install libffi-dev\r\n```\r\n\r\n如果配置时出错考虑主动指定参数  `--with-libffi=\u003Cpath>`\r\n\r\n#### 构建工具\r\n\r\n同样的，还会依赖下面这些构建工具，所以继续下载\r\n\r\n**Autoconf**\r\n\r\n```bash\r\nsudo apt-get install autoconf\r\n```\r\n\r\n配置出错时考虑 `AUTOCONF=\u003Cpath to autoconf> configure ...`\r\n\r\n**GNU Make**\r\n\r\n至少需要3.81版本以后的GNU Make\r\n\r\n强烈推荐4.0以上\r\n\r\n通过`make --version`即可查看，显示默认就是4.2.1，所以不用进行操作。\r\n\r\n```bash\r\nGNU Make 4.2.1\r\n为 x86_64-pc-linux-gnu 编译\r\nCopyright (C) 1988-2016 Free Software Foundation, Inc.\r\n许可证：GPLv3+：GNU 通用公共许可证第 3 版或更新版本\u003Chttp://gnu.org/licenses/gpl.html>。\r\n本软件是自由软件：您可以自由修改和重新发布它。\r\n在法律允许的范围内没有其他保证。\r\n```\r\n\r\n**GNU Bash**\r\n\r\n必须使用GNU Bash，且版本至少3.2\r\n\r\n同样的，通过`bash --version`查看，发现是5.0.17，所以继续跳过。\r\n\r\n```bash\r\nGNU bash，版本 5.0.17(1)-release (x86_64-pc-linux-gnu)\r\nCopyright (C) 2019 Free Software Foundation, Inc.\r\n许可证 GPLv3+: GNU GPL 许可证第三版或者更新版本 \u003Chttp://gnu.org/licenses/gpl.html>\r\n\r\n本软件是自由软件，您可以自由地更改和重新发布。\r\n在法律许可的情况下特此明示，本软件不提供任何担保。\r\n```\r\n\r\n#### 进行配置\r\n\r\n这里的配置指定了参数，表示编译64位的JDK，并指定了启动JDK的目录（没指定之前出现了错误...）\r\n\r\n```bash\r\nsudo bash configure --with-target-bits=64 --with-boot-jdk=/usr/local/jdk-15.0.2/\r\n```\r\n\r\n编译过程中碰到亿个错误，但是基本可以根据提示进行解决，不行就百度。\r\n\r\n比如没有fontconfig，百度后使用了apt进行安装，之后就成功了。\r\n\r\n```bash\r\nsudo apt-get install libfontconfig1-dev\r\n```\r\n\r\n问题解决后看到\r\n\r\n```bash\r\n====================================================\r\nA new configuration has been successfully created in\r\n/home/alightyoung/Desktop/jdk16u/build/linux-x86_64-server-release\r\nusing configure arguments '--with-target-bits=64 --with-boot-jdk=/usr/local/jdk-15.0.2/'.\r\n\r\nConfiguration summary:\r\n* Name:           linux-x86_64-server-release\r\n* Debug level:    release\r\n* HS debug level: product\r\n* JVM variants:   server\r\n* JVM features:   server: 'aot cds compiler1 compiler2 epsilongc g1gc graal jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs zgc' \r\n* OpenJDK target: OS: linux, CPU architecture: x86, address length: 64\r\n* Version string: 16-internal+0-adhoc.root.jdk16u (16-internal)\r\n\r\nTools summary:\r\n* Boot JDK:       openjdk version \"15.0.2\" 2021-01-19 OpenJDK Runtime Environment (build 15.0.2+7-27) OpenJDK 64-Bit Server VM (build 15.0.2+7-27, mixed mode, sharing) (at /usr/local/jdk-15.0.2)\r\n* Toolchain:      gcc (GNU Compiler Collection)\r\n* C Compiler:     Version 9.3.0 (at /usr/bin/gcc)\r\n* C++ Compiler:   Version 9.3.0 (at /usr/bin/g++)\r\n\r\nBuild performance summary:\r\n* Cores to use:   15\r\n* Memory limit:   15440 MB\r\n```\r\n\r\nOK！配置至此结束，需要不同版本的JDK可以看看配置参数进行修改，配置参数在官方文档介绍的十分详细，[官方文档](https://openjdk.java.net/groups/build/doc/building.html)\r\n\r\n#### 进行编译\r\n\r\n配置正确之后，就可以进行编译了。\r\n\r\n当使用`make`不加任何参数时，等同于`make default`或者`make jdk`，这将会构建一个尽量最小的镜像。编译后的镜像会放在`build`目录下\r\n\r\n这里我们就按默认进行编译即可\r\n\r\n```bash\r\nmake\r\n```\r\n\r\n然后就可以去喝杯Java了 - -\r\n\r\n```bash\r\nFinished building target 'default (exploded-image)' in configuration 'linux-x86_64-server-release'\r\n```\r\n\r\n可以看到编译完成了，使用以下命令检查一下\r\n\r\n```bash\r\nbuild/linux-x86_64-server-release/jdk/bin/java --version\r\n```\r\n\r\n发现可以正常使用，至此编译结束\r\n\r\n```bash\r\nopenjdk 16-internal 2021-03-16\r\nOpenJDK Runtime Environment (build 16-internal+0-adhoc.root.jdk16u)\r\nOpenJDK 64-Bit Server VM (build 16-internal+0-adhoc.root.jdk16u, mixed mode)\r\n```\r\n\r\n之后可以新建一个Test.java文件测试一下\r\n\r\n```java\r\npublic class Test{\r\n    public static void main(String[]args){\r\n        system.out.println(\"Hello World!\");\r\n    }\r\n}\r\n```\r\n\r\n然后进入到编译之后的JDK的目录调用`sudo ./javac Test.java`和`sudo ./java Test`\r\n测试一下，能输出就没啥问题了\r\n> 使用`./`是为了防止使用系统环境变量的JDK\r\n\r\n```bash\r\nHello World!\r\n```\r\n\r\n#### 最后\r\n\r\nJDK的构建至此便告一段落。说一下为什么突然想编译JDK，其实是前些天略读了一遍深入理解Java虚拟机，作者建议可以尝试一下，正好也觉得挺有趣的，所以就编译了一次。因为书是第二版（二手），JDK版本比较老，所以整个过程都是跟着官方文档走的，也百度了很多配置时出现的错误，强烈推荐大家看官方文档，虽然是英文，但是确实非常详细，包括后面还有交叉编译，测试JDK的环节等，因个人才疏学浅，所以也没有再进一步进行，感兴趣的直接去[OpenJDK](https://openjdk.java.net/)官方网站查看即可。最后提醒一下，这个JDK 16已经是GA了，就在本文发布的前几天 - -","\n### 序言\n\nMyBatis-Plus（简称 MP）是一个MyBatis的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。\n\n### 环境\n\n假设您已经\n\n- 拥有 Java 开发环境以及IDEA\n- 熟悉 Spring Boot\n- 熟悉 Maven\n- 熟悉MySQL\n\n\n\n直接在idea使用spring initializr初始化一个springboot项目+mysql驱动+[lombok](https://projectlombok.org/)（简化实体类），同时idea也得装lombok插件\n\n构建一个简单的数据库和一个简单的表并插入几条数据\n\n```sql\nCREATE DATABASE db_test;\nUSE db_test;\nCREATE TABLE t_test ( `id` BIGINT NOT NULL PRIMARY KEY, `name` VARCHAR ( 24 ) );\nINSERT INTO t_test VALUES( 1, \"张三\" );\nINSERT INTO t_test VALUES( 2, \"李四\" );\nINSERT INTO t_test VALUES( 3, \"王五\" );\n```\n\n导入mybatis plus依赖\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>com.baomidou\u003C/groupId>\n    \u003CartifactId>mybatis-plus-boot-starter\u003C/artifactId>\n    \u003Cversion>3.4.2\u003C/version>\n\u003C/dependency>\n```\n\n在application.yml配置数据库信息（默认是properties格式，改成yml即可）\n\n```yaml\nserver:\n  port: 8080\n\nspring:\n  datasource:\n    driver-class-name: com.mysql.cj.jdbc.Driver\n    url: jdbc:mysql://localhost:3306/db_test?serverTimezone=UTC\n    username: root\n    password: 123456\n```\n\n在application.yml启动 mybatis 本身的 log 日志\n\n```yaml\n# 方式一\nmybatis-plus:\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n# 方式二 application.yml 中增加配置，指定 mapper 文件所在的包\nlogging:\n  level:\n    com.baomidou.example.mapper: debug\n```\n\nspringboot启动类添加注解\n\n```java\n@MapperScan(\"com.baomidou.mybatisplus.samples.quickstart.mapper\")\n```\n\n一般我们自己还会写mapper，所以还得加上自己mapper包名\n\n```java\n@MapperScan({\"com.baomidou.mybatisplus.samples.quickstart.mapper\",\"xyz.ayay.mpdemo.mapper\"})\n```\n\n新建entity包和mapper包\n\n例：`xyz.ayay.mpdemo.entity`\n\n编写entity类及mapper类\n\n```java\n@Data\npublic class TTest {\n    private Long id;\n    private String name;\n}\n```\n\n```java\n@Mapper\npublic interface TTestMapper extends BaseMapper\u003CTTest> {\n}\n```\n\n准备过程至此结束\n\n### 简单的CRUD\n\n上面过程准备好就可以在test目录下编写测试案例了\n\n首先注入mapper，因为之后的操作都得通过mapper来进行\n\n```java\n@Autowired\nprivate TTestMapper tTestMapper;\n```\n\n#### 查询\n\n```java\n@Test\npublic void testSelect() {\n    //通过id查询单个记录\n    TTest tTest1 = tTestMapper.selectById(1L); // TTest(id=1, name=张三)\n    // 查询记录数量\n    Integer count = tTestMapper.selectCount(null); // 3\n    // 批量查询 可加wrapper条件\n    List\u003CTTest> tTests = tTestMapper.selectList(null);\n    /*\n    TTest(id=1, name=张三)\n    TTest(id=2, name=李四)\n    TTest(id=3, name=王五)\n    */\n}\n```\n\n#### 新增\n\n```java\n@Test\npublic void testInsert() {\n    TTest testObj = new TTest();\n    testObj.setId(4L);\n    testObj.setName(\"赵六\");\n    tTestMapper.insert(testObj);\n}\n```\n\n没有出错的话刷新一下表，就能看到记录已经成功的被插入到表中了\n\n#### 修改\n\n```java\n@Test\npublic void testUpdate() {\n    TTest testObj = new TTest();\n    testObj.setId(4L);\n    testObj.setName(\"赵六update\");\n    tTestMapper.updateById(testObj);\n}\n```\n\n#### 删除\n\n```java\n@Test\npublic void testDelete() {\n\ttTestMapper.deleteById(4L);\n}\n```\n\n至此，最简单的crud到此结束，但是这种简单的增删改查在具体业务中用的很少，实际业务的逻辑要复杂的多。所以，**条件构造器**便应运而生。\n\n### 条件构造器\n\n条件构造器可以简单的理解为sql语句中你需要附加的条件。所以你不需要亲自编写sql语句也能完成一些复杂的sql查询。\n\n#### AbstractWrapper\n\nQueryWrapper和UpdateWrapper的父类，该类中定义了许多条件构造的方法\n\n一下列举一些常用的，更多请查看[官方文档-条件构造器](https://baomidou.com/guide/wrapper.html)\n\n##### eq\n\neq即equals，用于构建相等条件。\n\n下面通过一个案例来进行解释，之后的将不再详细介绍。\n\n```java\n@Test\npublic void testSelect() {\n    QueryWrapper queryWrapper = new QueryWrapper();\n    queryWrapper.eq(\"name\",\"张三\");\n    TTest tTest1 = tTestMapper.selectOne(queryWrapper);\n    // TTest(id=1, name=张三)\n}\n```\n\n可以看到，这里我们构建了一个name＝张三的条件，然后让mapper通过该条件成功查询到了我们需要的数据。\n\n实际上mapper中的很多方法都可以传入条件构造器，在idea中通过mapper.可以看到mapper中的所有方法，同时也可以看到每个方法需要的参数，并且每次方法都是见名知义的。\n\n最后贴上eq的不同重载\n\n```java\neq(R column, Object val)\neq(boolean condition, R column, Object val)\n```\n\n可以看到有一个加了condition的重载方法，在wrapper类中很多方法都有这个参数，该参数表示是否生效此条件。\n\n举个例子，你可以根据判断输入字符串是否为空来决定要不要构建该条件，写个伪代码\n\n```java\nname = fromUserInput();\nwrapper.eq(name.isNotEmpty(),\"name\",name)\n```\n\n通过这种设计，我们可以避免构建出一些糟糕的，并不需要的条件。\n\n#####  allEq\n\n表示全部eq(或个别isNull)\n\n```java\nallEq(Map\u003CR, V> params)\nallEq(Map\u003CR, V> params, boolean null2IsNull)\nallEq(boolean condition, Map\u003CR, V> params, boolean null2IsNull)\n```\n\n>`params` : `key`为数据库字段名,`value`为字段值\n>`null2IsNull` : 为`true`则在`map`的`value`为`null`时调用 [isNull](https://baomidou.com/guide/wrapper.html#isnull) 方法,为`false`时则忽略`value`为`null`的\n\n##### ne\n\n表示不等于 `\u003C>`\n\n```java\nne(R column, Object val)\nne(boolean condition, R column, Object val)\n```\n\n##### gt\n\n表示大于，即 >\n\n```java\ngt(R column, Object val)\ngt(boolean condition, R column, Object val)\n```\n\n例如：`gt(\"age\", 18)`--->`age > 18`\n\n##### ge\n\n表示大于等于\n\n```java\nge(R column, Object val)\nge(boolean condition, R column, Object val)\n```\n\n##### lt\n\n表示小于\n\n```java\nlt(R column, Object val)\nlt(boolean condition, R column, Object val)\n```\n\n##### le\n\n表示小于等于\n\n```java\nle(R column, Object val)\nle(boolean condition, R column, Object val)\n```\n\n##### between\n\n表示两者之间\n\n```java\nbetween(R column, Object val1, Object val2)\nbetween(boolean condition, R column, Object val1, Object val2)\n```\n\n##### in\n\n字段 IN (value.get(0), value.get(1), ...)\n\n```java\nin(R column, Collection\u003C?> value)\nin(boolean condition, R column, Collection\u003C?> value)\n\nin(R column, Object... values)\nin(boolean condition, R column, Object... values)\n```\n\n例: `in(\"age\",{1,2,3})`--->`age in (1,2,3)`\n\n例: `in(\"age\", 1, 2, 3)`--->`age in (1,2,3)`\n\n#####  like\n\n模糊查询\n\n```java\nlike(R column, Object val)\nlike(boolean condition, R column, Object val)\n```\n\n例: `like(\"name\", \"王\")`--->`name like '%王%'\n\n##### groupBy\n\n分组：GROUP BY 字段\n\n```java\ngroupBy(R... columns)\ngroupBy(boolean condition, R... columns)\n```\n\n##### orderByAsc & orderByDesc\n\n正 / 反排序\n\n```java\norderByAsc(R... columns)\norderByAsc(boolean condition, R... columns)\n\norderByDesc(R... columns)\norderByDesc(boolean condition, R... columns)\n```\n\n##### having\n\nHAVING ( sql语句 )\n\n```java\nhaving(String sqlHaving, Object... params)\nhaving(boolean condition, String sqlHaving, Object... params)\n```\n\n例: `having(\"sum(age) > 10\")`--->`having sum(age) > 10`\n\n例: `having(\"sum(age) > {0}\", 11)`--->`having sum(age) > 11`\n\n##### and\n\nAND 嵌套\n\n```java\nand(Consumer\u003CParam> consumer)\nand(boolean condition, Consumer\u003CParam> consumer)\n```\n\n例: `and(i -> i.eq(\"name\", \"李白\").ne(\"status\", \"活着\"))`--->`and (name = '李白' and status \u003C> '活着')`\n\n##### or\n\n拼接 OR\n\n```java\nor()\nor(boolean condition)\n```\n\n例: `eq(\"id\",1).or().eq(\"name\",\"老王\")`--->`id = 1 or name = '老王'`\n\n>**注意事项:**\n>\n>主动调用`or`表示紧接着下一个**方法**不是用`and`连接!(不调用`or`则默认为使用`and`连接)\n\n##### exists & notExists\n\n拼接 EXISTS / NOT EXISTS ( sql语句 )\n\n```java\nexists(String existsSql)\nexists(boolean condition, String existsSql)\n\nnotExists(String notExistsSql)\nnotExists(boolean condition, String notExistsSql)\n```\n\n####  QueryWrapper\n\n继承自 AbstractWrapper ,自身的内部属性 entity 也用于生成 where 条件\n及 LambdaQueryWrapper, 可以通过 new QueryWrapper().lambda() 方法获取\n\n##### select\n\n设置查询字段\n\n```java\nselect(String... sqlSelect)\nselect(Predicate\u003CTableFieldInfo> predicate)\nselect(Class\u003CT> entityClass, Predicate\u003CTableFieldInfo> predicate)\n```\n\n以上方法分为两类.\n第二类方法为:过滤查询字段(主键除外),入参不包含 class 的调用前需要`wrapper`内的`entity`属性有值! 这两类方法重复调用以最后一次为准\n\n```java\n@Test\npublic void testSelect() {\n    QueryWrapper queryWrapper = new QueryWrapper();\n    queryWrapper.select(\"id\");\n    List list = tTestMapper.selectList(queryWrapper);\n    // [TTest(id=1, name=null), TTest(id=2, name=null), TTest(id=3, name=null)]\n}\n```\n\n#### UpdateWrapper\n\n继承自 `AbstractWrapper` ,自身的内部属性 `entity` 也用于生成 where 条件\n及 `LambdaUpdateWrapper`, 可以通过 `new UpdateWrapper().lambda()` 方法获取\n\n#####  set\n\nSQL SET 字段\n\n```java\nset(String column, Object val)\nset(boolean condition, String column, Object val)\n```\n\n例: `set(\"name\", \"老李头\")`\n\n##### setSql\n\n设置 SET 部分 SQL\n\n```java\nsetSql(String sql)\n```\n\n例: `setSql(\"name = '老李头'\")`\n\n### 代码生成器\n\n> AutoGenerator 是 MyBatis-Plus 的代码生成器，通过 AutoGenerator 可以快速生成 Entity、Mapper、Mapper XML、Service、Controller 等各个模块的代码，极大的提升了开发效率。\n\n说到代码生成器，应该不少人用过[mybatis generator](https://ayay.xyz/2020/01/08/20200108/)\n\n作为mybatis的增加版，代码生成器自然也是必不可少的。mybatis plus的代码生成器可谓十分优雅，无须繁琐的xml配置文件，不需要maven插件，只需要一个java类，运行即可！\n\n#### 添加依赖\n\nMyBatis-Plus 从 `3.0.3` 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖：\n\n添加代码生成器依赖\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>com.baomidou\u003C/groupId>\n    \u003CartifactId>mybatis-plus-generator\u003C/artifactId>\n    \u003Cversion>3.3.2\u003C/version>\n\u003C/dependency>\n```\n\n添加 模板引擎 依赖，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，如果都不满足您的要求，可以采用自定义模板引擎。\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>org.apache.velocity\u003C/groupId>\n    \u003CartifactId>velocity-engine-core\u003C/artifactId>\n    \u003Cversion>2.3\u003C/version>\n\u003C/dependency>\n```\n\n> 注意！如果您选择了**非默认引擎**，需要在 AutoGenerator 中 设置模板引擎。\n>\n> ```java\n> AutoGenerator generator = new AutoGenerator();\n>\n> // set freemarker engine\n> generator.setTemplateEngine(new FreemarkerTemplateEngine());\n>\n> // set beetl engine\n> generator.setTemplateEngine(new BeetlTemplateEngine());\n>\n> // set custom engine (reference class is your custom engine class)\n> generator.setTemplateEngine(new CustomTemplateEngine());\n>\n> // other config\n> ...\n> ```\n\n####  编写配置\n\n> MyBatis-Plus 的代码生成器提供了大量的自定义参数供用户选择，能够满足绝大部分人的使用需求。\n\n这里新建config包用来存放配置类。\n\n删掉之前测试新建的entity和mapper包以及包中的类，同时注释掉单元测试中对实体及mapper的引用。\n\n![image-20210323203254418](https://cdn.jsdelivr.net/gh/alightyoung/static/img/20210323203305.png)\n\n以下是配置文件，内容不多，并且都加上了注释，相信读者可以根据自己的环境自行修改。\n\n- CodeGenerator.java\n\n```java\npackage xyz.ayay.mpdemo.config;\n\nimport com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;\nimport com.baomidou.mybatisplus.core.toolkit.StringPool;\nimport com.baomidou.mybatisplus.core.toolkit.StringUtils;\nimport com.baomidou.mybatisplus.generator.AutoGenerator;\nimport com.baomidou.mybatisplus.generator.InjectionConfig;\nimport com.baomidou.mybatisplus.generator.config.*;\nimport com.baomidou.mybatisplus.generator.config.builder.ConfigBuilder;\nimport com.baomidou.mybatisplus.generator.config.converts.MySqlTypeConvert;\nimport com.baomidou.mybatisplus.generator.config.po.TableInfo;\nimport com.baomidou.mybatisplus.generator.config.rules.DbColumnType;\nimport com.baomidou.mybatisplus.generator.config.rules.FileType;\nimport com.baomidou.mybatisplus.generator.config.rules.IColumnType;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中\npublic class CodeGenerator {\n\n    public static String scanner(String tip) {\n        // 读取表名称\n        Scanner scanner = new Scanner(System.in);\n        StringBuilder help = new StringBuilder();\n        help.append(\"请输入\" + tip + \"：\");\n        System.out.println(help.toString());\n        if (scanner.hasNext()) {\n            String ipt = scanner.next();\n            if (StringUtils.isNotBlank(ipt)) {\n                return ipt;\n            }\n        }\n        throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\");\n    }\n\n    public static void main(String[] args) {\n        // 代码生成器\n        AutoGenerator mpg = new AutoGenerator();\n        // 全局配置\n        GlobalConfig gc = new GlobalConfig();\n        String projectPath = System.getProperty(\"user.dir\");\n        gc.setOutputDir(projectPath + \"/src/main/java\");\n        gc.setAuthor(\"AlightYoung\");\n        // 生成后是否打开资源管理器\n        gc.setOpen(false);\n        // 实体属性 Swagger2 注解\n        gc.setSwagger2(false);\n        // 覆盖已有文件,这里先不设置覆写，后面通过cfg.setFileCreate指定覆盖\n        gc.setFileOverride(false);\n        //去掉Service接口的首字母I\n        gc.setServiceName(\"%sService\");\n        //主键策略\n        gc.setIdType(IdType.ASSIGN_ID);\n        // 定义生成的实体类中日期类型\n        gc.setDateType(DateType.ONLY_DATE);\n\n        mpg.setGlobalConfig(gc);\n\n        // 数据源配置\n        DataSourceConfig dsc = new DataSourceConfig();\n        dsc.setUrl(\"jdbc:mysql://localhost:3306/db_test?&serverTimezone=UTC\");\n        // dsc.setSchemaName(\"public\");\n        dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");\n        dsc.setUsername(\"root\");\n        dsc.setPassword(\"123456\");\n        // 数据库类型映射\n        dsc.setTypeConvert(new MySqlTypeConvert() {\n            @Override\n            public IColumnType processTypeConvert(GlobalConfig globalConfig, String fieldType) {\n                //将数据库中datetime转换成date\n                if (fieldType.toLowerCase().contains(\"datetime\")) {\n                    return DbColumnType.DATE;\n                }\n                return (DbColumnType) super.processTypeConvert(globalConfig, fieldType);\n            }\n        });\n        mpg.setDataSource(dsc);\n        // 包配置\n        PackageConfig pc = new PackageConfig();\n        // pc.setModuleName(scanner(\"模块名\"));\n        pc.setParent(\"xyz.ayay.mpdemo\");\n        pc.setController(\"controller\");\n        pc.setEntity(\"entity\");\n        pc.setService(\"service\");\n        pc.setMapper(\"mapper\");\n        mpg.setPackageInfo(pc);\n\n        // 自定义配置\n        InjectionConfig cfg = new InjectionConfig() {\n            @Override\n            public void initMap() {\n                // to do nothing\n            }\n        };\n\n        // 如果模板引擎是 freemarker\n        // String templatePath = \"/templates/mapper.xml.ftl\";\n        // 如果模板引擎是 velocity\n        String templatePath = \"/templates/mapper.xml.vm\";\n\n        // 自定义输出配置\n        List\u003CFileOutConfig> focList = new ArrayList\u003C>();\n        // 自定义配置会被优先输出\n        focList.add(new FileOutConfig(templatePath) {\n            @Override\n            public String outputFile(TableInfo tableInfo) {\n                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\n                return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName()\n                        + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML;\n            }\n        });\n        /**\n        cfg.setFileCreate(new IFileCreate() {\n            @Override\n            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) {\n                // 判断自定义文件夹是否需要创建\n                checkDir(\"调用默认方法创建的目录，自定义目录用\");\n                if (fileType == FileType.MAPPER) {\n                    // 已经生成 mapper 文件判断存在，不想重新生成返回 false\n                    return !new File(filePath).exists();\n                }\n                // 允许生成模板文件\n                return true;\n            }\n        });\n        */\n        // 设置覆盖哪些文件\n        cfg.setFileCreate(new IFileCreate() {\n            @Override\n            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) {\n                //如果是Entity则直接返回true表示写文件\n                if (fileType == FileType.ENTITY) {\n                    return true;\n                }\n                //否则先判断文件是否存在\n                File file = new File(filePath);\n                boolean exist = file.exists();\n                if (!exist) {\n                    file.getParentFile().mkdirs();\n                }\n                //文件不存在或者全局配置的fileOverride为true才写文件\n                return !exist || configBuilder.getGlobalConfig().isFileOverride();\n            }\n        });\n        cfg.setFileOutConfigList(focList);\n        mpg.setCfg(cfg);\n\n        // 配置模板\n        TemplateConfig templateConfig = new TemplateConfig();\n\n        // 配置自定义输出模板\n        //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别\n        // templateConfig.setEntity(\"templates/entity2.java\");\n        // templateConfig.setService();\n        // 不生成controller\n        templateConfig.setController(\"\");\n        // templateConfig.setController();\n\n        templateConfig.setXml(null);\n        mpg.setTemplate(templateConfig);\n\n        // 策略配置\n        StrategyConfig strategy = new StrategyConfig();\n        // 命名采用下划线转驼峰\n        strategy.setNaming(NamingStrategy.underline_to_camel);\n        strategy.setColumnNaming(NamingStrategy.underline_to_camel);\n        //生成代码时去掉表前缀\n        strategy.setTablePrefix(pc.getModuleName() + \"_\");\n        // strategy.setSuperEntityClass(\"你自己的父类实体,没有就不用设置!\");\n        // 实体类添加lombok\n        strategy.setEntityLombokModel(true);\n        // RestController风格\n        strategy.setRestControllerStyle(true);\n        // url中驼峰转连字符\n        strategy.setControllerMappingHyphenStyle(true);\n        // 公共父类\n        // strategy.setSuperControllerClass(\"你自己的父类控制器,没有就不用设置!\");\n        // 写于父类中的公共字段\n        // strategy.setSuperEntityColumns(\"id\");\n        strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\"));\n        mpg.setStrategy(strategy);\n        // 不设置 使用默认模板引擎VelocityTemplate\n        // mpg.setTemplateEngine(new FreemarkerTemplateEngine());\n        mpg.execute();\n    }\n\n}\n\n```\n\n当配置文件改完之后，右键执行：控制台出现\n\n```\n请输入表名，多个英文逗号分割：\nt_test\n```\n\n回车，等待奇迹！\n\n![image-20210323203600341](https://cdn.jsdelivr.net/gh/alightyoung/static/img/20210323203602.png)\n\n到这儿，我们对代码生成器已经有了一定的认识。在实际工作场景中，表的数量基本都在上百张以上，虽然可能配置的类也相对复杂一些，但和编写几百个实体类mapper、service相比，无疑让我们减轻了不少负担。\n\n#### 自定义模板引擎\n\n> 请继承类 com.baomidou.mybatisplus.generator.engine.AbstractTemplateEngine\n\n更多详见[官方文档-自定义模板引擎](https://baomidou.com/guide/generator.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E)\n\n### 分页插件\n\n分页在项目中的应用十分广泛。如果是在不使用分页插件的情况下写分页的话，效率必然大打折扣（对数据库底层不太了解的话，效率可能会很低）。所以，一个好用的分页插件无疑可以大幅提升开发效率（使开发人员专注于业务）。\n\n在我之前的博客中已经介绍过了一种分页的实现方式，但是当时对分页的理解尚浅（现在也浅），写的也比较简单。不过感兴趣的还是可以看看。 ---- [分页的实现](https://ayay.xyz/2019/12/28/20191228/)\n\n#### 配置文件\n\nconfig包下新建配置类 `MybatisPlusConfig.java`\n\n> 这里需要注意新旧版本可能导致配置文件有很大的变化，当你发现配置不成功时（一般同版本不太可能出现问题），请考虑查询官方文档---[分页实现](https://baomidou.com/guide/page.html)\n\n```java\npackage xyz.ayay.mpdemo.config;\n\nimport com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;\nimport com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize;\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@MapperScan(\"com.baomidou.cloud.service.*.mapper*\")\npublic class MybatisPlusConfig {\n\n    /**如果你是较新版的mybatis plus，请参考https://baomidou.com/guide/page.html，这个配置不适用于较新版本*/\n    @Bean\n    public PaginationInterceptor paginationInterceptor() {\n        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();\n        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false\n         paginationInterceptor.setOverflow(true);\n        // 设置最大单页限制数量，默认 500 条，-1 不受限制\n         paginationInterceptor.setLimit(500);\n        // 开启 count 的 join 优化,只针对部分 left join\n        paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));\n        return paginationInterceptor;\n    }\n\n}\n```\n\n#### 测试代码\n\n```java\n@Test\nvoid testPagination() {\n    // 每页两条记录，取第三页\n    Page\u003CTTest> page = new Page\u003C>(1, 2);\n\n    // page.addOrder(OrderItem.desc(\"id\"));\n    // Page\u003CTTest> resultPage = tTestMapper.selectPage(page, null);\n    // 使用上面的方法也能按照id进行倒排序\n    Page\u003CTTest> resultPage = tTestMapper.selectPage(page, Wrappers.\u003CTTest>lambdaQuery().orderByDesc(TTest::getId));\n\n    // 获取当前页的数据记录\n    System.err.println(resultPage.getRecords()); // [TTest(id=6, name=王八), TTest(id=5, name=田七)]\n    // 当前是第几页\n    System.err.println(resultPage.getCurrent()); // 1\n    // 总页数\n    System.err.println(resultPage.getPages());   // 3\n    // 每页的数据量\n    System.err.println(resultPage.getSize());    // 2\n    // 总共的记录数量\n    System.err.println(resultPage.getTotal());   // 6\n    // 这里并没有设置orders，需要的话则是在page条件中设置，lambdaQuery设置的排序这里查询不到\n    System.err.println(resultPage.getOrders());  // []\n}\n```\n\n这里我们就完成了一个基本的分页查询，似乎还是不用编写SQL\n\n但在某些场景中，不管出于何种原因，我们仍然希望编写xml来进行自定义分页的话，mybatis plus也同样是支持的。\n\n####  XML 自定义分页\n\n其实对mybatis熟悉的话，应该十分清楚该怎么在mapper中自定义sql，但是即使是自定义sql，也不需要关注分页的sql实现，这里提供一个简单的案例来说明\n\n安利下[MybatisX](https://baomidou.com/guide/mybatisx-idea-plugin.html)插件，不清楚的话点进去看一下就知道了。\n\n安装完成之后，因为在上面的代码生成器中环节中，我们已经有了我们的mapper接口以及xml文件。\n\n所以我们直接在mapper接口中添加一个分页方法\n\n```java\n/**\n     * \u003Cp>\n     * 查询 : 根据name模糊查询用户列表，分页显示\n     * \u003C/p>\n     *\n     * @param page 分页对象,xml中可以从里面进行取值,传递参数 Page 即自动分页,必须放在第一位(你可以继承Page实现自己的分页对象)\n     * @param name name\n     * @return 分页对象\n     */\nIPage\u003CTTest> selectPageVo(Page\u003CTTest> page, String name);\n```\n\n写完之后可以看到出现警告，hover即可发现generate statement，点击。对应的xml语句模板就出来了，然后点击左边的【红色小鸟】跳转过去。\n\n编写一个简单的列表查询即可，无需实现分页逻辑（看上面接口的注释，mapper接口中方法只要传入了page参数，必须第一个，就可以 自 动 分 页！）\n\n```xml\n\u003Cselect id=\"selectPageVo\" resultType=\"xyz.ayay.mpdemo.entity.TTest\">\n    SELECT id,name FROM t_test where 1=1\n    \u003Cif test=\"name!=null and name != ''\">\n        and name like concat('%',#{name},'%')\n    \u003C/if>\n\u003C/select>\n```\n\n下面编写测试类检查一下\n\n```java\n@Test\nvoid testXMLPagination() {\n    // 不进行 count sql 优化，解决 MP 无法自动优化 SQL 问题，这时候你需要自己查询 count 部分\n    // page.setOptimizeCountSql(false);\n    // 当 total 为小于 0 或者设置 setSearchCount(false) 分页插件不会进行 count 查询\n    // 要点!! 分页返回的对象与传入的对象是同一个,所以不用另外新建变量去接收\n    Page\u003CTTest> page = new Page\u003C>(2,3);\n    page.addOrder(OrderItem.asc(\"id\"));\n    tTestMapper.selectPageVo(page, null);\n    System.err.println(page.getRecords()); // [TTest(id=4, name=赵六), TTest(id=5, name=田七), TTest(id=6, name=王八)]\n    System.err.println(page.getCurrent()); // 2\n    System.err.println(page.getPages());   // 2\n    System.err.println(page.getSize());    // 3\n    System.err.println(page.getTotal());   // 6\n    System.err.println(page.getOrders());  // [OrderItem(column=id, asc=true)]\n}\n```\n\n至此，分页部分便告一段落，好处此刻已无需多言了。\n\n### 主键&自动填充\n\n#### 自动生成主键\n\n在之前的insert中，我们为对象设置了一个id，但其实mybatis plus可以自动生成id，无论是数字还是字符串类型，下面举个例子。\n\n首先在实体类的id字段上加上注解\n\n```java\n@TableId(value = \"id\",type = IdType.ASSIGN_ID)\nprivate Long id;\n```\n\n然后编写测试类插入一条记录\n\n```java\n@Test\nvoid testAutoId() {\n    TTest test = new TTest();\n    test.setName(\"auto id row\");\n    tTestMapper.insert(test);\n}\n```\n\n可以发现这里我们没有设置id，再看看数据库\n\n|         id          |    name     |\n| :-----------------: | :---------: |\n| 1374718566774980610 | auto id row |\n\n可以看到记录被成功插入，并且生成了一长串数字作为id。\n\n#### 生成策略\n\n可以看到，上面的注解指定了IdType，事实上，mybatis plus内置了几种常见类型的IdType，如果你对内置的不满意，也可以考虑自定义生成。下面简单介绍一个IdType。\n\n|      IdType       |                      描述                       |\n| :---------------: | :---------------------------------------------: |\n|       AUTO        | 使用自增方式生成，MySQL主键需设置Auto Increment |\n|       NONE        |          不自动生成，跟随全局默认INPUT          |\n|       INPUT       |              用户在插入前自行设置               |\n|     ASSIGN_ID     | 自动分配，雪花算法，Integer Long String类型均可 |\n|    ASSIGN_UUID    |        自动分配，UUID算法，仅String类型         |\n|   ~~ID_WORKER~~   |     废弃，类似ASSIGN_ID的Integer和Long类型      |\n| ~~ID_WORKER_STR~~ |         废弃，类似ASSIGN_ID的String类型         |\n|     ~~UUID~~      |              废弃，类似ASSIGN_UUID              |\n\n#### 自定义ID生成\n\n首先，idtype需要设置为`ASSIGN_ID`或者`ASSIGN_UUID`，然后实现自定义id生成器，即编写一个类，实现`IdentifierGenerator`接口，同时标记注解 `@Component`\n\n举个例子\n\n```java\n@Component\npublic class CustomIdGenerator implements IdentifierGenerator {\n    @Override\n    public Long nextId(Object entity) {\n        //可以将当前传入的class全类名来作为bizKey,或者提取参数来生成bizKey进行分布式Id调用生成.\n        String bizKey = entity.getClass().getName();\n        //根据bizKey调用分布式ID生成\n        long id = new Date().hashCode() + bizKey.hashCode();\n        //返回生成的id值即可.\n        return id;\n    }\n}\n```\n\n#### 自动填充\n\n考虑到使用场景，这里我们在表中添加两个字段\n\ncreate_time & update_time，顺便把主键改成递增，之前建表忘了加。\n\n然后使用之前的代码生成器重新生成实体类\n\n新建Handler包，并创建一个类继承MetaObjectHandler\n\n```java\n@Component\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        // 新增时需自动填充创建及修改时间\n        this.strictInsertFill(metaObject, \"createTime\", Date.class, new Date());\n        this.strictInsertFill(metaObject, \"updateTime\", Date.class, new Date());\n    }\n\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        // 修改时仅自动填充修改时间\n        this.strictUpdateFill(metaObject, \"updateTime\", Date.class, new Date());\n    }\n}\n```\n\n> 这里需要注意，不同版本的api可能会发生改变，详细参考官方文档，[传送门](https://baomidou.com/guide/auto-fill-metainfo.html)\n\n> 注意事项：\n>\n> - 填充原理是直接给`entity`的属性设置值!!!\n> - 注解则是指定该属性在对应情况下必有值,如果无值则入库会是`null`\n> - `MetaObjectHandler`提供的默认方法的策略均为:如果属性有值则不覆盖,如果填充值为`null`则不填充\n> - 字段必须声明`TableField`注解,属性`fill`选择对应策略,该声明告知`Mybatis-Plus`需要预留注入`SQL`字段\n> - 填充处理器`MyMetaObjectHandler`在 Spring Boot 中需要声明`@Component`或`@Bean`注入\n> - 要想根据注解`FieldFill.xxx`和`字段名`以及`字段类型`来区分必须使用父类的`strictInsertFill`或者`strictUpdateFill`方法\n> - 不需要根据任何来区分可以使用父类的`fillStrategy`方法\n\n接下来对实体类字段添加注解\n\n```java\n@Data\n@EqualsAndHashCode(callSuper = false)\npublic class TTest implements Serializable {\n\n    private static final long serialVersionUID=1L;\n\n    @TableId(value = \"id\", type = IdType.AUTO)\n    private Long id;\n\n    private String name;\n\n    @TableField(value = \"create_time\", fill = FieldFill.INSERT)\n    private Date createTime;\n\n    @TableField(value = \"update_time\", fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n\n}\n```\n\n这里解释一下FieldFill的各个值\n\n```java\npublic enum FieldFill {\n    /**\n     * 默认不处理\n     */\n    DEFAULT,\n    /**\n     * 插入填充字段\n     */\n    INSERT,\n    /**\n     * 更新填充字段\n     */\n    UPDATE,\n    /**\n     * 插入和更新填充字段\n     */\n    INSERT_UPDATE\n}\n```\n\n之后使用insert+update进行测试即可，有问题就仔细检查handler有没有错误。\n\n### 逻辑删除\n\n简单来说，正常通过delete操作的数据将真正从表中删除，但有些场景下我们希望记录\n\n被删除后，表中仍然有记录，通过添加标志位，来判断记录是否被删除。\n\n照常编写一个简单的案例\n\n1. 首先在数据库表中添加一个`is_deleted`字段，类型tiny_int即可（只会用到0和1）\n\n2. 在springboot的配置文件`application.yml`添加以下配置\n\n   ```yaml\n   mybatis-plus:\n     global-config:\n       db-config:\n         logic-delete-field: isDeleted  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置实体类字段上的@TableLogic注解)\n         logic-delete-value: 1 # 逻辑已删除值(默认为 1)\n         logic-not-delete-value: 0 # 逻辑未删除值(默认为 0)\n   ```\n\n3. 使用代码生成器重新生成实体类，记得加上之前两个@TableField已实现自动填充（嫌麻烦直接在后面手动加上isDeleted属性也行。另外我之前在代码生成器环节配置了实体类存在也进行覆盖，不想覆盖的自己改回来）\n\n4. 编写删除查询进行测试即可\n\n这里测试逻辑测试发现记录确实没有被删除，但是isDeleted字段也没有改变，这是因为之前的记录的isDeleted为null，而在加入逻辑删除之后会把查询及更新的语句都附加一个条件， `isDeleted = 0`，所以建议在数据库中将isDeleted字段的默认值设置为0。下面是官方的一些说明及问题。\n\n> 说明:\n>\n> 只对自动注入的sql起效:\n>\n> - 插入: 不作限制\n> - 查找: 追加where条件过滤掉已删除数据,且使用 wrapper.entity 生成的where条件会忽略该字段\n> - 更新: 追加where条件防止更新到已删除数据,且使用 wrapper.entity 生成的where条件会忽略该字段\n> - 删除: 转变为 更新\n>\n> 例如:\n>\n> - 删除: `update user set deleted=1 where id = 1 and deleted=0`\n> - 查找: `select id,name,deleted from user where deleted=0`\n>\n> 字段类型支持说明:\n>\n> - 支持所有数据类型(推荐使用 `Integer`,`Boolean`,`LocalDateTime`)\n> - 如果数据库字段使用`datetime`,逻辑未删除值和已删除值支持配置为字符串`null`,另一个值支持配置为函数来获取值如`now()`\n>\n> 附录:\n>\n> - 逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。\n> - 如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。\n\n![image-20210325210627121](https://cdn.jsdelivr.net/gh/alightyoung/static/img/20210325210642.png)\n\n### 乐观锁\n\n#### 乐观锁简介\n\n乐观锁是并发控制中比较常见的的锁，它采取了更加宽松的加锁机制用于提高系统的性能。（*乐观锁机制避免了长事务中的数据库加锁开销*）最常见的是采用Version进行对数据进行记录。下面简单介绍一下它的实现方式。\n\n> 当要更新一条记录的时候，希望这条记录没有被别人更新\n>\n> - 取出记录时，获取当前version\n> - 更新时，带上这个version\n> - 执行更新时，set version = newVersion where version = oldVersion\n> - 如果version不对，就更新失败\n\n再补充一个例子加以理解。\n\n在一个金融系统中，操作员A和操作员B都要对客户的金额进行修改，所以都获取了客户当前金额100元（*同时获取当前version，假设为1*）\n\n- 操作员A扣除其40元，并将剩余金额60元进行返回\n\n- 操作员A扣除其20元，并将剩余金额80元进行返回\n\n假设操作员A先执行了更新，返回了客户的余额60，并设置了version=2\n\n然后操作员B在进行更新的时候发现version此时为2，和之前获取的不一致，所以会取消当前更新。（*假设没有version的判断，操作员B将余额80进行返回，那么客户的余额反而更多了，这显然是不合理的*）\n\n#### 乐观锁的实现\n\nMybatis Plus中使用了OptimisticLockerInnerInterceptor来实现乐观锁。\n\n使用方法\n\n1. 在数据库中添加version字段，类型为int\n\n2. 类似于分页插件，在mybatisPlusConfig添加一个bean，返回OptimisticLockerInnerInterceptor。\n\n   ```java\n   @Bean\n   public OptimisticLockerInterceptor optimisticLockerInterceptor() {\n       OptimisticLockerInterceptor optimisticLockerInterceptor = new OptimisticLockerInterceptor();\n       return optimisticLockerInterceptor;\n   }\n   ```\n\n3. 在实体类添加属性，并加上以下注解，尽管只使用了FieldFill.INSERT，但是更新时仍会自动填充。\n\n   ```java\n   @Version\n   @TableField(fill = FieldFill.INSERT)\n   private Integer version;\n   ```\n\n4. 在MyMetaObjectHandler中实现version字段的自动填充，给version一个初始值1。\n\n   ```java\n   @Override\n   public void insertFill(MetaObject metaObject) {\n       // 新增时需自动填充创建及修改时间\n       this.strictInsertFill(metaObject, \"createTime\", Date.class, new Date());\n       this.strictInsertFill(metaObject, \"updateTime\", Date.class, new Date());\n       this.strictInsertFill(metaObject, \"version\", Integer.class, 1);\n   }\n   ```\n\n5. 进行新增以及修改测试，注意修改时必须先查询，只进行修改不查询乐观锁将不再生效\n\n   ```java\n   @Test\n   public void testInsert() {\n       TTest testObj = new TTest();\n       testObj.setName(\"移动\");\n       tTestMapper.insert(testObj);\n   }\n\n   @Test\n   public void testUpdate() {\n       /**\n       * 这种直接的修改乐观锁不会生效（version不会改变）\n       * TTest test = new TTest();\n       * test.setName(\"移动update\");\n       * tTestMapper.update(test, Wrappers.\u003CTTest>lambdaQuery().eq(TTest::getName, \"移动\"));\n       **/\n       // 先查询，后修改，乐观锁生效\n       TTest test = tTestMapper.selectOne(Wrappers.\u003CTTest>lambdaQuery().eq(TTest::getName, \"移动\"));\n       test.setName(\"移动update\");\n       tTestMapper.updateById(test);\n   }\n   ```\n\n> 说明:\n>\n> - **支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime**\n> - 整数类型下 `newVersion = oldVersion + 1`\n> - `newVersion` 会回写到 `entity` 中\n> - 仅支持 `updateById(id)` 与 `update(entity, wrapper)` 方法\n> - **在 `update(entity, wrapper)` 方法下, `wrapper` 不能复用!!!**\n\n### 最后\n\nMybatis Plus至此便告一段落，更多细节请参考[官方文档](https://baomidou.com/guide/)（*u1s1官方文档的细节还有待完善，小声bb*）\n","\n### 简介\n\n早在19年的时候，Oracle就宣布JDK的许可证将发生改变。从那个时候就有了两种许可证，分别是BCL（2019年4月16日前的JDK）和OTN，前者是完全免费的，后者是商用付费的。为此，Oracle的解决方案是提供了两种JDK，一个是Oracle OpenJDK releases（*GPL V2*），另一个是Oracle Java SE product releases（BCL/OTN）。简单来说，如果想使用较新版本的JDK只能选择[Oracle OpenJDK](http://openjdk.java.net/)。还有一个选择就是自己获取OpenJDK源码自行编译。另外，使用阿里等其他公司维护的第三方OpenJDK也不失为为一个方案。这里附上阿里维护的[Alibaba Dragonwell JDK](http://dragonwell-jdk.io/)。如果非得选择Oracle Java SE下的JDK只能选择在2019年4月16日前发布的JDK，建议使用前确认一下Oracle JDK FAQ [https://www.oracle.com/java/technologies/javase/jdk-faqs.html](https://www.oracle.com/java/technologies/javase/jdk-faqs.html)。\n\n废话不多说，直接开始介绍Java1.8几个常用的特性。\n\n### Lambda表达式\n\nLambda 表达式（lambda expression）是Java 8的一个大亮点，Lambda表达式基于数学中的[λ演算](https://baike.baidu.com/item/λ演算)得名，直接对应于其中的lambda抽象（lambda abstraction）. Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中），这里的函数是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示[闭包](https://baike.baidu.com/item/闭包/10908873)（注意和数学传统意义上的不同）。使用Lambda表达式可以使代码变得十分简洁。\n\n**lambda表达式的重要特征**\n\n- **可选类型声明：** 不需要声明参数类型，编译器可以统一识别参数值。\n- **可选的参数圆括号：** 一个参数无需定义圆括号，但多个参数需要定义圆括号。\n- **可选的大括号：** 如果主体包含了一个语句，就不需要使用大括号。\n- **可选的返回关键字：** 如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。\n\n举个例子\n\n```java\n// 没有声明e的类型 一个参数（省略圆括号） 一个语句（省略大括号） 一个表达式自动返回 e.getMessage()的结果\ne -> e.getMessage()\n```\n\n这种用法是最为常见的。\n\n:::warning\nlambda 表达式只能引用标记了 **final** 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。\n\nlambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）\n\nLambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。\n:::\n\n### 方法引用\n\n方法引用通过使用`::`来引用一个方法，eg. `Class/instance::method`。\n\n1. 构造器引用（`User::new`）\n2. 静态方法引用\n3. 特定类的任意对象的方法引用\n4. 特定对象的方法引用\n\n编写一个简单的例子\n\n```java\nnew ArrayList\u003CString>(){{add(\"1\");add(\"2\");add(\"3\");}}.forEach(System.out::println);\n```\n\n### 函数式接口\n\n函数式接口指的是该接口**有且仅有一个抽象方法**\n\n函数式接口基本上用于配合lambda表达式\n\n使用`@FunctionalInterface`声明该接口为函数式接口\n\n```java\n@FunctionalInterface\npublic interface Runnable {\n    /**\n     * When an object implementing interface \u003Ccode>Runnable\u003C/code> is used\n     * to create a thread, starting the thread causes the object's\n     * \u003Ccode>run\u003C/code> method to be called in that separately executing\n     * thread.\n     * \u003Cp>\n     * The general contract of the method \u003Ccode>run\u003C/code> is that it may\n     * take any action whatsoever.\n     *\n     * @see     java.lang.Thread#run()\n     */\n    public abstract void run();\n}\n```\n\n可以看到Runnable接口就是函数式接口\n\n好处就在于可以直接使用lambda表达式实现该接口，不再需要通过匿名内部类\n\n匿名内部类是这样的\n\n```java\nThread thread = new Thread(new Runnable() {\n\t@Override\n    public void run() {\n\n    }\n});\n```\n\nlambda expression方式\n\n```java\nThread thread = new Thread(()->{\n\n});\n```\n\n下面通过一个例子来看如果不是FunctionalInterface的话会发生什么\n\n```java\ninterface Phone {\n    void brand(String brand);\n    void name(String name);\n}\n\nclass Human{\n    Human(Phone phone){\n    \tSystem.out.println(\"play phone...\");\n    }\n}\n\nHuman human = new Human(new Phone() {\n    @Override\n    public void brand(String brand) {\n\n    }\n\n    @Override\n    public void name(String name) {\n\n    }\n});\n// 写成这种将会编译错误\n// Multiple non-overriding abstract methods found in interface xxx.xxx.xxxx.Class.Phone\n// Human human = new Human(()->{});\n\n// 而如果删掉Phone接口的一个方法，使其满足有且仅有一个抽象方法，则可以直接使用lambda expression\n// Human human = new Human(brand->{});\n\n// @FunctionalInterface不是必需的。声明该注解的作用在于如果该接口中出现两个或以上抽象方法时会产生编译错误\n```\n\n### Stream API\n\n相信Stream API已经并不少见了，写本文的出发点也是因为Stream API，因为经常看到别人使用Stream API初始化容器。\n\n那么问题就来了，什么时stream？\n\nstream是一个非常抽象的概念。可以先简单理解成**来自数据源的元素队列并支持聚合操作**\n\n了解字节流的概念的话应该不难理解\n\n**两个基础特征**\n\n- **Pipelining**: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n- **内部迭代**： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。\n\n#### 流的生成\n\n在Java 8 中，集合对象可以通过 **stream()** 或者 **parallelStream** 为集合创建流，区别在于前者是串行流，后者是并行流。\n\n```java\nList\u003CString> filtered = Arrays.asList(\"abc\", \"\", \"bc\", \"efg\", \"abcd\",\"\", \"jkl\").stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());\n```\n\n通过stream+lambda，我们竟可以如此优雅的实现List的筛选！\n\n#### forEach\n\nStream 提供了新的方法 `forEach` 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：\n\n```java\nnew Random().ints().limit(10).forEach(System.err::println);\n```\n\n#### map\n\nmap 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：\n\n```java\n// 获取对应的平方数 distinct:去重\nList\u003CInteger> squaresList = Arrays.asList(3, 2, 2, 3, 7, 3, 5).stream().map( i -> i*i).distinct().collect(Collectors.toList());\n```\n\n#### filter\n\nfilter 方法用于通过设置的条件过滤出元素。\n\n```java\n// 获取空字符串的数量\nArrays.asList(\"abc\", \"\", \"bc\", \"efg\", \"abcd\",\"\", \"jkl\").stream().filter(string -> string.isEmpty()).count();\n```\n\n#### limit\n\nlimit 方法用于获取指定数量的流。例子之前foreach已经展示过了\n\n#### sorted\n\nsorted 方法用于对流进行排序。\n\n```java\nnew Random().ints().limit(10).sorted().forEach(System.err::println);\n```\n\nsort list\n\n```java\n// sort by desc\nnew ArrayList\u003CInteger>(){{\n            add(1);\n            add(2);\n            add(3);\n            add(4);\n        }}.stream().sorted(Comparator.reverseOrder()).forEach(System.out::println);\n```\n\nsort map\n\n```java\n// sort by key\nmap.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(e -> System.out.println(e.getKey() + \" \" + e.getValue()));\n// sort by key desc\nmap.entrySet().stream().sorted(Map.Entry.comparingByKey(Comparator.reverseOrder())).forEach(e -> System.out.println(e.getKey() + \" \" + e.getValue()));\n// sort by value\nmap.entrySet().stream().sorted(Map.Entry.comparingByValue()).forEach(e -> System.out.println(e.getKey() + \" \" + e.getValue()));\n// sort by value desc\nmap.entrySet().stream().sorted(Map.Entry.comparingByValue(Comparator.reverseOrder())).forEach(e -> System.out.println(e.getKey() + \" \" + e.getVal\n```\n\n#### Collectors\n\nCollectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串。\n\n```java\nList\u003CString>strings = Arrays.asList(\"abc\", \"\", \"bc\", \"efg\", \"abcd\",\"\", \"jkl\");\n// 转成集合\nList\u003CString> filtered = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.toList());\n// 转成字符串\nString mergedString = strings.stream().filter(string -> !string.isEmpty()).collect(Collectors.joining(\", \"));\n```\n\n#### 统计\n\n一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。\n\n```java\nList\u003CInteger> numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);\n\nIntSummaryStatistics stats = numbers.stream().mapToInt((x) -> x).summaryStatistics();\n\nSystem.out.println(\"列表中最大的数 : \" + stats.getMax());\nSystem.out.println(\"列表中最小的数 : \" + stats.getMin());\nSystem.out.println(\"所有数之和 : \" + stats.getSum());\nSystem.out.println(\"平均数 : \" + stats.getAverage());\n```\n\n用过的都说好！\n\n### Date Time API\n\nJava 8通过发布新的Date Time API (JSR 310)来进一步加强对日期与时间的处理。\n\n在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：\n\n- **非线程安全** − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。\n- **设计很差** − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。\n- **时区处理麻烦** − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。\n\nJava 8 在 **java.time** 包下提供了很多新的 API。以下为两个比较重要的 API：\n\n- **Local(本地)** − 简化了日期时间的处理，没有时区的问题。\n- **Zoned(时区)** − 通过制定的时区处理日期时间。\n\n新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\n\n#### 本地化日期时间 API\n\n不需要考虑时区的情况。\n\n```java\nLocalDateTime currentTime = LocalDateTime.now();\nSystem.out.println(currentTime); // 2021-03-29T21:31:25.006189300\nLocalDate localDate = currentTime.toLocalDate();\nSystem.out.println(localDate); // 2021-03-29\nLocalTime localTime = currentTime.toLocalTime();\nSystem.out.println(localTime); // 21:31:25.006189300\n// 类似获取年月日都可以猜到怎么调了\n// 解析字符串 其他依此类推\nLocalTime parseTime = LocalTime.parse(\"21:31:25\");\n// 21 小时 31 分钟\nLocalTime date4 = LocalTime.of(21, 31);\n// 29 March 2021\nLocalDate date3 = LocalDate.of(2021, Month.MARCH, 29);\n```\n\n#### 使用时区的日期时间API\n\n如果我们需要考虑到时区，就可以使用时区的日期时间API。\n\n``` java\n// 获取当前时间日期\nZonedDateTime now = ZonedDateTime.now();\nSystem.out.println(now); // 2021-03-29T21:40:22.618917600+08:00[Asia/Shanghai]\n// 解析\nZonedDateTime zonedDateTime = ZonedDateTime.parse(now.toString());\n// 时区ID\nZoneId zoneId = now.getZone();\nZoneId zoneId2 = ZoneId.of(\"Europe/Paris\");\n// 系统时区\nZoneId currentZoneId = ZoneId.systemDefault();\nSystem.out.println(currentZoneId); // Asia/Shanghai\n// 转换\nZonedDateTime.of(LocalDateTime.now(),ZoneId.systemDefault());\n```\n\n### Optional 类\n\n主要用来处理一些可以预见到可能为null的情况，避免出现错误，注意Optionnal本身不为null，它应当永远指向Optional的实例。\n\n:::tip\n在Optional的实例上使用对标识敏感的操作（包括引用相等（=）、标识哈希码或同步）可能会产生不可预知的结果，应该避免。\n:::\n\n常见用法\n\n```java\n// Optional.ofNullable - 允许传递为 null 参数\nOptional\u003CInteger> o1 = Optional.ofNullable(null);\n// 不允许 会抛NullPointerException\n// Optional\u003CObject> o2 = Optional.of(null);\n// isPresent 判断是否为null\nif(o1.isPresent()){ // 此处为false\n    // 获取值，必须值存在\n    o1.get();\n}\n// 存在直接返回，不存在返回指定值\no1.orElse(0);\n```\n\n常见的就以上这些，还有一些其他api，但是见的比较少，所以没有列举。\n\n值得一提的是，Optional类也支持Stream API。\n\n### 最后\n\nJDK 8的新特性其实远不止此，更多新特性可以查看 [What is new in JDK 8](https://www.oracle.com/java/technologies/javase/8-whats-new.html)\n","\n## 什么是REST\n\nREST是**代表性状态转移**的首字母缩写（**RE**presentational **S**tate **T**ransfer），它是分布式超媒体系统的体系结构样式，由Roy Fielding于2000年在他的著名论文中首次提出。\n\n## REST的指导原则\n\n如果要将接口称之为RESTful，则需要满足以下6个基本原则\n\n### 1.客户端服务器\n\n这种限制本质上意味着客户端应用程序和服务器应用程序必须能够独立地发展而不会相互依赖。客户端应该只知道资源URI，仅此而已。\n\n可以理解成前后分离\n\n### 2.无状态\n\n所有客户端-服务器交互都变为无状态。服务器将不存储有关客户端发出的最新HTTP请求的任何内容。它将每个请求视为新请求。没有会议，没有历史。\n\n### 3.可缓存\n\n缓存约束要求对请求的响应中的数据被隐式或显式标记为可缓存或不可缓存。 如果响应是可缓存的，则授予客户端缓存以将响应数据重新用于以后的等效请求的权限。\n\n### 4.统一接口\n\n系统中的资源应**仅具有一个**逻辑URI，并且应提供一种获取相关或附加数据的方式。最好将**资源与网页同义**。\n\n### 5.分层系统\n\nREST允许您使用分层的系统架构，在该架构中，您可以在服务器A上部署API，并在服务器B上存储数据并在服务器C中对请求进行身份验证。客户端通常无法知道自己是直接连接到终端服务器还是中间设备。\n\n### 6.按需代码（可选）\n\n大多数时候，您将以XML或JSON的形式发送资源的静态表示。但是，在需要时，您可以自由地`return executable code`支持应用程序的一部分，例如，客户端可以调用您的API来获取UI窗口小部件呈现代码。这是允许的。\n\n## REST API设计的最佳做法\n\n### 1.接受并使用JSON进行响应\n\n现在主流基本都是前后分离，返回JSON了，没啥好说的。曾经非常流行的XML现在也很少见了。JSON格式的最大优势就在于JSON结构更容易**映射**至一般语言的数据结构，更好处理。而在易读性，这个就见仁见智了，但是有一点XML数据会更加冗余，传输效率相对较低，这点是毋庸置疑的。\n\n### 2.在路径中使用名词代替动词\n\n一个简单的例子，以前定义url时，我们常常会加上get，delete之类的动词，而在RESTful API中，我们可以直接使用`名词`+`请求方法类型`就能判断出API的含义。\n\nHTTP常见的请求方法有`GET`、`POST`、`PUT`、`DELETE`。其中`GET`用于检索资源（read）。` POST`将新数据提交到服务器（create）。 `PUT`更新现有数据（update）。 `DELETE`删除数据（delete）。通过这些动词映射到CRUD操作。\n\n例如 :\n\n`GET: /students/:id` 根据id查询一个学生信息\n\n`DELETE: /students/:id` 根据id删除一个学生\n\n`POST: /students` 新增一个学生\n\n`PUT: /students/:id` 修改一个学生的信息\n\n> 注意：避免资源URL部分使用复数，这会影响API的统一性。\n\n### 3.使用复数名词命名集合\n\n通常情况下，我们会使用articles获取一个文章列表，如果是需要一篇文章，则可以在资源集合后加个id。eg. `/articles/:id`。同时，因为我们的数据库表名一般也是复数，所以也可以与数据库的表保持一致性。可以避免出现歧义。\n\n### 4.对分层对象使用嵌套资源\n\n处理嵌套资源的路径应通过将嵌套资源附加为父资源后面的路径的名称来完成。\n\n例如，获取某篇文章的评论\n\n`/articles/:articleid/comments`\n\n在这种结构下，我们可以很清楚的知道评论资源是文章资源的子对象。\n\n### 5.优雅处理错误并返回标准状态码\n\n发生错误的可能是多样的，为了优雅的处理错误，我们必须定下一些响应码以使API用户在出现错误时不至于困惑。\n\n#### HTTP Status Codes\n\nHTTP定义了一些标准状态代码，可用于传达客户请求的结果。状态码分为五类\n\n- **1xx: 信息** – 交流传输协议级别的信息.\n- **2xx: 成功** – 表示客户的请求已被成功接受.\n- **3xx: 重定向** – 表示客户端必须采取一些其他措施才能完成他们的请求。\n- **4xx: 客户端错误** – 此类错误状态代码通常指向客户端。\n- **5xx: 服务端错误** – 这类错误状态代码通常指向服务端。\n\n下面通过一个表格来详细介绍一些常见的REST状态码\n\n| **STATUS CODE**           | **DESCRIPTION**                                              |\n| :------------------------ | :----------------------------------------------------------- |\n| 200 OK                    | 指示请求已成功。                                             |\n| 201 Created               | 指示请求已成功，并且结果是创建了新资源。                     |\n| 204 No Content            | 服务器已完成请求，但不需要返回响应正文。服务器可以返回更新的元信息。 |\n| 301 Moved Permanently     | 所请求资源的URL已永久更改。新的URL由`Location`响应中的头字段给出。除非另有说明，否则此响应是可缓存的。 |\n| 302 Found                 | 所请求资源的URL已临时更改。新的URL由`Location`响应中的头字段给出。仅当由`Cache-Control`或`Expires`头字段指示时，此响应才可缓存。 |\n| 400 Bad Request           | 由于语法错误，服务器无法理解该请求。客户不应在没有修改的情况下重复请求。 |\n| 401 Unauthorized          | 指示该请求需要用户认证信息。客户端可以使用合适的Authorization头字段重复请求 |\n| 403 Forbidden             | 未经授权的请求。客户端没有对该内容的访问权限。与401不同，服务器知道客户端的身份。 |\n| 404 Not Found             | 服务器找不到请求的资源。                                     |\n| 500 Internal Server Error | 服务器遇到意外情况，阻止其满足请求。（通常不应该明确地抛出。） |\n| 502 Bad Gateway           | 服务器作为网关获取处理请求所需的响应时，收到无效响应。       |\n| 503 Service Unavailable   | 服务器尚未准备好处理该请求。（可能是服务器过载，系统某些部分发生故障） |\n\n有了这些状态码，服务端在处理错误时便可以给出一个明确定义的错误码（通常还需要附加一些具体的信息），而客户端也可以通过错误码以及附加信息了解系统错误的原因。\n\n:::details{text=\"点击展开Java接口模板\"}\n请直接使用Spring的HttpStatus\n``` java\npublic interface HttpStatusCodes {\n\n    /**\n     * https://restfulapi.net/http-status-codes/\n     * 1xx: 信息 – 交流传输协议级别的信息.\n     * 2xx: 成功 – 表示客户的请求已被成功接受.\n     * 3xx: 重定向 – 表示客户端必须采取一些其他措施才能完成他们的请求。\n     * 4xx: 客户端错误 – 此类错误状态代码通常指向客户端。\n     * 5xx: 服务端错误 – 这类错误状态代码通常指向服务端。\n     **/\n\n    // 指示请求已成功。\n    Integer SUCCESS = 200;\n    // 指示请求已成功，并且结果是创建了新资源。\n    Integer CREATED = 201;\n    // 服务器已完成请求，但不需要返回响应正文。服务器可以返回更新的元信息。\n    Integer N0_CONTENT = 204;\n    // 所请求资源的URL已永久更改。新的URL由Location响应中的头字段给出。除非另有说明，否则此响应是可缓存的。\n    Integer MOVED_PERMANENTLY = 301;\n    // 所请求资源的URL已临时更改。新的URL由Location响应中的头字段给出。仅当由Cache-Control或Expires头字段指示时，此响应才可缓存。\n    Integer Found = 302;\n    // 由于语法错误，服务器无法理解该请求。客户不应在没有修改的情况下重复请求。\n    Integer BAD_REQUEST = 400;\n    // 指示该请求需要用户认证信息。客户端可以使用合适的Authorization头字段重复请求\n    Integer UNAUTHORIZED = 401;\n    // 未经授权的请求。客户端没有对该内容的访问权限。与401不同，服务器知道客户端的身份。\n    Integer FORBIDDEN = 403;\n    // 服务器找不到请求的资源。\n    Integer NOT_FOUND = 404;\n    // 服务器遇到意外情况，阻止其满足请求。（通常不应该明确地抛出。）\n    Integer INTERNAL_SERVER_ERROR = 500;\n    // 服务器作为网关获取处理请求所需的响应时，收到无效响应。\n    Integer BAD_GATEWAY = 502;\n    // 服务器尚未准备好处理该请求。（可能是服务器过载，系统某些部分发生故障）\n    Integer SERVICE_UNAVAILABLE = 503;\n\n}\n```\n:::\n\n### 6.允许过滤、排序、分页\n\n通常，为了避免一次性返回太多数据而导致的响应时间过长，服务端通常会使用过滤、分页的方式，来使系统每次仅需返回一部分而不是全部数据，以此减少系统响应时间。\n\n### 7.保持良好的安全习惯\n\n客户端和服务器之间的大多数通信应该是私有的，因为我们经常发送和接收私有信息。因此，必须使用SSL / TLS进行安全保护。\n\nSSL证书可以很简单的加载到服务器上，并且成本是免费的或非常低的。没有理由不让我们的REST API通过安全通道进行通信，而不是公开进行通信。\n\n人们不应该能够访问他们要求的更多信息。例如，普通用户不应该能够访问其他用户的信息。他们也不应该能够访问管理员的数据。\n\n为了实施最小权限原则，我们需要为单个角色添加角色检查，或者为每个用户添加更精细的角色。\n\n如果我们选择将用户分组为几个角色，则这些角色应具有覆盖他们所需要的全部权限，而不再需要更多权限。如果我们对用户可以访问的每个功能具有更细化的权限，那么我们必须确保管理员可以相应地向每个用户添加和删除这些功能。另外，我们需要添加一些可以应用于组用户的预设角色，这样我们就不必手动为每个用户执行此操作。\n\n> **最小权限原则**\n>\n> 在计算机科学以及其它领域中，最小权限原则是要求计算环境中的特定抽象层的每个模组如进程、用户或者计算机程序只能访问当下所必需的信息或者资源。\n>\n> 赋予每一个合法动作最小的权限，就是为了保护数据以及功能避免受到错误或者恶意行为的破坏。\n>\n> 最小权限原则也称为最少权限原则。\n\n### 8.缓存数据以提升性能\n\n我们可以添加缓存以从本地内存缓存中返回数据，而不是每次我们想要检索用户请求的某些数据时都查询数据库以获取数据。缓存的好处是用户可以更快地获取数据。\n\n### 9.版本化APIs\n\n如果API即将发生较大变动时，我们可能就需要考虑对API进行版本化控制，尽可能减少API的改变给使用者带来的不适。\n\n我们只需将版本号添加到API路径的开头即可对其进行版本控制。\n\n假设你提供了一个获取文章的API，处于`http://localhost/articles/:id`。\n\n之后你准备对API进行升级，正确的做法时将原有的API改为`http://localhost/v1/articles/:id`，然后再定义一个新的API为`http://localhost/v2/articles/:id`，\n\n如果你一开始就打算以后升级API的话，那么最好就是刚开始加带上版本号。\n\n## 最后\n\n通过以上对REST的了解，简单做个总结。RESTful接口的核心在于使用JSON返回数据、尽量使用名词而不是动词（主要是请求方法仍大多是GET+POST），合理的嵌套资源（有利于了解对象层级结构），优雅的处理错误（因为客户端服务端是完全独立的，所以良好的规范是必须的）。至于其他的一些细节我觉得就是见仁见智了。\n\n\n\n\n\n> **参考资料**\n>\n> [What is REST](https://restfulapi.net/)\n>\n> [Best practices for REST API design](https://stackoverflow.blog/2020/03/02/best-practices-for-rest-api-design/)\n","\n## 介绍\n\nVuePress是一个由Vue 驱动的静态网站生成器。\n\n**特点：**\n\n1. 简洁：以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\n2. Vue驱动：享受 Vue + webpack 的开发体验，可以在 Markdown 中使用 Vue 组件，又可以使用 Vue 来开发自定义主题。\n3. 高性能：VuePress 会为每个页面预渲染生成静态的 HTML，同时，每个页面被加载的时候，将作为 SPA 运行。\n\n它的初衷是为了更优雅的编写技术文档，而不是博客。但在VuePress 1.x版本之后，你可以轻松使用三方主题完成个人博客的搭建，这也将是该文章接下来主要阐述的内容。\n\n## 为什么是VuePress\n\n在使用VuePress之前，我的博客一直是使用Hexo进行管理的。如果你现在正在使用Hexo进行博客创作，那么你完全不需要迁移到VuePress，因为Hexo已经足够简单、易用，并且拥有数量庞大的优秀主题。\n\n那么我为什么还是花这么长时间进行博客的迁移呢？\n\n始于颜值。从第一眼看到Vue的文档的时候，我便感受到了一丝惊艳。\n\n再一个方面就是VuePress可以使用Vue编写组件进行高度的自定义，相信对于大部分熟悉Vue的开发者来说，都有着莫大的吸引力。事实上，**VuePress 就是一个由 Vue 、Vue Router和 webpack驱动的单页应用。**\n\n## 快速入门\n\n接下来将通过一个案例让你快速搭建一个博客环境。主题采用的是`vuepress-theme-reco`，主题简洁美观，同时兼容默认主题。\n\n1 创建并进入一个新目录\n\n```sh\nmkdir reco && cd reco\n```\n\n2 使用你喜欢的包管理器进行初始化\n\n```sh\nyarn init # npm init\n```\n\n3 将 VuePress 安装为本地依赖（不推荐全局安装）\n\n```sh\nyarn add -D vuepress # npm install -D vuepress\n```\n\n4 创建你的第一篇文档\n\n```sh\nmkdir docs && echo '# Hello VuePress' > docs/readme.md\n```\n\n5 在 `package.json` 中添加一些 scripts\n\n```json\n{\n  \"scripts\": {\n    \"docs:dev\": \"vuepress dev docs\",\n    \"docs:build\": \"vuepress build docs\"\n  }\n}\n```\n\n6 安装主题`vuepress-theme-reco`\n\n```sh\nyarn add vuepress-theme-reco # npm install vuepress-theme-reco --save-dev\n```\n\n7 创建`.vuepress`文件夹并创建`config.js`配置文件\n\n```sh\nmkdir docs/.vuepress && touch docs/.vuepress/config.js\n```\n\n8 编辑`config.js`文件\n\n```js\nmodule.exports = {\n  title: 'Title', //首页左上角title\n  theme: 'reco', // 应用博客主题\n  themeConfig: {\n    type: 'blog',\n    nav: [ // 首页导航栏\n      { text: 'Home', link: '/', icon: 'reco-home' },\n      { text: 'TimeLine', link: '/timeline/', icon: 'reco-date' }\n    ],\n    author: 'xxx', // 首页作者\n    authorAvatar: 'https://vuepress.vuejs.org/hero.png', // 首页头像\n    subSidebar: 'auto', // 博客页面的目录\n    // 博客配置\n    blogConfig: {\n      category: {\n        location: 2,     // 在导航栏菜单中所占的位置，默认2\n        text: 'Category' // 默认文案 “分类”\n      },\n      tag: {\n        location: 3,     // 在导航栏菜单中所占的位置，默认3\n        text: 'Tag'      // 默认文案 “标签”\n      },\n      socialLinks: [     // 信息栏展示社交信息\n        { icon: 'reco-github', link: 'https://github.com/recoluan' },\n        { icon: 'reco-npm', link: 'https://www.npmjs.com/~reco_luan' }\n      ]\n    }\n  }\n}\n```\n\n9 编辑`docs/readme.md`\n\n```yaml\n---\nhome: true\nheroText: VuePress\ntagline: Vue 驱动的静态网站生成器\n---\n```\n\n10 在`docs`下创建`posts`目录用于存放博客源文件\n\n```sh\nmkdir docs/posts;\n```\n\n11 在`post`目录下新建三个.md文件\n\n```yaml\n---\ntitle: post1\ndate: '2020-04-20 00:00:00'\ncategories:\n - frontEnd\ntags:\n - vuepress\nkeys: # 加密\n - 'e10adc3949ba59abbe56e057f20f883e' # 123456\nsticky: 1 # 文章置顶\npublish: true # 是否发布\n---\n\n# post1\n```\n\n以此类推新建出post2和post3。\n\n12 检查目录结构\n\n```\nvuepress/\n├── docs\n│   ├── .vuepress\n│   │   └── config.js\n│   ├── readme.md\n│   └── posts\n│       ├── post1.md\n│       ├── post2.md\n│       └── post3.md\n├── package.json\n└── yarn.lock\n```\n\n\n\n13 在`reco`目录下执行`yarn docs:dev`，打开[localhost:8080](http://localhost:8080)\n\n:::warning\n如果出现乱码请检查编码是否为UTF-8\n:::\n\n至此，博客的基础搭建便结束了。\n\n至于其他的实现细节，限于篇幅这里就不一一赘述。有需要的可以直接参考[VuePress官方文档](https://vuepress.vuejs.org/)以及[vuepress-theme-reco官方文档](https://vuepress-theme-reco.recoluan.com/)\n\n## 部署\n\n部署的方式很多，而且还分为云服务器和静态网站托管。所以接下来将通过三个方案进行分析。\n\n### 源码部署\n\n最原始，最粗暴的方式就是通过`yarn docs:build`编译出静态资源文件，文件默认保存在`docs/.vuepress/dist`下，你可以通过git或者ftp等其他方式将其部署到Github Pages、Serverless或是静态资源服务器。\n\n``` sh\n# get the dist folder\nyarn docs:build\n# sftp to tencent cloud & lcd the path of dist\nput -r dist/ /var/www/html/\nsystemctl restart nginx\nsystemctl status nginx\n```\n\n### Github Action\n\n:::tip\n需要简单了解Git、Github Action\n:::\n\n如果你准备部署Github Pages，那么Github Action可能是较好的选择。\n\n使用Github Action你可以\n\n1. 同时发布到Github Pages和Gitee Pages\n2. 备份你的博客源文件\n\n主要采用了两个Action来实现以上功能\n\n1. [Vuepress deploy](https://github.com/marketplace/actions/vuepress-deploy)\n2. [Hub Mirror Action](https://github.com/marketplace/actions/hub-mirror-action)\n\n这里就不赘述Github Action的用法了。\n\n### 一些建议\n\n类似Github Pages的服务有很多，像[Github Pages](https://pages.github.com/)、[Gitlab Pages](https://about.gitlab.com/stages-devops-lifecycle/pages/)、[Gitee Pages](https://gitee.com/help/articles/4136)、[Cloudflare Pages](https://pages.cloudflare.com/)，除此之外可供选择的还有[Netlify](https://www.netlify.com/)，[Vercel](https://vercel.com/)，或者选择国内一些Serverless服务来保证一个良好的响应速度。\n\n简单分析\n\n如果是国内不使用代理的情况下，选择Gitee Pages可以获得一个良好的体验，缺点是是Gitee Pages非Pro用户不支持自定义域名，每次提交得手动更新。\n\n选择国内Serverless服务一是需要付费，再一个国内服务器自定义域名是需要备案的。\n\n除了以上方案的话，其他方案基本都是国外服务器，在没有代理的情况下访问必然是十分慢的。\n\n推荐Github Pages + Gitee Pages。\n\n首先，部署源代码到Git仓库，通过Github Action自动备份源程序到Gitee同时发布静态资源到Github Pages和Gitee Pages。\n\n将域名解析到Github Pages同时在navbar提供镜像选择。前提是你Github Pages能访问。意义不大。\n\n或者直接检测浏览器语言或者基于ip选择是否跳转Gitee Pages\n\n具体方案请自行参考。\n\n## 最后\n\n还是那句话，VuePress目前用作博客需要折腾，如果你已经在使用Hexo部署，那么完全没有必要切换，尤其是在你并不熟悉Vue的情况下。\n\n写博客不是为了换UI，写博客只是为了写博客。\n","\n## 序言\n\nGithub Action是Github自2018年10月推出的一款服务，主要用于CI/CD\n\n:::tip\nCI / CD (**C**ontinuous **I**ntegration / **C**ontinuous **D**elivery or **D**eployment)\n\n持续集成 & 持续交付/持续部署\n:::\n\n## 可以做些什么\n\n1. 自动部署你的项目到Github Pages\n2. 编译OpenWRT固件\n3. 代码质量检查\n4. ...\n\nGithub Action的玩法非常多，在官方的[Marketplace](https://github.com/marketplace?type=actions)中，你可以搜索到大量别人已经写好的Action，参考对应文档即可轻松实现一些强大的功能。当然，如果你想自定义也是没有问题的，前提是你足够了解它。\n\n## 一些概念\n\n在Github Action中，通常由一个yaml配置文件对应一个工作流。这个yaml文件的命名可以随意，但是必须放在`/.github/workflows/`目录下。\n\n在这个yaml文件下，你需要进行大量的配置。\n\n下面通过一个简单的例子来详细介绍一下\n\n*github-actions-demo.yml*\n``` yaml\n# 展示的名称 默认为文件名\nname: GitHub Actions Demo\n# 触发的条件，详细参考：https://docs.github.com/en/actions/reference/events-that-trigger-workflows\non: [push]\n# 工作\njobs:\n   # 自定义的工作\n  Explore-GitHub-Actions:\n    # 运行环境，详细参考：https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners\n    runs-on: ubuntu-latest\n    #步骤\n    steps:\n      - run: echo \"🎉 The job was automatically triggered by a ${{ github.event_name }} event.\"\n      - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\"\n      - run: echo \"🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.\"\n      - name: Check out repository code\n        uses: actions/checkout@v2\n      - run: echo \"💡 The ${{ github.repository }} repository has been cloned to the runner.\"\n      - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\"\n      - name: List files in the repository\n        run: |\n          ls ${{ github.workspace }}\n      - run: echo \"🍏 This job's status is ${{ job.status }}.\"\n```\n\n以上是一个较为简单的模板。具体会因需求的增加导致参数也会增加，例如env，通常是一些个人的配置参数。或者secrets，一般是用来获取Github的Access Token之类的加密参数。总之，大部分配置都是类似结构。\n\n## 一个栗子\n\n因为本博客就是利用了Github Action完成的持续部署。所以这里简单说明一下该Action的使用方式。\n\n首先在市场搜索VuePress，发现了一个star数最高的[VuePress Deploy](https://github.com/marketplace/actions/vuepress-deploy)\n\n使用方法在发布页描述的十分清楚，大致分为以下几个步鄹\n\n1. 在你的VuePress项目的根目录新建`.github/workflows`目录，并在其中新建一个`vuepress-deploy.yml`文件，复制以下内容。\n\n```yaml\nname: Build and Deploy\non: [push]\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout\n      uses: actions/checkout@master\n\n    - name: vuepress-deploy\n      uses: jenkey2011/vuepress-deploy@master\n      env:\n        ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}\n        TARGET_REPO: username/repo\n        TARGET_BRANCH: master\n        BUILD_SCRIPT: yarn && yarn build\n        BUILD_DIR: blog/.vuepress/dist/\n```\n\n其中`TARGET_REPO`是Github的用户名及你想存放VuePress的仓库，`TARGET_BRANCH`是你想要推送仓库的分支，`BUILD_SCRIPT`是你的构建脚本，`BUILD_DIR`是你构建之后生成的文件目录。根据自己本地的情况相应配置即可。\n\n2. Github token的生成和仓库secrets的添加\n\n    Token的生成：点击你的头像 > Settings > Developer settings > Personal access tokens > Generate new token. 权限至少要勾选repo\n    secrets的添加：Github的仓库下 > Settings > Secrets， 创建ACCESS_TOKEN， 值就填写你刚才创建的token，确定。\n\n3. 推送你的本地仓库到Github，触发Push事件，脚本会自动开始。在仓库的Action页面下即可查看具体过程的情况。\n\n## 最后\n\n自此，相信你已经对Github Action有了一个基本的了解。现在，你已经可以开始尝试通过[Marketplace](https://github.com/marketplace?type=actions)搜索你感兴趣的Action并使用，或者参考[官方文档](https://docs.github.com/en/actions)自行编写一个Action了。\n","\n## 序言\n\n之前一直对webpack都是拿来即用，从来没去了解一些基本概念，Getting Started也没看过。\n\n所以今天看了一下文档，了解了一下基本概念，就简单做个记录。\n\n:::tip\n该文章仅介绍一些基础概念和入门案例，更多请查看官方文档。\n\n[英文原版](https://webpack.js.org/)\n\n[中文版](https://webpack.docschina.org/)\n:::\n\n## 什么是webpack\n\n本质上，**webpack** 是一个用于现代 JavaScript 应用程序的 *静态模块打包工具*。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 *bundle*。\n\n## 一些核心概念\n\n主要是以下几个keywords\n\n- Entry\n- Output\n- Loaders\n- Plugins\n- Mode\n- Browser Compatibility\n\n### Entry\n\n用于指定一个入口js文件作为依赖图的开始。\n\n```js\nmodule.exports = {\n  entry: './path/to/my/entry/file.js',\n};\n```\n\n### Output\n\n告诉 webpack 在哪里输出它所创建的 *bundle*，以及如何命名这些文件。\n\n主要输出文件的默认值是 `./dist/main.js`，其他生成文件默认放置在 `./dist` 文件夹中。\n\n```js\nconst path = require('path');\n\nmodule.exports = {\n  entry: './path/to/my/entry/file.js',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'my-first-webpack.bundle.js',\n  },\n};\n```\n\n### loader\n\n让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，并将其添加到依赖图。\n\n默认可处理JavaScript 和 JSON 文件。\n\nloader由两个属性组成：\n\n1. `test` 属性，识别出哪些文件会被转换。\n2. `use` 属性，定义出在进行转换时，应该使用哪个 loader。\n\n```js\nconst path = require('path');\n\nmodule.exports = {\n  output: {\n    filename: 'my-first-webpack.bundle.js',\n  },\n  module: {\n    rules: [{ test: /\\.txt$/, use: 'raw-loader' }],\n  },\n};\n```\n\n以上配置中，对一个单独的 module 对象定义了 `rules` 属性，里面包含两个必须属性：`test` 和 `use`。这告诉 webpack 编译器(compiler) 如下信息：\n\n> “嘿，webpack 编译器，当你碰到「在 `require()`/`import` 语句中被解析为 '.txt' 的路径」时，在你对它打包之前，先 **use(使用)** `raw-loader` 转换一下。”\n\n### Plugin\n\n插件可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。\n\n想要使用一个插件，你只需要 `require()` 它，然后把它添加到 `plugins` 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 `new` 操作符来创建一个插件实例。\n\n```js\nconst HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装\nconst webpack = require('webpack'); // 用于访问内置插件\n\nmodule.exports = {\n  module: {\n    rules: [{ test: /\\.txt$/, use: 'raw-loader' }],\n  },\n  plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })],\n};\n```\n\n在上面的示例中，`html-webpack-plugin` 为应用程序生成一个 HTML 文件，并自动注入所有生成的 bundle。\n\n### Mode\n\n通过选择 `development`, `production` 或 `none` 之中的一个，来设置 `mode` 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 `production`。\n\n```js\nmodule.exports = {\n  mode: 'production',\n};\n```\n\n### Browser Compatibility\n\nwebpack 支持所有符合 [ES5 标准](https://kangax.github.io/compat-table/es5/) 的浏览器（不支持 IE8 及以下版本）。webpack 的 `import()` 和 `require.ensure()` 需要 `Promise`。如果你想要支持旧版本浏览器，在使用这些表达式之前，还需要 [提前加载 polyfill](https://webpack.docschina.org/guides/shimming/)。\n\n## Getting Started\n\n### 基本安装\n\n执行以下命令\n\n```bash\nmkdir webpack-demo\ncd webpack-demo\nnpm init -y\nnpm install webpack webpack-cli --save-dev\n```\n\n创建以下目录结构\n\n**project**\n\n```diff\n  webpack-demo\n  |- package.json\n+ |- index.html\n+ |- /src\n+   |- index.js\n```\n\n**src/index.js**\n\n```javascript\nfunction component() {\n  const element = document.createElement('div');\n\n  // lodash（目前通过一个 script 引入）对于执行这一行是必需的\n  element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n\n  return element;\n}\n\ndocument.body.appendChild(component());\n```\n\n**index.html**\n\n```html\n\u003C!DOCTYPE html>\n\u003Chtml>\n  \u003Chead>\n    \u003Cmeta charset=\"utf-8\" />\n    \u003Ctitle>起步\u003C/title>\n    \u003Cscript src=\"https://unpkg.com/lodash@4.17.20\">\u003C/script>\n  \u003C/head>\n  \u003Cbody>\n    \u003Cscript src=\"./src/index.js\">\u003C/script>\n  \u003C/body>\n\u003C/html>\n```\n\n> [Lodash](https://lodash.com/) 是一个一致性、模块化、高性能的 JavaScript 实用工具库。\n\n我们还需要调整 `package.json` 文件，以便确保我们安装包是 `private(私有的)`，并且移除 `main` 入口。这可以防止意外发布你的代码。\n\n**package.json**\n\n```diff\n {\n   \"name\": \"webpack-demo\",\n   \"version\": \"1.0.0\",\n   \"description\": \"\",\n-  \"main\": \"index.js\",\n+  \"private\": true,\n   \"scripts\": {\n     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n   },\n   \"keywords\": [],\n   \"author\": \"\",\n   \"license\": \"ISC\",\n   \"devDependencies\": {\n     \"webpack\": \"^5.4.0\",\n     \"webpack-cli\": \"^4.2.0\"\n   }\n }\n```\n\n### 创建一个 bundle\n\n修改目录结构\n\n```diff\n  webpack-demo\n  |- package.json\n+ |- /dist\n+   |- index.html\n- |- index.html\n  |- /src\n    |- index.js\n```\n\n本地安装lodash\n\n```bash\nnpm install --save lodash\n```\n\n> 在安装一个 要打包到生产环境 bundle 中的package时，，你应该使用 `npm install --save`。如果你在安装一个用于开发环境的 package 时（例如，linter, 测试库等），你应该使用 `npm install --save-dev`。更多信息请查看 [npm 文档](https://docs.npmjs.com/cli/install)。\n\n现在，在我们的 script 中 import `lodash`：\n\n**src/index.js**\n\n```diff\n+import _ from 'lodash';\n+\n function component() {\n   const element = document.createElement('div');\n\n-  // lodash（目前通过一个 script 引入）对于执行这一行是必需的\n+  // lodash 在当前 script 中使用 import 引入\n   element.innerHTML = _.join(['Hello', 'webpack'], ' ');\n\n   return element;\n }\n\n document.body.appendChild(component());\n```\n\n现在，我们将会打包所有脚本，我们必须更新 `index.html` 文件。由于现在是通过 `import` 引入 lodash，所以要将 lodash `\u003Cscript>` 删除，然后修改另一个 `\u003Cscript>` 标签来加载 bundle，而不是原始的 `./src` 文件：\n\n**dist/index.html**\n\n```diff\n \u003C!DOCTYPE html>\n \u003Chtml>\n   \u003Chead>\n     \u003Cmeta charset=\"utf-8\" />\n     \u003Ctitle>起步\u003C/title>\n-    \u003Cscript src=\"https://unpkg.com/lodash@4.17.20\">\u003C/script>\n   \u003C/head>\n   \u003Cbody>\n-    \u003Cscript src=\"./src/index.js\">\u003C/script>\n+    \u003Cscript src=\"main.js\">\u003C/script>\n   \u003C/body>\n \u003C/html>\n```\n\n执行 `npx webpack`，然后打开`dist/index.html`，应该就能看到hello webpack了。说明import的js也被打包进去了。\n\n:::warning\n直接运行html出现main.js语法错误，使用vscode open with live server却发现一切正常\n\n初步怀疑是js等级问题，后来f12查看js，发现出现乱码，查看html编码，果然有问题，不知道为什么是utf-16，而js编码为utf-8，遂修改html编码为utf-8，问题解决\n:::\n\n### 模块\n\nES2015（ES6的第一个版本）的`import`和`export`已十分常见，但是很多浏览器却不能支持，所以webpack默认会将一些模块的语法转换成浏览器可以兼容的方式。除了`export`和`import`，webpack还支持更多信息查看[模块API](https://webpack.docschina.org/api/module-methods)\n\n:::warning\nwebpack 不会更改代码中除 `import` 和 `export` 语句以外的部分。如果你在使用其它 [ES2015 特性](http://es6-features.org/)，请确保你在 webpack [loader 系统](https://webpack.docschina.org/concepts/loaders/) 中使用了一个像是 [Babel](https://babel.docschina.org/) 或 [Bublé](https://buble.surge.sh/guide/) 的 [transpiler(转译器)](https://webpack.docschina.org/loaders/#transpiling)。\n:::\n\n## 使用一个配置文件\n\n在以下目录创建配置文件，`webpack.config.js`\n\n```diff\n webpack-demo\n  |- package.json\n+ |- webpack.config.js\n  |- /dist\n    |- index.html\n  |- /src\n    |- index.js\n```\n\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  entry: './src/index.js',\n  output: {\n    filename: 'main.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};\n```\n\n执行`npx webpack --config webpack.config.js`，成功构建。\n\n:::tip\n`--config`只是表明可以指定配置文件，缺省值为webpack.config.js，也就是以上的--config可以被省略\n:::\n\n## npm scripts\n\n一般情况，我们会将webpack的脚本配置到npm的script中。\n\n**package.json**\n\n```diff\n\"scripts\": {\n     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n+    \"build\": \"webpack\"\n   },\n```\n\n现在，我们就可以直接执行`npm run build`来进行打包了。\n\n:::tip\n可以通过在 npm run build 命令与参数之间添加两个连接符的方式向 webpack 传递自定义参数，例如：npm run build -- --color。\n\n也可以在build script中webpack后加上自定义参数\n:::\n\n## 管理资源\n\n为了在 JavaScript 模块中 import 一个 CSS 文件，你需要安装 style-loader 和 css-loader，并在 module 配置 中添加这些 loader：\n\n```bash\nnpm install --save-dev style-loader css-loader\n```\n\n同时配置**webpack.config.js**\n\n```diff\n const path = require('path');\n\n module.exports = {\n   entry: './src/index.js',\n   output: {\n     filename: 'bundle.js',\n     path: path.resolve(__dirname, 'dist'),\n   },\n+  module: {\n+    rules: [\n+      {\n+        test: /\\.css$/i,\n+        use: ['style-loader', 'css-loader'],\n+      },\n+    ],\n+  },\n };\n```\n\n这样，项目依赖的CSS将会被打包。\n\n更多资源类型参考[官方文档-管理资源](https://webpack.docschina.org/guides/asset-management/)。\n\n## 最后\n\n至此，webpack的入门可以告一段落了，有些这些基本概念和使用方式，相信已经能够让初学者初步使用webpack了。\n\n","\r\n## 序言\r\n\r\nBabel是JavaScript的编译器，主要用于转换ECMAScript 2015+ 的代码，使之可以在各种环境正常运行。用户完全可以使用最新的ECMAScript语法而完全无需担心浏览器是否支持的问题。\r\n\r\n## 使用指南\r\n\r\n按照惯例，这里依旧采取一个简单的案例来帮助我们更好的理解和使用Babel。\r\n\r\n案例主要介绍如何通过Babel的命令行工具转换EMCAScript 2015+的语法至更低的等级。\r\n\r\n首先是Babel的安装\r\n\r\n```bash\r\nnpm install --save-dev @babel/core @babel/cli @babel/preset-env\r\n```\r\n\r\n创建Babel的配置文件，`babel.config.json`\r\n\r\n```json\r\n{\r\n  \"presets\": [\r\n    [\r\n      \"@babel/env\",\r\n      {\r\n        \"targets\": {\r\n          \"edge\": \"17\",\r\n          \"firefox\": \"60\",\r\n          \"chrome\": \"67\",\r\n          \"safari\": \"11.1\"\r\n        },\r\n        \"useBuiltIns\": \"usage\", // 当此参数设置为 \"usage\" 时，就会加载上面所提到的最后一个优化措施，也就是只包含你所需要的 polyfill。\r\n        \"corejs\": \"3.6.5\"\r\n      }\r\n    ]\r\n  ]\r\n}\r\n```\r\n\r\n现在新建一个`src`和`lib`目录，并在`src`目录下新建一个`main.js`文件，内容如下：\r\n\r\n```js\r\nconst x = (x, y) => x * y\r\n```\r\n\r\n通过npx执行babel命令，将src下的文件进行转化并输出到lib目录\r\n\r\n```bash\r\nnpx babel src --out-dir lib --presets=@babel/env\r\n```\r\n\r\n现在你可以打开lib目录，查看转换之后的代码了。\r\n\r\n## 基础概念\r\n\r\n虽然案例看起来十分简单易用，但是了解一些基础概念会让你更好理解Babel。\r\n\r\n在上述案例中，我们安装了`@babel/core` `@babel/cli` `@babel/preset-env`这三个包。\r\n\r\n其中core是核心，cli是命令行工具（*没有cli就需要使用api进行转换*），这两个都很好理解，关键是preset-env是什么？\r\n\r\n**预设**（**preset**）是一些插件的集合，`@babel/preset-env`是个官方的预设，它已经自动帮我们配置了许多插件。例如箭头函数转换。\r\n\r\n> 在没有预设的情况下，你需要自己安装很多插件。\r\n\r\n> 你可以分享自己的插件集合为预设。\r\n\r\n**Polyfill**：`@babel/polyfill` 模块包含 core-js 和一个自定义的 regenerator runtime 来模拟完整的 ES2015+ 环境。\r\n\r\n> Babel默认只转换语法（syntax），而不转换API，所以需要polyfill来让浏览器支持API，而不是出现xxx is not a function。\r\n\r\n这意味着你可以使用诸如 `Promise` 和 `WeakMap` 之类的新的内置组件、 `Array.from` 或 `Object.assign` 之类的静态方法、 `Array.prototype.includes` 之类的实例方法以及生成器函数（generator functions）（前提是你使用了 regenerator 插件）。\r\n\r\n对于一些人来说，可能不会使用到这么多特性，所以`preset-env`提供了一个参数**useBuiltIns**，当此参数设置为 **usage** 时，Babel 将检查你的所有代码，以便查找目标环境中缺失的功能，然后只把必须的 polyfill 包含进来。\r\n\r\n> 从 Babel 7.4.0 版本开始，这个软件包已经不建议使用了，建议直接包含 `core-js/stable` （用于模拟 ECMAScript 的功能）和 `regenerator-runtime/runtime` 需要使用转译后的生成器函数）：\r\n\r\n想了解更多preset可以查看[https://babeljs.io/docs/en/babel-preset-env](https://babeljs.io/docs/en/babel-preset-env)\r\n\r\n## webpack & babel\r\n\r\n以下是webpack使用babel的指南。\r\n\r\n安装loader\r\n\r\n```bash\r\nnpm install --save-dev babel-loader @babel/core\r\n```\r\n\r\n安装预设\r\n\r\n```bash\r\nnpm install @babel/preset-env --save-dev\r\n```\r\n\r\n`webpack.config.js`\r\n\r\n```js\r\n{\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.m?js$/,\r\n        exclude: /node_modules/,\r\n        use: {\r\n          loader: \"babel-loader\",\r\n          options: {\r\n            presets: ['@babel/preset-env']\r\n          }\r\n        }\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nFor more information see the [babel/babel-loader repo](https://github.com/babel/babel-loader).\r\n\r\n`babel.config.json`\r\n\r\n```diff\r\n    const path = require('path');\r\n\r\n    module.exports = {\r\n      entry: './src/index.js',\r\n      output: {\r\n        filename: 'main.js',\r\n        path: path.resolve(__dirname, 'dist'),\r\n      },\r\n      mode: 'development',\r\n      module: {\r\n+        rules: [\r\n+          {\r\n+            test: /\\.m?js$/,\r\n+            exclude: /node_modules/,\r\n+            use: {\r\n+              loader: \"babel-loader\",\r\n+              options: {\r\n+                presets: ['@babel/preset-env'\r\n+                ]\r\n+              }\r\n+            }\r\n+          }\r\n+        ]\r\n      }\r\n    };\r\n```\r\n\r\n`babel.config.json`\r\n\r\n```json\r\n{\r\n  \"presets\": [\"@babel/preset-env\"]\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n更多细节参考[官方文档](https://babeljs.io/)\r\n\r\n","\n## 前言\n\nDruid是阿里开源的一个Java数据库连接池，能够提供强大的监控和扩展功能。\n\nDruid主要分为三个部分\n\n1. DruidDriver：代替默认的Database Driver\n2. DruidDataSource：数据库连接池部分\n3. SQLParser：SQL分析\n\n:::warning\nApache下同样有个项目叫Druid，那个Druid是一个高性能实时分析数据库。\n:::\n\n## 与SpringBoot的集成\n\n以下将通过一个案例展示Druid与SpringBoot的继承。\n\npom.xml\n\n``` xml\n\u003Cdependency>\n    \u003CgroupId>com.alibaba\u003C/groupId>\n    \u003CartifactId>druid-spring-boot-starter\u003C/artifactId>\n\u003C/dependency>\n```\n[https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter](https://mvnrepository.com/artifact/com.alibaba/druid-spring-boot-starter) 自行选择版本\n\napplication.yml\n\n```yaml\nspring:\n  datasource:\n    username: xxx\n    password: xxx\n    driver-class-name: x\n    url: xxx\n    type: com.alibaba.druid.pool.DruidDataSource\n    druid:\n      initial-size: 5\n      min-idle: 5\n      max-active: 20\n      test-while-idle: true\n      test-on-borrow: false\n      test-on-return: false\n      pool-prepared-statements: true\n      max-pool-prepared-statement-per-connection-size: 20\n      max-wait: 60000\n      time-between-eviction-runs-millis: 60000\n      min-evictable-idle-time-millis: 30000\n      filters: stat\n      async-init: true\n      stat-view-servlet:\n        login-username: druid\n        login-password: 123456\n```\n\n配置了登录的用户名密码，悉知。其他配置可以参考文末的参考文档。\n\n默认的监控页面：`http://host:port/druid/webapp.html` (host：域名/IP，port：端口号)，打开之后输入用户名密码应该可以看到以下类似的监控页面。\n\n![image-20210518214400455](https://cdn.jsdelivr.net/gh/alightyoung/static/img/20210519102624.png)\n\n## 最后\n\n:::tip{text=\"参考文档\"}\n[https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter](https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter)\n\n[https://www.oschina.net/p/druid?hmsr=aladdin1e1](https://www.oschina.net/p/druid?hmsr=aladdin1e1)\n\n[https://juejin.cn/post/6844904190909628429](https://juejin.cn/post/6844904190909628429)\n:::\n","\n## 简介\n\nECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 [ZRender](https://github.com/ecomfe/zrender)，提供直观，交互丰富，可高度个性化定制的数据可视化图表。\n\nEcharts不仅提供了常见条形图，折线图，扇形图等数十种类型的图，还支持自定义图，基本可以涵盖你所有的需求。\n\n## 快速入门\n\n最简单的了解方式就是通过一个案例。（Vue2环境 + Echarts5）\n\n1 下载安装\n\n```shell\nnpm install echarts --save\n```\n\n2 在main.js引用并定义全局变量\n\n```js\n// import echarts from 'echarts' // 5.0-方式\nimport * as echarts from 'echarts' // 5.0+方式\nVue.prototype.$echarts = echarts\n```\n\n:::tip\n这里为了快速上手直接引用了全部的组件，通常情况下，我们都会选择按需引用，这点在之后会说明。\n:::\n\n3 在组件中创建一个容器用于展示图\n\n```html\n\u003Cdiv id=\"main\" :style=\"{ width: '800px', height: '300px' }\">\u003C/div>\n```\n\n4 在mounted函数中进行图的初始化创建\n\n```js\nvar chartDom = document.getElementById('main');\nvar myChart = this.$echarts.init(chartDom);\nvar option;\n\noption = {\n    xAxis: {\n        type: 'category',\n        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']\n    },\n    yAxis: {\n        type: 'value'\n    },\n    series: [{\n        data: [120, 200, 150, 80, 70, 110, 130],\n        type: 'bar'\n    }]\n};\n\noption && myChart.setOption(option);\n```\n\n这样一个最简单的柱状图案例就完成了。你可以在Echarts的官网上找到更多案例，并且每个案例都可选择按需引用的方式。[传送门](https://echarts.apache.org/examples/zh/index.html)\n\n\n## 最后\n\nEcharts的介绍至此结束，这里只是简单的了解，以后再填坑。\n","\n## 简介\n\nMock.js 是一个**模拟数据生成器**，帮助前端开发和原型与后端进程分离，减少一些单调的工作，特别是在编写自动化测试时。\n\n简单来说，你可以利用它来生成大量测试数据，并且你还可以拦截Ajax请求，返回格式正确的测试数据。\n\n## 快速上手\n\n照例编写一个简单的例子。(依旧是vue2环境)\n\n1 下载安装\n\n```sh\nnpm install mockjs -S\n```\n\n2 main.js引用并定义全局变量，这里还使用了axios发送请求，用于测试mockjs的ajax拦截功能。\n\n```js\nimport Mock from 'mockjs'\nimport axios from 'axios'\n\nVue.prototype.$mock = Mock\nVue.prototype.$axios = axios\n```\n\n3 在组件中使用mockjs\n\n```js\n  data() {\n    return {\n      provinces: [],\n    };\n  },\n  mounted() {\n    var data = this.$mock.mock('province',{\n      \"list|10\": [\"@province\"],\n    });\n    this.$axios.get('province').then(res=>{\n      this.provinces = res.data.list;\n      console.log(this.province)\n    })\n  }\n```\n\n查看控制台，发现已经自动生成了10个随机省份。\n\n## 核心概念与函数\n\n在上面的案例中，我们已经使用过了mock函数，接下来主要详细解析一下这些函数。\n\n### Mock.mock\n\n`Mock.mock( rurl?, rtype?, template|function( options ) )`\n\n该函数可根据参数的组合分为以下几种情况：\n\n- `Mock.mock(template)` ：根据数据模板生成模拟数据。\n- `Mock.mock(rurl,template)` ：记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。\n- `Mock.mock(rurl,function(options))` ：记录用于生成响应数据的函数。当拦截到匹配 rurl 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。\n- `Mock.mock(rurl,rtype,template)` ：记录数据模板。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。\n- `Mock.mock(rurl,rtype,function(options))` ：记录用于生成响应数据的函数。当拦截到匹配 rurl 和 rtype 的 Ajax 请求时，函数 function(options) 将被执行，并把执行结果作为响应数据返回。\n\n### Mock.Random\n\nMock.Random 是一个工具类，用于生成各种随机数据。\n\n在上述示例代码中，用到的`@province`其实就是『占位符』。\n\nMock.Random 的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数 [, 参数]) 。\n\n### 数据模板\n\n数据模板，就是之前我们示例代码中的`{\"list|10\": [\"@province\"],}`，该模板定义了一个对象，其中有一个list属性，该属性会生辰10个随机省份。\n\n因为数据模板的类型十分丰富，这里也不可能一一列举，附上官方网站示例页面，[传送门](http://mockjs.com/examples.html)。\n\n\n## 最后\n\nMockjs的基本用法差不多就是这些了，其中还有一些函数或者其他点没有说明是因为暂时没用上。\n\n所以这里也一并附上官方Github wiki和文档站。需要的可以自行查阅。\n\n:::tip\nGithub : [https://github.com/nuysoft/Mock](https://github.com/nuysoft/Mock)\n\nWiki : [https://github.com/nuysoft/Mock/wiki](https://github.com/nuysoft/Mock/wiki)\n\nOfficial Doc : [http://mockjs.com/](http://mockjs.com/)\n:::\n\n","\n## 简介\n\nSpring Cloud Alibaba旨在为微服务开发提供一站式解决方案。\n\n说到Spring Cloud Alibaba就不得不提到Dubbo，Dubbo 项目诞生于 2008 年，然后在2014年停更，最后又在2017年重获新生，可谓是一波三折。\n\n:::tip\n想了解Dubbo的故事可以看看：[Dubbo作者亲述：那些辉煌、沉寂与重生的故事](https://zhuanlan.zhihu.com/p/53935365)\n:::\n\n接着在2018年，Spring Cloud Alibaba正式进入Spring Cloud官方孵化器，并在Maven中央库发布了第一个版本。\n\n正好Netflix的一些组件（Spring Cloud官方整合的组件很多是Netflix开源的，比如Eureka、Zuul、Hystrix等）也不再维护，所以学习Spring Cloud Alibaba也就提上日程了。\n\n以下案例均采用`Spring Cloud Alibaba 2.2.1.RELEASE`版本\n\n[版本说明参考](https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E)\n\n**pom.xml**\n\n```xml\n\u003CdependencyManagement>\n    \u003Cdependencies>\n        \u003Cdependency>\n            \u003CgroupId>com.alibaba.cloud\u003C/groupId>\n            \u003CartifactId>spring-cloud-alibaba-dependencies\u003C/artifactId>\n            \u003Cversion>2.2.1.RELEASE\u003C/version>\n            \u003Ctype>pom\u003C/type>\n            \u003Cscope>import\u003C/scope>\n        \u003C/dependency>\n    \u003C/dependencies>\n\u003C/dependencyManagement>\n```\n\n## 核心组件\n\n1. Nacos：服务发现与注册、分布式配置。\n2. Dubbo：服务调用\n3. Sentinel：服务熔断\n4. Seate：分布式事务\n5. RocketMQ：分布式消息\n\n## Nacos\n\nNacos 是一个易于使用的动态服务发现、配置和服务管理平台，用于构建云原生应用\n\n[Nacos Spring Cloud 快速开始](https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html)\n\n### 服务端下载及运行\n\n1 下载nacos服务端，你有以下两种方式获取\n\n   - 下载编译好的压缩包 - [https://github.com/alibaba/nacos/releases](https://github.com/alibaba/nacos/releases)\n\n   - 下载源码自己编译\n\n```sh\ngit clone https://github.com/alibaba/nacos.git\ncd nacos/\nmvn -Prelease-nacos -Dmaven.test.skip=true clean install -U\nls -al distribution/target/\n\n// change the $version to your actual path\ncd distribution/target/nacos-server-$version/nacos/bin\n```\n\n2 启动Nacos服务端\n\n   **以下命令均在bin目录中**\n\n   **Linux/Unix/Mac**\n\n   启动命令(standalone代表着单机模式运行，非集群模式):\n\n```sh\nsh startup.sh -m standalone\n```\n\n:::warning\n如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：`bash startup.sh -m standalone`\n:::\n\n**Windows**\n\n启动命令(standalone代表着单机模式运行，非集群模式):\n\n```sh\nstartup.cmd -m standalone\n```\n\n需要关闭则使用`shutdown`命令即可。\n\n### Nacos配置管理\n\n在Nacos server启动之后便可以通过ip+端口打开nacos web页面了，用户名密码均为nacos。\n\n进入管理界面添加一个配置文件，dataID为`nacosconfig`\n\n配置如下\n\n```yaml\nuseLocalCache: test\n```\n\n记得发布。\n\n**代码中获取nacos的配置**\n\n**`pom.xml`**（默认已经添加`springcloud` / `springboot`）\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>com.alibaba.cloud\u003C/groupId>\n    \u003CartifactId>spring-cloud-starter-alibaba-nacos-config\u003C/artifactId>\n\u003C/dependency>\n```\n\n**`bootstrap.properties`**（`bootstrap.properties`先于 `application.properties` 加载）\n\n```properties\n# 服务端的ip端口\nspring.cloud.nacos.config.server-addr=192.168.191.1:8848\n# dataID，用于确定配置\nspring.application.name=nacosconfig\n# 配置文件格式\nspring.cloud.nacos.config.file-extension=yaml\n```\n\n**`ConfigController`**\n\n```java\n@RestController\n@RequestMapping(\"/config\")\n@RefreshScope // Spring Cloud 原生注解，实现配置自动更新\npublic class ConfigController {\n\n    @Value(\"${useLocalCache:''}\")\n    private String useLocalCache;\n\n    @RequestMapping(\"/get\")\n    public String get() {\n        return useLocalCache;\n    }\n}\n```\n\n启动SpringBoot主程序，查看`/config/get`接口，发现可以获取远程配置。回到nacos web管理界面修改test为test1，刷新接口，发现值已自动修改。\n\n### Nacos服务发现与注册\n\n启动Nacos Server\n\n首先创建两个模块，一个为服务提供者，另一个为服务消费者。\n\n在服务提供端和服务消费端均添加`spring-cloud-starter-alibaba-nacos-discovery`依赖，默认已添加SpringBoot依赖\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>com.alibaba.cloud\u003C/groupId>\n    \u003CartifactId>spring-cloud-starter-alibaba-nacos-discovery\u003C/artifactId>\n\u003C/dependency>\n```\n\n服务提供端 `application.propertiies`\n\n```properties\nserver.port=8070\nspring.application.name=service-provider\n\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\n```\n\n服务提供端 SpringBoot启动类\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class NacosProviderApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(NacosProviderApplication.class, args);\n\t}\n\n\t@RestController\n\tclass EchoController {\n\t\t@RequestMapping(value = \"/echo/{string}\", method = RequestMethod.GET)\n\t\tpublic String echo(@PathVariable String string) {\n\t\t\treturn \"Hello Nacos Discovery \" + string;\n\t\t}\n\t}\n}\n```\n\n服务消费端 `application.propertiies`\n\n```properties\nserver.port=8080\nspring.application.name=service-consumer\n\nspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848\n```\n\n服务消费端 SpringBoot启动类\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class NacosConsumerApplication {\n\n    @LoadBalanced\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(NacosConsumerApplication.class, args);\n    }\n\n    @RestController\n    public class TestController {\n\n        private final RestTemplate restTemplate;\n\n        @Autowired\n        public TestController(RestTemplate restTemplate) {this.restTemplate = restTemplate;}\n\n        @RequestMapping(value = \"/echo/{str}\", method = RequestMethod.GET)\n        public String echo(@PathVariable String str) {\n            return restTemplate.getForObject(\"http://service-provider/echo/\" + str, String.class);\n        }\n    }\n}\n```\n\n最后，启动 `ProviderApplication` 和 `ConsumerApplication` ，调用 [http://localhost:8080/echo/2018](http://localhost:8080/echo/2018)，返回内容为 Hello Nacos Discovery 2018。\n\n此时也可以打开**Nacos web管理界面**地址，查看服务列表。\n\n## Sentinel\n\nSentinel 以**流量**为切入点，从**流量控制**、**熔断降级**、**系统负载保护**等多个维度保护服务的稳定性。\n\n### WebFlux简介\n\n在介绍Sentinel之前，我想提一下Spring WebFlux（仅了解一下概念），因为Sentinel目前已经支持Spring WebFlux，而该框架是Spring 5推出的一个的非阻塞，响应式Web框架\n\n:::tip\n响应式编程（reactive programming）是一种基于数据流（data stream）和变化传递（propagation of change）的声明式（declarative）的编程范式。\n:::\n\n该框架类似于Spring MVC，不同之处在于它是非阻塞、响应式的Web框架，因此相较于Spring MVC，Spring WebFlux有着很大的性能优势。这并不意味着你需要马上切换到Spring WebFlux，因为响应式编程就意味着它会和许多以前阻塞式框架搭配起来不工作或者效果很差（可以但没有必要），但如果你觉得你已经完成准备好了应付非阻塞式系统及响应式编程，并且你的系统确实能通过它提升巨大的性能，就可以考虑切换到响应式编程的分支来。\n\n另外Spring WebFlux提升的并不是单个接口的响应速率，而是提高整个系统的吞吐量。\n\n举个例子，假设一个接口正在等待一个需要非常长时间才能响应的处理（访问大文件或者数据库全表查询之类），对于阻塞式的架构来说，此时线程卡在这里但是什么事也干不了，但对于非阻塞式架构，它就可以在此时将线程使用权让出来交给其它请求去使用。\n\n限于篇幅，这里不多赘述，有个基本概念就好。\n\n对于想从Spring MVC切换到Spring WebFlux的SpringBoot用户来说，只需要将artifactId从`spring-boot-starter-web`改成`spring-boot-starter-webflux`即可。\n\n:::warning{text=\"注意\"}\n\n在Spring MVC模式下，默认采用Servlet + Tomcat\n\n而在Spring WebFlux下，默认采用Reactor + Netty\n:::\n\n### Quick Start\n\nSentinel提供了两种方式来进行接入，一种是无侵入式接入，另一个则是代码手动接入。\n\n:::details{text=\"无侵入接入\"}\n\n*若希望无侵入将已有服务接入 Sentinel 来快速体验 Sentinel 全方位的流量防护和可观测能力，推荐采用 [Java Agent 方式](https://help.aliyun.com/document_detail/102506.html)快速、无侵入将应用接入到[云上 AHAS 控制台](https://github.com/alibaba/Sentinel/wiki/AHAS-Sentinel-控制台)来体验 Sentinel 的能力。*\n\n:::\n\n:::details{text=\"代码手动接入\"}\n\n首先引入依赖\n\n```xml\n\u003Cdependency>\n    \u003CgroupId>com.alibaba.cloud\u003C/groupId>\n    \u003CartifactId>spring-cloud-starter-alibaba-sentinel\u003C/artifactId>\n\u003C/dependency>\n```\n\n通过`@SentinelResource`标识Sentinel资源，最常见的就是方法。\n\n```java\npublic class TestService {\n\n    // 原函数\n    @SentinelResource(value = \"hello\", blockHandler = \"exceptionHandler\", fallback = \"helloFallback\")\n    public String hello(long s) {\n        return String.format(\"Hello at %d\", s);\n    }\n\n    // Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数.\n    public String helloFallback(long s) {\n        return String.format(\"Halooooo %d\", s);\n    }\n\n    // Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致.\n    public String exceptionHandler(long s, BlockException ex) {\n        // Do some log here.\n        ex.printStackTrace();\n        return \"Oops, error occurred at \" + s;\n    }\n\n    // 这里单独演示 blockHandlerClass 的配置.\n    // 对应的 `handleException` 函数需要位于 `ExceptionUtil` 类中，并且必须为 public static 函数.\n    @SentinelResource(value = \"test\", blockHandler = \"handleException\", blockHandlerClass = {ExceptionUtil.class})\n    public void test() {\n        System.out.println(\"Test\");\n    }\n}\n```\n\n细节参考，[Sentinel注解支持](https://github.com/alibaba/Sentinel/wiki/%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81)\n:::\n\n:::details{text=\"控制面板\"}\n\n从 [release 页面](https://github.com/alibaba/Sentinel/releases) 下载最新版本的控制台 jar 包。\n\n启动 （这里命令没有加上版本，自行删掉下载jar的版本号或者给命令加上版本）\n\n``` sh\njava -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar\n```\n\n从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的**登录**功能，默认用户名和密码都是 `sentinel`。可以参考 [鉴权模块文档](https://github.com/alibaba/Sentinel/wiki/控制台#鉴权) 配置用户名和密码。\n\n`application.properties`\n\n```properties\nspring.cloud.sentinel.transport.port=8719\nspring.cloud.sentinel.transport.dashboard=localhost:8080\n```\n\n**确保客户端有访问量**，Sentinel 会在**客户端首次调用的时候**进行初始化，开始向控制台发送心跳包。\n\n更多细节参考[Sentinel控制面板](https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0)\n\n:::\n\n主流框架整合Demo：[Github仓库](https://github.com/alibaba/Sentinel/tree/master/sentinel-demo)。\n\n文档参考：[官方文档站](https://sentinelguard.io/)，[Github Wiki](https://github.com/alibaba/Sentinel/wiki)，[Spring Cloud Alibaba #Sentinel](https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html#_spring_cloud_alibaba_sentinel)\n\n","\n\u003CBadge text=\"简单\" type=\"tip\"/>\n\n原题链接：[https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)\n\n## 题目描述\n\n给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 `ranges[i] = [starti, endi]` 表示一个从 starti 到 endi 的 闭区间 。\n\n如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。\n\n已知区间 `ranges[i] = [starti, endi]` ，如果整数 x 满足 `starti \u003C= x \u003C= endi` ，那么我们称整数x 被覆盖了。\n\n:::details{text=\"示例 1\"}\n输入：ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n\n输出：true\n\n解释：2 到 5 的每个整数都被覆盖了：\n\n- 2 被第一个区间覆盖。\n- 3 和 4 被第二个区间覆盖。\n- 5 被第三个区间覆盖。\n:::\n\n:::details{text=\"示例 2\"}\n输入：ranges = [[1,10],[10,20]], left = 21, right = 21\n\n输出：false\n\n解释：21 没有被任何一个区间覆盖。\n:::\n\n:::details{text=\"提示\"}\n\n`1 \u003C= ranges.length \u003C= 50`\n\n`1 \u003C= starti \u003C= endi \u003C= 50`\n\n`1 \u003C= left \u003C= right \u003C= 50`\n:::\n\n\n## Python题解\n\n### 个人题解\n\n只会暴力解 - -\n\n```python\nclass Solution(object):\n    def isCovered(self, ranges, left, right):\n        \"\"\"\n        :type ranges: List[List[int]]\n        :type left: int\n        :type right: int\n        :rtype: bool\n        \"\"\"\n        flag = False\n        for i in range(left, right + 1):\n            flag = False\n            for j in ranges:\n                if i in range(j[0], j[1] + 1):\n                    flag = True\n                    break\n            if not flag:\n                return flag\n        return flag\n```\n\n## 总结\n\n其他题解没看,暂时只有暴力解.\n\n\n","\n\u003CBadge text=\"简单\" type=\"tip\"/>\n原题链接：[https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits](https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits)\n\n## 题目描述\n\n给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。\n\n有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。\n\n替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。\n\n:::details{text=\"示例 1\"}\n输入：time = \"2?:?0\"\n\n输出：\"23:50\"\n\n解释：以数字 '2' 开头的最晚一小时是 23 ，以 '0' 结尾的最晚一分钟是 50 。\n:::\n\n:::details{text=\"示例 2\"}\n输入：time = \"0?:3?\"\n\n输出：\"09:39\"\n:::\n\n:::details{text=\"示例 3\"}\n输入：time = \"1?:22\"\n\n输出：\"19:22\"\n:::\n\n:::details{text=\"提示\"}\ntime 的格式为 hh:mm\n\n题目数据保证你可以由输入的字符串生成有效的时间\n:::\n\n## Python题解\n\n### 个人题解\n\n经典暴力解\n\n``` Python\nclass Solution(object):\n    def maximumTime(self, time):\n        \"\"\"\n        :type time: str\n        :rtype: str\n        \"\"\"\n        h1, h2, m1, m2 = time[0], time[1], time[3], time[4]\n        if h1 == '?' and h2 == '?':\n            h1, h2 = '2', '3'\n        elif h1 == '?':\n            if int(h2) >= 4:\n                h1 = '1'\n            else:\n                h1 = '2'\n        elif h2 == '?':\n            if int(h1) \u003C 2:\n                h2 = '9'\n            else:\n                h2 = '3'\n        if m1 == '?': m1 = '5'\n        if m2 == '?': m2 = '9'\n        return h1 + h2 + ':' + m1 + m2\n```\n\n## 总结\n\n看了题解的一些其他解法，写法挺很多，逻辑的可变换性很大。\n","\n\u003CBadge text=\"中等\" type=\"warning\"/>\n原题链接：[https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs](https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs)\n\n## 题目描述\n\n存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。\n\n给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。\n\n题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。\n\n返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。\n\n:::details{text=\"示例 1\"}\n输入：adjacentPairs = [[2,1],[3,4],[3,2]]\n输出：[1,2,3,4]\n解释：数组的所有相邻元素对都在 adjacentPairs 中。\n特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。\n:::\n\n:::details{text=\"示例 2\"}\n输入：adjacentPairs = [[4,-2],[1,4],[-3,1]]\n输出：[-2,4,1,-3]\n解释：数组中可能存在负数。\n另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。\n:::\n\n:::details{text=\"示例 3\"}\n输入：adjacentPairs = [[100000,-100000]]\n输出：[100000,-100000]\n:::\n\n:::details{text=\"提示\"}\nnums.length == n\n\nadjacentPairs.length == n - 1\n\nadjacentPairs[i].length == 2\n\n`2 \u003C= n \u003C= 105`\n\n`-105 \u003C= nums[i], ui, vi \u003C= 105`\n题目数据保证存在一些以 adjacentPairs 作为元素对的数组 nums\n:::\n\n## Python题解\n\n### 参考题解\n\n因为没做出来，而且官方题解没有Python版本，所以就参照Java版本以及社区Python题解修改出了一个300ms的方案，时间100%。\n\n```python\nclass Solution(object):\n    def restoreArray(self, adjacentPairs):\n        \"\"\"\n        :type adjacentPairs: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        dic = defaultdict(list)\n        for a, b in adjacentPairs:\n            dic[a].append(b)\n            dic[b].append(a)\n        res = []\n        for m, n in dic.items():\n            if len(n) == 1:\n                res.append(m)\n                break\n        res.append(dic.get(res[0])[0])\n        for _ in range(2, len(adjacentPairs) + 1):\n            cur = res[-1]\n            res.append(dic[cur][0]) if dic[cur][0] != res[-2] else res.append(dic[cur][1])\n        return res\n```\n\n## 总结\n\n一开始把问题想简单了，没打算递推，准备直接找出头尾排序一下，后来发现行不通。\n\n另一个是完全没想到字典，medium太难了。\n","\n\u003CBadge text=\"简单\" type=\"tip\"/>\n原题链接：[https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree](https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree)\n\n## 题目描述\n\n给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。\n\n更正式地说，root.val = min(root.left.val, root.right.val) 总成立。\n\n给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。\n\n:::details{text=\"示例 1\"}\n![smbt1.jpg](https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg)\n输入：root = [2,2,5,null,null,5,7]\n\n输出：5\n\n解释：最小的值是 2 ，第二小的值是 5 。\n:::\n\n:::details{text=\"示例 2\"}\n![smbt2.jpg](https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg)\n\n输入：root = [2,2,2]\n\n输出：-1\n\n解释：最小的值是 2, 但是不存在第二小的值。\n:::\n\n:::details{text=\"提示\"}\n树中节点数目在范围 [1, 25] 内\n\n`1 \u003C= Node.val \u003C= 231 - 1`\n\n对于树中每个节点 root.val == min(root.left.val, root.right.val)\n:::\n\n## Python题解\n\n### 方法一：深度优先搜索\n\n:::details{text=\"思路&算法&细节&复杂度\"}\n**思路**\n\n根据题目中的描述「如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个」，我们可以知道，对于二叉树中的任意节点 xx，xx 的值不大于其所有子节点的值，因此：\n\n对于二叉树中的任意节点 xx，xx 的值不大于以 xx 为根的子树中所有节点的值。\n\n令 xx 为二叉树的根节点，此时我们可以得出结论：\n\n二叉树根节点的值即为所有节点中的最小值。\n\n因此，我们可以对整棵二叉树进行一次遍历。设根节点的值为 rootvalue，我们只需要通过遍历，找出严格大于 rootvalue 的最小值，即为「所有节点中的第二小的值」。\n\n**算法**\n\n我们可以使用深度优先搜索的方法对二叉树进行遍历。\n\n假设当前遍历到的节点为 node，如果 node 的值严格大于 rootvalue，那么我们就可以用 node 的值来更新答案 ans。\n\n当我们遍历完整棵二叉树后，即可返回 ans。\n\n**细节**\n\n根据题目要求，如果第二小的值不存在的话，输出 -1−1，那么我们可以将 ans 的初始值置为 -1−1。在遍历的过程中，如果当前节点的值严格大于 rootvalue 的节点时，那么只要 ans 的值为 -1−1 或者当前节点的值严格小于 ans，我们就需要对 ans 进行更新。\n\n此外，如果当前节点的值大于等于 ans，那么根据「思路」部分，以当前节点为根的子树中所有节点的值都大于等于 ans，我们就直接回溯，无需对该子树进行遍历。这样做可以省去不必要的遍历过程。\n\n**复杂度分析**：\n\n- 时间复杂度：O(n)O(n)，其中 nn 是二叉树中的节点个数。我们最多需要对整棵二叉树进行一次遍历。\n\n- 空间复杂度：O(n)O(n)。我们使用深度优先搜索的方法进行遍历，需要使用的栈空间为 O(n)O(n)。\n:::\n\n\n题解用的是Python3 `nonlocal`关键字，这里用global替代了一下。\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findSecondMinimumValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        global ans\n        ans = -1\n        rootvalue = root.val\n\n        def dfs(node):\n            global ans\n            if not node:\n                return\n            if ans != -1 and node.val >= ans:\n                return\n            if node.val > rootvalue:\n                ans = node.val\n\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return ans\n```\n\n## 总结\n\n写了挺久没写出来，主要是树的遍历，不了解BFS和DFS。\n","\n\u003CBadge text=\"中等\" type=\"warning\"/>\n原题链接：[https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree)\n\n## 题目描述\n\n给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。\n\n返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。\n\n:::details{text=\"示例 1\"}\n输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2\n\n输出：[7,4,1]\n\n解释：\n\n所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1\n\n![sketch0.png](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png)\n\n注意，输入的 \"root\" 和 \"target\" 实际上是树上的结点。上面的输入仅仅是对这些对象进行了序列化描述。\n:::\n\n:::details{text=\"提示\"}\n1. 给定的树是非空的。\n2. 树上的每个结点都具有唯一的值 `0 \u003C= node.val \u003C= 500`。\n3. 目标结点 target 是树上的结点。\n4. `0 \u003C= K \u003C= 1000`.\n:::\n\n## Python题解\n\n### 方法一：深度优先搜索 + 哈希表\n\n``` python\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def distanceK(self, root, target, k):\n        \"\"\"\n        :type root: TreeNode\n        :type target: TreeNode\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        parents = {root.val: None}\n        ans = []\n\n        def findParents(node):\n            if node.left is not None:\n                parents[node.left.val] = node\n                findParents(node.left)\n            if node.right is not None:\n                parents[node.right.val] = node\n                findParents(node.right)\n\n        def findAns(node, source, depth, k):\n            if node is None:\n                return\n            if depth == k:\n                ans.append(node.val)\n                return\n            if node.left != source:\n                findAns(node.left, node, depth + 1, k)\n            if node.right != source:\n                findAns(node.right, node, depth + 1, k)\n            if parents[node.val] != source:\n                findAns(parents[node.val], node, depth + 1, k)\n\n        findParents(root)\n        findAns(target, None, 0, k)\n        return ans\n```\n\n## 总结\n\n又是没写出DFS的一天，对哈希表的理解也不到位。\n","\n\u003CBadge text=\"简单\" type=\"tip\"/>\n原题链接：[https://leetcode-cn.com/problems/excel-sheet-column-number](https://leetcode-cn.com/problems/excel-sheet-column-number)\n\n## 题目描述\n\n给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。\n\n例如\n\n```\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28\n...\n```\n\n:::details{text=\"示例 1\"}\n输入: columnTitle = \"A\"\n\n输出: 1\n:::\n\n:::details{text=\"示例 2\"}\n输入: columnTitle = \"AB\"\n输出: 28\n:::\n\n:::details{text=\"示例 3\"}\n输入: columnTitle = \"ZY\"\n\n输出: 701\n:::\n\n:::details{text=\"示例 4\"}\n输入: columnTitle = \"ZY\"\n\n输出: 701\n:::\n\n:::details{text=\"提示\"}\n`1 \u003C= columnTitle.length \u003C= 7`\ncolumnTitle 仅由大写英文组成\ncolumnTitle 在范围 [\"A\", \"FXSHRXW\"] 内\n:::\n\n## Python题解\n\n### 个人题解\n\n```python\nclass Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        num = 0\n        for i in range(len(columnTitle)):\n            num += (ord(columnTitle[i]) - 64) * 26 ** (len(columnTitle) - i - 1)\n        return num\n```\n\n## 总结\n\n入门难度没啥好说的，顺带了解了`ord`函数（转换ASCII码）与乘方运算`**`。\n","\n\u003CBadge text=\"困难\" type=\"error\"/>\n原题链接：[https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree)\n\n## 题目描述\n\n给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。\n\n对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。\n\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n\n返回二叉树的 垂序遍历 序列。\n\n:::details{text=\"示例 1\"}\n![vtree1.jpg](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)\n\n输入：root = [3,9,20,null,null,15,7]\n\n输出：[[9],[3,15],[20],[7]]\n\n解释：\n- 列 -1 ：只有结点 9 在此列中。\n- 列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n- 列  1 ：只有结点 20 在此列中。\n- 列  2 ：只有结点 7 在此列中。\n:::\n\n:::details{text=\"示例 2\"}\n![https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg](https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg)\n\n输入：root = [1,2,3,4,5,6,7]\n\n输出：[[4],[2],[1,5,6],[3],[7]]\n\n解释：\n- 列 -2 ：只有结点 4 在此列中。\n- 列 -1 ：只有结点 2 在此列中。\n- 列  0 ：结点 1 、5 和 6 都在此列中。\n    - 1 在上面，所以它出现在前面。\n    - 5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n- 列  1 ：只有结点 3 在此列中。\n- 列  2 ：只有结点 7 在此列中。\n:::\n\n:::details{text=\"示例 3\"}\n![https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg](https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg)\n\n输入：root = [1,2,3,4,6,5,7]\n\n输出：[[4],[2],[1,5,6],[3],[7]]\n\n解释：\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。\n:::\n\n:::details{text=\"提示\"}\n- 树中结点数目总数在范围 [1, 1000] 内\n- `0 \u003C= Node.val \u003C= 1000`\n:::\n\n## Python题解\n\n\n### 方法一：自定义排序\n\n```python\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def verticalTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        nodes = []\n\n        def dfs(node, depth, column):\n            nodes.append((column, depth, node.val))\n            if node.left is not None:\n                dfs(node.left, depth + 1, column - 1)\n            if node.right is not None:\n                dfs(node.right, depth + 1, column + 1)\n\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans, lastColumn = list(), float(\"-inf\")\n        for column, row, value in nodes:\n            if column != lastColumn:\n                lastColumn = column\n                ans.append(list())\n            ans[-1].append(value)\n\n        return ans\n```\n\n## 总结\n\n没弄清楚sort函数可以按顺序排序，写了好久也没写出来同列同深度排序 :(\n\n另外官方题解最后ans的添加也有点意思。\n","\n\u003CBadge text=\"简单\" type=\"tip\"/>\n原题链接：[https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix)\n\n## 题目描述\n\n给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。\n\n请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。\n\n如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。\n\n军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。\n\n:::details{text=\"示例 1\"}\n输入：mat =\n[[1,1,0,0,0],\n [1,1,1,1,0],\n [1,0,0,0,0],\n [1,1,0,0,0],\n [1,1,1,1,1]],\n\nk = 3\n\n输出：[2,0,3]\n\n解释：\n\n每行中的军人数目：\n行 0 -> 2\n行 1 -> 4\n行 2 -> 1\n行 3 -> 2\n行 4 -> 5\n\n从最弱到最强对这些行排序后得到 [2,0,3,1,4]\n:::\n\n:::details{text=\"示例 2\"}\n输入：mat =\n[[1,0,0,0],\n [1,1,1,1],\n [1,0,0,0],\n [1,0,0,0]],\n\nk = 2\n\n输出：[0,2]\n\n解释：\n\n每行中的军人数目：\n行 0 -> 1\n行 1 -> 4\n行 2 -> 1\n行 3 -> 1\n\n从最弱到最强对这些行排序后得到 [0,2,3,1]\n:::\n\n:::details{text=\"提示\"}\n- `m == mat.length`\n- `n == mat[i].length`\n- `2 \u003C= n, m \u003C= 100`\n- `1 \u003C= k \u003C= m`\n- `matrix[i][j]` 不是 0 就是 1\n:::\n\n## Python题解\n\n### 个人题解\n\n```python\nclass Solution(object):\n    def kWeakestRows(self, mat, k):\n        \"\"\"\n        :type mat: List[List[int]]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        powers = []\n        for i in range(len(mat)):\n            power = 0\n            for column in mat[i]:\n                power += column\n                if column == 0:\n                    break\n            powers.append((power, i))\n        powers.sort()\n        ans = []\n        for power, row in powers:\n            if len(ans) == k:\n                break\n            ans.append(row)\n        return ans\n```\n\n\n## 总结\n\n题比较简单，但是官方题解有两个比较高级的解法。\n\n一个是二分查找+堆，另一个是二分查找+快速选择。（看不懂）\n","\n\u003CBadge text='简单' type='tip'/>\n\n原题链接：[https://leetcode-cn.com/problems/three-divisors](https://leetcode-cn.com/problems/three-divisors )\n## 题目描述\n\n给你一个整数 n 。如果 n 恰好有三个正除数 ，返回 true ；否则，返回 false 。\n\n如果存在整数 k ，满足 n = k * m ，那么整数 m 就是 n 的一个 除数 。\n\n:::details{text=\"示例 1\"}\n输入：n = 2\n\n输出：false\n\n解释：2 只有两个除数：1 和 2 。\n:::\n\n:::details{text=\"示例 2\"}\n输入：n = 4\n\n输出：true\n\n解释：4 有三个除数：1、2 和 4 。\n:::\n\n:::details{text=\"示例\"}\n`1 \u003C= n \u003C= 10^4`\n:::\n\n## Python题解\n\n### 参考题解\n\n结合官方对范围的思路优化后的题解\n\n```python\nclass Solution(object):\n    def isThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        count,i = 0,1\n        while i**2 \u003C= n:\n            if n % i == 0:\n                if i != n // i:\n                    count += 2\n                else:\n                    count += 1\n            if count > 3:\n                return False\n            i+=1\n        return count == 3\n```\n\n## 总结\n\n第一次做周赛只对了这一题😔\n\n[第 252 场周赛](https://leetcode-cn.com/contest/weekly-contest-252/)\n","\n\u003CBadge text='中等' type='warning' />\n原题链接：[https://leetcode-cn.com/problems/network-delay-time](https://leetcode-cn.com/problems/network-delay-time)\n\n## 题目描述\n\n有 n 个网络节点，标记为 1 到 n。\n\n给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。\n\n现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。\n\n:::details{text=\"示例 1\"}\n![931_example_1.png](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)\n\n输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n\n输出：2\n:::\n\n:::details{text=\"示例 2\"}\n输入：times = [[1,2,1]], n = 2, k = 1\n\n输出：1\n:::\n\n:::details{text=\"示例 3\"}\n输入：times = [[1,2,1]], n = 2, k = 2\n\n输出：-1\n:::\n\n:::details{text=\"提示\"}\n```\n1 \u003C= k \u003C= n \u003C= 100\n1 \u003C= times.length \u003C= 6000\ntimes[i].length == 3\n1 \u003C= ui, vi \u003C= n\nui != vi\n0 \u003C= wi \u003C= 100\n```\n所有 (ui, vi) 对都 互不相同（即，不含重复边）\n:::\n\n## Python题解\n\n### 方法一：Dijkstra 算法\n\n:::details{text=\"Dijkstra 算法\"}\n迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中**最短路径问题**。迪杰斯特拉算法主要特点是从起始点开始，采用**贪心算法**的策略，每次遍历到始点**距离最近**且**未访问过的顶点**的邻接节点，直到扩展到终点为止。\n:::\n\n```python\n    def networkDelayTime(self, times, n, k):\n        \"\"\"\n        :type times: List[List[int]]\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # 邻接矩阵存储图，此处存储距离信息\n        g = [[float('inf')] * n for _ in range(n)]\n        # 从邻接矩阵更新权重，对下标进行了减一处理\n        for start, end, time in times:\n            g[start - 1][end - 1] = time\n        # 目标节点到其他节点的最短距离列表信息\n        distance = [float('inf')] * n\n        # 起点距离设置为0\n        distance[k - 1] = 0\n        # 用于标记已被经过的节点\n        used = [False] * n\n        # 遍历所有节点\n        for _ in range(n):\n            # 第一次不用比较距离用到的参数\n            x = -1\n            # 获取未被标记的最近节点\n            for index, false in enumerate(used):\n                if not false and (x == -1 or distance[index] \u003C distance[x]):\n                    x = index\n            # 标记节点\n            used[x] = True\n            # 更新最短路径距离\n            for index, time in enumerate(g[x]):\n                distance[index] = min(distance[index], distance[x] + time)\n        # 要求所有节点接收，所以返回最短距离的最大值\n        ans = max(distance)\n        # 如果存在inf则代表有节点不可达，此时返回-1\n        return ans if ans \u003C float('inf') else -1\n```\n\n\n## 总结\n\n题解没看懂，debug了一遍才看懂一点，然后写了点注释 :(\n\n增加测试用例，又debug了一遍，有了新的理解，已更新注释信息。\n","\n## 1. 数据库相关概念\n\n**数据库（Database）**：Database是按照数据结构来组织、存储和管理数据的仓库。\n\n**数据库管理系统（Database Management System）**：数据库管理系统是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS。DBMS可分为**关系型数据库管理系统**（Relational Database Management System：RDBMS）与**NoSQL**（Not only SQL：对不同于传统的关系数据库的数据库管理系统的统称）。\n\n**数据库系统（Database System）**：数据库系统，是由数据库及其管理软件组成的系统。\n\n:::warning\n现实中可能会经常听到一些人使用“数据库”（Database）来表示“数据库管理系统”（Database Managment System）这一概念，但其实这是两个不同的概念，只是被简化了，例如我们通常使用“法人”表示“法人代表”，但其实“法人”表示的是组织。\n:::\n\n**模式（schema）**：关于数据库和表的布局及特性的信息。\n\n:::warning\n在某些时候，schema也可用于表示数据库。\n:::\n\n**表（table）**：数据库中的特定类型数据的结构化清单。\n\n**列（column）**：表中的一个字段。所有表都是由一个或多个列组成的。\n\n**行（row）**：表中的数据是按行存储的，所保存的每个记录存储在自己的行内。有时也称为记录（record）。\n\n**数据类型（datatype）**：每一列都可以根据自身的特性选择特定的数据类型。\n\n**主键（primary key）**：通常用于确定唯一的行，所以主键是不能重复的。\n\n**外键（foreign key）**：表中存储的与其他表主键关联的键，叫外键。\n\n**索引（index）**：相当于对列添加目录，用于加速列的查询。\n\n**SQL**：结构化查询语言（Structured Query Language）的缩写。用于与数据库通信。\n\n## 2. MySQL概念及安装\n\nMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。因为其开源的特性所以成为了当下较为流行的DBMS。目前为止MySQL已经更新到了8这个大版本，也算是久经沙场了。\n\n对于初学者来说，你可以使用MySQL自带的命令行工具来学习MySQL，也可以使用第三方MySQL管理软件，例如开源的[Dbeaver](https://dbeaver.io/)。\n\nMySQL官方网站：[https://www.mysql.com/](https://www.mysql.com/)\n\n直接下载MySQL社区服务端：[MySQL Community Server Download](https://dev.mysql.com/downloads/mysql/)，根据自己需求下载压缩包或者是MSI安装程序，新手建议选择MSI安装程序。\n\n下载完成之后双击安装程序即可，过程选项看着选，看不懂就翻译，这里不多赘述。\n\n[MySQL 8.0参考手册](https://dev.mysql.com/doc/refman/8.0/en/)，下载安装等相关指南都在里面了，如果只是下载和入门只需要过一下[Installing and Upgrading MySQL](https://dev.mysql.com/doc/refman/8.0/en/installing.html)和[Tutorial](https://dev.mysql.com/doc/refman/8.0/en/tutorial.html)这两个篇章就行了（看着吃力就翻译）。\n\n安装完成之后，尝试使用 `mysql -u root -p` ，根据提示输入密码即可连接到本地MySQL服务端。\n\n:::warning\n提示没有mysql这个指令则需要将mysql安装目录下的bin目录添加到环境变量即可\n:::\n\n登录之后可以 `show databases;` 查看所有数据库，`use {database_name}` 切换数据库，`show tables;`查看当前数据库下的所有表，`describe {table_name};`查看表结构等。(*大括号里替代成具体的数据库/表的名称*)\n\n## 3. 基本关键字\n\n以下均使用`table`代替表名，`column`代替列名。\n\n### 3.1 select\n\n用于查询数据。\n\n常见用法：\n\n1. 查询全部数据：`select * from table;`\n2. 查询单/多列：`select column/column1,column2 from table;`\n\n:::tip\n在使用列名是可以使用**表名.列名**的写法，例如`select table.column from table;`，这在之后的联表查询会经常使用。\n:::\n\n### 3.2 distinct\n\n用于剔除结果中的重复数据。\n\n常见用法：\n\n1. 查询去重：`select distinct column from table;`\n\n### 3.3 limit\n\n限制结果集。不指定正反则默认为正序，即按照`asc`方式进行排序.\n\n常见用法：\n\n1. 限制为1条记录：`select * from table limit 1;`\n2. 偏移限制-写法1：`select * from table limit 2 , 3;`\n3. 偏移限制-写法1: `select * from table limit 3 offset 2;`\n\n以上两种写法都代表从第二条记录后取3条数据，即(3,4,5)\n\n### 3.4 order by\n\n用于对数据排序。\n\n常见用法：\n\n1. 正序排序1：`select * from table order by column;`\n2. 正序排序2: `select * from table order by column asc;`\n3. 倒序排序：`select * from table order by column desc;`\n4. 多列排序：`select * from table order by column1 asc,column2 desc;`\n\n### 3.5 where\n\n用于对数据的过滤，其后可以接子句等其他表达式。\n\n常见用法：\n\n1. 查询列值为1的记录：`select * from table where column = 1;`\n2. 查询列值为Null的记录：`select * from table where column is null;`\n\n在上述示例中我们只使用了“＝”这个比较符号，在MySQL中还有这些比较符号可以在where语句中使用。\n\n| 符号    | 含义     |\n| :-----: | :------: |\n| `=`       | 等于     |\n| `\u003C>`      | 不等于   |\n| `!=`      | 不等于   |\n| `\u003C`       | 小于     |\n| `\u003C=`      | 小于等于 |\n| `>`       | 大于     |\n| `>=`      | 大于等于 |\n\n:::warning\n注意：null是这个列没有被赋值，而不是空字符串或者空格，也不是0。\n:::\n\n### 3.6 not\n\n常用于对逻辑取反。例如与`between`与`in`的取反。\n\n### 3.7 between\n\n常用于与where配合限制数据在某个区间内。\n\n常见用法：\n\n1. 查询列值在1到10之间的记录：`select * from table where column between 1 and 10;`\n2. 查询列值不在1到10之间的记录：`select * from table where column not between 1 and 10;`\n\n### 3.8 in\n\n常用于配合where语法，对数据进行结果集过滤。\n\n常见用法：\n\n1. 查询列值在某个结果集的记录：`select * from table where column in (1,2);`\n2. 查询列值不在某个结果集的记录：`select * from table where column not in (1,2);`\n\n\n### 3.9 and\n\n常用于与where语句配合，进行多条件的逻辑与判断\n\n:::warning\n`and`与`or`同时使用`and`拥有更多的优先级，当同时使用时，推荐使用括号来明确优先级。\n:::\n\n常见用法：\n\n1. 限制多属性查询：`select * from table where column1 = 1 and column2 = '计算机';`\n\n### 3.10 or\n\n常用于与where语句配合，进行多条件的逻辑或判断\n\n常见用法：\n\n1. 限制单属性多选择：`select * from table where column = 1 or column = 2;`\n2. 等上写法：`select * from table where column in (1,2);`\n3. 等上写法：`select * from table where column between 1 and 2;`\n\n:::warning\n`and`与`or`同时使用`and`拥有更多的优先级，当同时使用时，推荐使用括号来明确优先级。\n:::\n\n### 3.11 like\n\n用于模糊匹配，常与`%`一起使用。\n\n另一个通配符是`_`，和`%`不同的是，`_`只能匹配单个字符。\n\n常见用法：\n\n1. 左模糊：`select * from table where column like '1%';`\n2. 右模糊：`select * from table where column like '%1';`\n3. 中间模糊：`select * from table where column like '1%1';`\n4. 左右模糊：`select * from table where column like '%1%';`\n\n:::warning\n模糊查询效率相对较低，如果可以简单查询的话，尽量使用简单明确的条件过滤。\n:::\n\n### 3.12 regexp\n\n用于进行正则表达式过滤。\n\n常见用法：\n\n1. 查询包含1的结果集：`select * from table where column regexp '1';`\n2. 查询包含`1%`的结果集：`select * from table where column regexp '1.'\n\n这里的`.`是正则表达式中用于匹配任意一个字符的，更多正则表达式的内容可以查看：[Github：learn-regex](https://github.com/ziishaned/learn-regex)\n\n:::tip\n你可以不查询表来测试正则表达式，像这样`select 'hello' regexp '[:alpha:]';`，如果匹配则返回1，反之为0。\n:::\n\n### 3.13 as\n\n为列取别名。\n\n常见用法：\n\n1. 别名：`select t.column as new_name from table as t;`\n2. 简写：`select t.column new_name from table t;`\n\n### 3.14 group by\n\n将数据进行分组\n\n常见用法：\n\n1. 按列分组：`select column count(column) from table group by column;`\n\n:::warning\nGROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。\n:::\n\n### 3.15 having\n\n对分组数据进行过滤，类似where，但是where不能过滤分组数组，因为where是用于过滤行的，大多数情况下都可以使用having代替where。\n\n常见用法：\n\n1. 分组并取count大于等于2的：`select column count(column) from table group by column having count(*) >= 2;`\n\n### 3.16 insert\n\n新增记录。\n\n常见用法：\n\n1. 按照表中的列顺序插入：`insert into table values(xxx,xxx,xxx...);`\n2. 自定义列及顺序插入：`insert into table(id,name,age...) values(null,'test',18...)`\n3. 多行插入：`insert into table values(xxx,xxx,xxx...),(xxx,xxx,xxx...)`\n\n:::tip\n你还可以在insert的values部分使用select语句返回的值作为value插入，需要注意的是涉及唯一的列需要变动时，如果id设置了自增那么可以不用插入id。\n\n类似`INSERT INTO table(column1,column2) SELECT column1, column2 FROM articles`\n:::\n\n### 3.17 update\n\n更新记录。\n\n常见用法：\n\n1. 更新指定数据：`update table set column1 = 1 where column2 = 2`\n2. 更新多列：`update table set column1 = 1,column2 = 2 where column3 = 3`\n\n### 3.18 delete\n\n删除数据。\n\n常见用法：\n\n1. 删除指定记录：`delete from table where column1 = 1 `\n\n## 4. 函数和运算符\n\n此章节内容参考：[官方手册 - 函数与运算符章节](https://dev.mysql.com/doc/refman/8.0/en/functions.html)，[w3school - MySQL函数](https://www.w3schools.com/mysql/mysql_ref_functions.asp)。\n\n:::tip\n手册版本为8.0\n:::\n\n### 4.1 运算符\n\n四则运算（+、-、*、/）是最为常见的运算符。例如你想对一个数进行平方，可以这样 `select column column * column square from table;`\n\n更多内容建议参考[官方手册-运算符](https://dev.mysql.com/doc/refman/8.0/en/non-typed-operators.html)\n\n### 4.2 函数\n\n如果是想细节了解函数，建议参考上面的官方手册。\n\n以下仅简单按照几个方面介绍一些常用的函数。\n\n- 字符串函数\n- 数值函数\n- 日期与时间函数\n\n#### 4.2.1 字符串函数\n\n**concat()**：用于拼接字符串，`select concat('hello',' world !');`\n**left()**：返回字符串左边n位，`right()`同理\n**length()**：返回字符串长度\n**lower()**：小写函数。大写为`upper()`\n**trim()**：删除前后空格，衍生函数：`ltrim()`、`rtrim()`\n**locate()**：返回子字符串在字符串中第一次出现的位置，`SELECT LOCATE(\"3\", \"W3Schools.com\");`\n**repeat()**：重复字符串，`SELECT REPEAT(\"SQL Tutorial\", 3);`\n**replace()**: 替换字符串，`SELECT REPLACE(\"SQL Tutorial\", \"SQL\", \"HTML\");`\n**reverse()**：反转字符串，`SELECT REVERSE(\"SQL Tutorial\");`\n**substr()**：截取字符串，同`substring()`，`SELECT SUBSTR(\"SQL Tutorial\", 5, 3);`\n\n#### 4.2.2 数值函数\n\n**abs()**：获取数值绝对值\n**avg()**：平均值，`SELECT AVG(Price) AS AveragePrice FROM Products;`\n**sum()**：求和\n**max()**：获取某列最大值，`min()`则相反\n**ceil()**：想上取整，同`ceiling()`\n**floor()**：向下取整\n**count()**：统计数值\n**mod()**：取模\n**greatest()**：返回列表最大值，`SELECT GREATEST(3, 12, 34, 8, 25);`，`least()`则相反\n**pow()**：幂运算，同`power()`，`SELECT POW(4, 3);`\n**rand()**：返回一个大于等于0小于1的浮点数。\n**round()**：将数值进行四舍五入。四舍五入到小数点后两位：`SELECT ROUND(135.375, 2);`\n**sqrt()**：平方根\n\n除此之外还有许多都是数学函数，类似三角函数与反三角函数，弧度角度转换函数，对数函数等。\n\n#### 4.3.3 日期与时间函数\n\n**curdate()**：当前日期，同`current_date()`\n**curtime()**：当前时间，同`current_time()`\n**current_timestamp()**：当前日期加时间，类似`now()`，`localtime()`\n**datediff()**：日期差，`SELECT DATEDIFF(\"2017-06-25\", \"2017-06-15\");`\n**adddate()**：增加日期，`SELECT ADDDATE(\"2017-06-15\", INTERVAL 10 DAY);`\n**addtime()**：增加时间，`SELECT ADDTIME(\"2017-06-15 09:34:21\", \"2\");`\n\n此处基本没介绍年月日时分秒，但是相关函数都有。\n\n#### 4.4.4 流程控制函数\n\n不知道为什么官方手册把这归结到函数而不是语句，但这都不是重点，重点是流程控制。\n\n因为觉得介绍看的不如直接上代码，所以这里直接上代码。\n\n- case、then、when、else、end\n\n这是一套十分常见的流程控制组合。\n\n``` SQL\nmysql> SELECT CASE 1 WHEN 1 THEN 'one'\n    ->     WHEN 2 THEN 'two' ELSE 'more' END;\n        -> 'one'\nmysql> SELECT CASE WHEN 1>0 THEN 'true' ELSE 'false' END;\n        -> 'true'\nmysql> SELECT CASE BINARY 'B'\n    ->     WHEN 'a' THEN 1 WHEN 'b' THEN 2 END;\n        -> NULL\n```\n\n- IF(expr1,expr2,expr3)\n\n如果 expr1 为 TRUE（`expr1 \u003C> 0` 和 `expr1 \u003C> NULL`），IF() 返回 expr2。否则，它返回 expr3。\n\n``` sql\nmysql> SELECT IF(1>2,2,3);\n        -> 3\nmysql> SELECT IF(1\u003C2,'yes','no');\n        -> 'yes'\nmysql> SELECT IF(STRCMP('test','test1'),'no','yes');\n        -> 'no'\n```\n\n- IFNULL(expr1,expr2)\n\n如果 expr1 不为 NULL，则 IFNULL() 返回 expr1；否则返回 expr2。\n\n``` sql\nmysql> SELECT IFNULL(1,0);\n        -> 1\nmysql> SELECT IFNULL(NULL,10);\n        -> 10\nmysql> SELECT IFNULL(1/0,10);\n        -> 10\nmysql> SELECT IFNULL(1/0,'yes');\n        -> 'yes'\n```\n\n- NULLIF(expr1,expr2)\n\n如果 expr1 = expr2 为真，则返回 NULL，否则返回 expr1。这与 CASE WHEN expr1 = expr2 THEN NULL ELSE expr1 END 相同。\n\n```sql\nmysql> SELECT NULLIF(1,1);\n        -> NULL\nmysql> SELECT NULLIF(1,2);\n        -> 1\n```\n\n## 5. 高级部分\n\n### 5.1 子查询（subquery）\n\n子查询就是嵌套在其他查询中的查询。\n\n举个栗子\n\n```sql\nselect column from table where column = (select column from table where column = 1)\n```\n\n以上是最为简单的子查询，接下来介绍一种作为**计算字段的子查询**\n\n```sql\nselect column1 (select count(*) from table2 where table1.column1 = table2.column1) from table1\n```\n\n这里提前使用了联表，目的是为了查出当前的某些主题在其他表的其他统计信息。\n\n### 5.2 连表查询（join）\n\n**连表查询**是SQL中十分常见的做法，因为如果把所有信息都放在同一张表中的话，那么这张表将会十分复杂，并且有些信息可能是大量重复的数据，所以连表查询也可以减少数据库的空间占用。\n\n通常的做法是提供多张表，然后在关联表中使用一个字段与主表的**主键**进行关联，因此关联表中的这个字段也被称为**外键**。\n\n既然数据存放在不同表，那么使用简单查询就不可能查询出我们需要的所有信息，所以此时就需要使用连表查询。\n\n举个例子，现在有一张商品表products与订单表orders，我们需要从订单金额大于500的商品信息（在商品表才有商品信息，订单表只有商品id），所以此时我们可以这样：\n\n```sql\nselect product.product_name, orders.amount from orders, products where orders.product_id = products.id\n```\n\n在上面的SQL语句中，我们在查询了两个在不同表的字段 **（** 使用表名.列名的方式，这种方式称之为 **完全限定名）** ，通过from后面添加两张表名（使用逗号隔开），并且在where条件中补充连接关系，这样便是一个最简单的连表查询。\n\n如果不在where条件中补充联结关系，那么返回的结果将会是两表的笛卡尔积，这种方式也称之为**交叉连接**（`cross join`）。\n\n- **内连接**\n\n连接其实也分为不同的类型，上述的写法其实是**内连接**的简化写法，事实上它和以下这种写法是一样的\n\n```sql\nselect product.product_name, orders.amount from orders inner join products on orders.product_id = products.id\n```\n\n两者的区别在乎这里我们明确使用了`inner join`关键字进行内连接，同时使用`on`而不是`where`进行连接关系的补充。\n\n连接不仅局限于两张表，如果需要连接多张表，则需要继续补充相应的连接关系。但是需要注意，连表是有性能代价的，**连接的表越多，性能下降也越大。**\n\n- **外连接**\n\n外连接与内连接不同在于，内连接只会返回匹配的行，而外连接除了返回匹配的行还会返回不匹配的行。\n\n外连接通常分为**左外连接**（`left outer join`，简写为`left join`）与**右外连接**(`right outer join`，简写为`right join`)。\n\n:::warning\nMySQL是没有`full join`的，想实现这个功能可以考虑下面的组合查询（union）。\n:::\n\n左外连接即使返回左表的所有行，即使行没有与右表相匹配，右连接则相反。\n\n通过韦恩图可以获得更为直观的信息。\n\n![img_innerjoin.gif](https://www.runoob.com/wp-content/uploads/2014/03/img_innerjoin.gif)\n\n![img_leftjoin.gif](https://www.runoob.com/wp-content/uploads/2014/03/img_leftjoin.gif)\n\n![img_rightjoin.gif](https://www.runoob.com/wp-content/uploads/2014/03/img_rightjoin.gif)\n\n- **自连接**\n\n自连接是把同一张表进行联表查的方式，自连接的好处在于对于那些只在一张表使用子查询时，可以考虑自连接，因为自连接的性能通常会比子查询要好（需要你自己测试）。\n\n下面举个例子，假设我们有张教师表，我们需要从该表中查询出所有科目等于**id为1的老师的科目**的教师姓名，此时如果使用子查询则可以：\n\n```sql\nselect name, subject from teachers where subject = (select subject from teachers where id = 1);\n```\n\n自连接的方式：\n\n```sql\nselect t1.name, t1.subject from teachers t1, teachers t2 where t1.subject = t2.subject and t2.id = 1;\n```\n\n:::tip\n更多参考：[官方手册 - JOIN Clause](https://dev.mysql.com/doc/refman/8.0/en/join.html)\n:::\n\n### 5.3 组合查询（union）\n\n组合查询其实就是把多个查询结果进行并集处理。在上述连表查询中我们提到过使用组合查询实现全连接，通过左连接与右连接进行并集处理，返回的结果正好是全连接，通过上述的韦恩图也可以非常直观的感受到。\n\n组合查询的使用非常简单，但是这里仍然给出一个例子：\n\n```sql\nselect name, age, level from teachers where age \u003C= 30 union select name, age, level from teachers where level >= 3\n```\n\n上述的需求可能是，最近学校要选出一些教师，要求教师年纪最好要小（30之内），如果年纪大了的话，那么等级必须大于3，因此使用并集处理就可以获取我们所有符合条件的教师。\n\n你可能会疑惑在这个情况下，使用or不也能完成嘛。事实上这里仅仅是为了介绍union的使用，实际上union的结果集大多不在一张表，而且也不会如此简单。\n\n:::warning\n在使用union时，你应该注意，union必须连接两条或以上的select语句，并且每个查询必须包含相同的列，表达式或者聚集函数（顺序可以不同），此外，列的数据也必须兼容（不必完全相同，但需要能隐式转换）。\n:::\n\n:::warning\n需要注意的是，union默认会合并重复行，比如上方的例子中在30岁以下的同时level大于3的教师就会被自动合并，如果不想被合并可以使用`union all`即可。\n:::\n\n:::warning\n对union的排序不应该对单独的select语句进行排序，而是应该在最后进行一个`order by`排序即可。\n:::\n\n### 5.4 全文索引（fulltext index）\n\n\n```\n手册参考：\n- [官方手册8.0 - 全文索引功能](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html)\n- [官方手册8.0 - InnoDB全文索引](https://dev.mysql.com/doc/refman/8.0/en/innodb-fulltext-index.html)\n```\n\n全文索引通常用于加快基于大文本列的查询。MySQL早期的只有MyISAM引擎支持全文索引，不过在5.6之后，InnoDB引擎也开始支持全文索引，但是这个分词默认是针对英文的，中文的分词在5.7开始内置了ngram插件，这个插件可以支持中文、日语、韩语，所以对于想使用中文索引的人建议使用5.7+的版本。\n\nInnoDB全文索引采用倒排索引设计。倒排索引存储一个单词列表，对于每个单词，还有一个该单词出现的文档列表。为了支持邻近搜索，每个单词的位置信息也被作为字节偏移进行存储。\n\n对于大型数据集，将数据加载到没有FULLTEXT索引的表然后创建索引比将数据加载到具有现有FULLTEXT索引的表要快得多。\n\n\n- **全文索引的创建与删除**\n\n创建：\n\n```sql\nCREATE TABLE opening_lines (\n       id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,\n       opening_line TEXT(500),\n       author VARCHAR(200),\n       title VARCHAR(200),\n       FULLTEXT idx (opening_line)\n       ) ENGINE=InnoDB;\n```\n\n```sql\n CREATE FULLTEXT INDEX idx ON opening_lines(opening_line);\n```\n\n```sql\n-- 此方法添加的索引名即为列名\nALTER TABLE opening_lines\nADD FULLTEXT(opening_line)\n```\n\n:::warning\n将全文索引添加到没有`FTS_DOC_ID`列的表时，会返回`InnoDB rebuilding table to add column FTS_DOC_ID`警告。\n如果您不关心`CREATE FULLTEXT INDEX`性能，请忽略该`FTS_DOC_ID`列， InnoDB为您创建它。\n:::\n\n删除：\n\n```sql\ndrop index idx on opening_lines\n```\n\n或者\n\n```sql\nalter table opening_lines drop index idx\n```\n\n- **使用全文索引**\n\n通过在where之后添加`match()`,`against()`即可根据全文索引搜索，需要注意的是，在默认分词插件下，通常是通过空格,逗号，句号进行分词，并且较短的字符串（默认是3）是不会被收录到单词列表。\n\n```sql\nselect opening_line from opening_lines where match(opening_line) against('xxx')\n```\n\n:::tip\n默认情况下，搜索以不区分大小写的方式执行。要执行区分大小写的全文搜索，请对索引列使用区分大小写或二进制排序规则。例如，utf8mb4 可以为使用字符集的列分配排序规则 utf8mb4_0900_as_cs或 utf8mb4_bin使其区分大小写以进行全文搜索。\n:::\n\n在某些情况下，使用like操作也能完成类似的操作，但是like的效率比较低（精度高）。而全文索引降低了一些精度，换来分析结果相关度，这一点是非常重要的，在下面我们将继续通过一个例子来介绍如何查询结果相关度或者权重。\n\n```sql\nselect opening_line, match(opening_line) against('xxx') as weight from opening_lines\n```\n\n 通过将`match(opening_line) against('xxx')`作为字段，我们可以看到每列对于该索引条件的权重。\n\n 默认通过全文索引查询的结果就是根据权重进行排序的，这一点是`like`这种高精度硬匹配所无法做到的。\n\n 在上述示例中，我们没有介绍全文索引的工作模式，**默认情况下**，全文索引使用**自然语言模式**，即`IN NATURAL LANGUAGE MODE`，除了该模式外，还有**布尔模式**和**查询扩展模式**。\n\n更多参考：[官方手册8.0 - 自然语言全文搜索](https://dev.mysql.com/doc/refman/8.0/en/fulltext-natural-language.html)\n\n**布尔模式**：布尔模式通常对字符串进行一些逻辑判断，比如判断某些单词存在同时某些单词不存在可以这样：\n\n```sql\nSELECT * FROM articles WHERE MATCH (title,body)\n    AGAINST ('+MySQL -YourSQL' IN BOOLEAN MODE);\n```\n\n在上述示例中，`+`和`-`运算符分别指示一个词必须存在或不存在，`IN BOOLEAN MODE`用于确定采用布尔模式。\n\n除了`+`和`-`之外还有许多其他的运算符，同时布尔查询也不会按照相关度进行排序。\n\n更多参考：[官方手册8.0 - 布尔全文搜索](https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html)\n\n **查询扩展模式**：如果你想对结果进行扩展（即使结果不包含相关关键词），那么你可以使用`with query expansion`。\n\n ```sql\nselect opening_line from opening_lines where match(opening_line) against('xxx' with query expansion)\n ```\n\n 举个例子，你需要查询的词为`Newtons`，现在有一条记录为`Apple fell on Newton's head.`，那么与之相关词的就可能是`head`，所以结果可能就会返会包含`head`的记录。\n\n更多参考：[官方手册8.0 - 带有查询扩展的全文搜索](https://dev.mysql.com/doc/refman/8.0/en/fulltext-query-expansion.html)\n\n\n- **ngram 全文解析器**\n\nngram是`mysql 5.7`开始内置的中文分词插件，根据n来确定分词基数的，在中文情况下，词语通常为两个字，所以ngram默认的token size就是2，但是这个值也可以进行配置，取值范围为[1,10].\n\n1. 命令行参数配置：`mysqld --ngram_token_size=2`\n2. 配置文件：\n``` ini\n[mysqld]\nngram_token_size=2\n```\n\n创建时指定ngram作为解析器：\n\n```sql\nCREATE TABLE articles (\n      id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,\n      title VARCHAR(200),\n      body TEXT,\n      FULLTEXT (title,body) WITH PARSER ngram\n    ) ENGINE=InnoDB CHARACTER SET utf8mb4;\n\nCREATE FULLTEXT INDEX ft_index ON articles (title,body) WITH PARSER ngram;\n\nALTER TABLE articles ADD FULLTEXT INDEX ft_index (title,body) WITH PARSER ngram;\n```\n\n:::warning\n默认情况下，ngram 解析器使用默认停用词列表，其中包含英文停用词列表。对于适用于中文、日语或韩语的停用词列表，您必须创建自己的停用词列表。有关创建停用词列表的信息，请参阅[全文停用词](https://dev.mysql.com/doc/refman/8.0/en/fulltext-stopwords.html)。\n\nGithub中文停用词仓库: [https://github.com/goto456/stopwords](https://github.com/goto456/stopwords)\n:::\n\n对于**自然语言模式**，搜索词被转换为ngram**词的联合**。例如默认分词基数（2）的情况下，“长安城”将被分解成“长安 安城”，如果现在有两条记录，分别包含“长安”，“长安城”，那么在自然语言模式下，他们都将被匹配。\n\n对于**布尔模式**，搜索词将转换为ngram**短语搜索**，同样在上述情况，则只有“长安城”被匹配。\n\n如果你想查询分词的结果，官方有个示例：\n\n```sql\nmysql> USE test;\n\nmysql> CREATE TABLE articles (\n      id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,\n      title VARCHAR(200),\n      body TEXT,\n      FULLTEXT (title,body) WITH PARSER ngram\n    ) ENGINE=InnoDB CHARACTER SET utf8mb4;\n\nmysql> SET NAMES utf8mb4;\n\nINSERT INTO articles (title,body) VALUES\n    ('数据库管理','在本教程中我将向你展示如何管理数据库'),\n    ('数据库应用开发','学习开发数据库应用程序');\n\nmysql> SET GLOBAL innodb_ft_aux_table=\"test/articles\";\n\nmysql> SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE ORDER BY doc_id, position;\n```\n\n更多参考：[官方手册8.0 - ngram 全文解析器](https://dev.mysql.com/doc/refman/8.0/en/fulltext-search-ngram.html)\n\n### 5.5 视图（view）\n\n在 SQL 中，视图是基于 SQL 语句的结果集的可视化的**虚拟**表。\n\n视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。我们可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，我们也可以提交数据，就像这些来自于某个单一的表。\n\n:::tip\n- 数据库的设计和结构不会受到视图中的函数、where 或 join 语句的影响。\n- 视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。\n:::\n\n:::warning\n- 视图名与表名不可重复。\n- 使用复杂视图前请测试性能。\n:::\n\n**视图的好处**\n\n1. 重用sql\n2. 简化sql\n3. 保护数据，只能操作表的特定部分\n\n**基本用法**\n\n```sql\n# 创建视图\nCREATE VIEW [Products Above Average Price] AS\nSELECT ProductName,UnitPrice\nFROM Products\nWHERE UnitPrice>(SELECT AVG(UnitPrice) FROM Products);\n# 查询视图\nSELECT * FROM [Products Above Average Price];\n# 查看视图创建过程\nSHOW CREATE VIEW [Products Above Average Price];\n# 更新视图\nCREATE OR REPLACE VIEW [视图名] AS\nSELECT column_name(s)\nFROM table_name\nWHERE condition;\n# 删除视图\nDROP VIEW [视图名];\n```\n\n### 5.6 存储过程（Stored Procedure）\n\n存储过程（Stored Procedure）是在大型数据库系统中，**一组为了完成特定功能的SQL 语句集**。\n\n它存储在数据库中，一次编译后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。\n\n:::tip\n存储过程的优点：可重用、使用简单、安全、高性能。\n\n存储过程的创建权限与执行权限是分开的。\n:::\n\n:::warning\n一般来说，存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。\n:::\n\n以下仅介绍基本的语法，实际上的存储过程十分复杂，建议参考：\n\n- [MySQL 存储过程 | 菜鸟教程](https://www.runoob.com/w3cnote/mysql-stored-procedure.html)\n- [CREATE PROCEDURE and CREATE FUNCTION Statements | MySQL](https://dev.mysql.com/doc/refman/8.0/en/create-procedure.html)\n\n**基本用法**\n\n```sql\n# 创建存储过程\nCREATE PROCEDURE two_sum(\n\tin num1 int, # 入参\n\tin num2 int,\n\tout sum int # 出参\n)\nbegin\n\tselect num1+num2 into sum;\nend;\n# 查看存储过程创建过程\nshow create procedure two_sum;\n# 调用存储过程\ncall two_sum(1,1,@ans);\n# 查询存储过程返回的变量\nselect @ans; # 2\n# 删除存储过程\ndrop procedure two_sum;\n# 修改存储过程只能改变存储过程的特征，不能修改过程的参数以及过程体。\nALTER PROCEDURE proc_name [characteristic ...]\n\ncharacteristic: {\n    COMMENT 'string'\n  | LANGUAGE SQL\n  | { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }\n  | SQL SECURITY { DEFINER | INVOKER }\n}\n```\n\n:::warning\n默认的MySQL语句分隔符为`;`，如果你使用的是mysql命令行创建存储过程，则`;`会被忽略而导致语法错误。\n解决办法是临时更改命令行实用程序的语句分隔符\n```sql\n# 临时修改为//\ndelimiter //\n# 修改为正常情况\ndelimiter ;\n```\n:::\n\n### 5.7 游标（cursor）\n\n游标是一个存储在MySQL服务器上的数据库查询， 它不是一条SELECT语句，而是被该语句检索出来的结果集。\n\n游标在MySQL中只能与存储过程协同使用。\n\n**基础使用**\n\n```sql\ncreate procedure testcursor(out res int)\nbegin\n\n\t-- 定义本地变量done\n\tdeclare done boolean default 0;\n\n\t-- 创建游标\n\tdeclare mycursor cursor\n\tfor\n\tselect id from gowow_admin;\n\n\n\t-- '02000'事件(未找到条件，fetch循环到最后触发)触发设置done变量\n\tdeclare continue handler for sqlstate '02000' set done = 1;\n\n\t-- 打开游标\n\topen mycursor;\n\n\t-- 循环\n\trepeat\n\t\t-- 使用游标\n\t\tfetch mycursor into res;\n\tuntil done end repeat;\n\n\t-- 关闭游标\n\tclose mycursor;\nend;\n```\n\n:::warning\n**DECLARE语句的次序**\n\nDECLARE语句的发布存在特定的次序。用DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义。不遵守此顺序将产生错误消息。\n:::\n\n### 5.8 触发器（trigger）\n\n触发器是存储在数据库目录中的一组SQL语句。每当与表相关联的**事件**发生时，就会执行或触发SQL触发器，例如**插入**，**更新**或**删除**。\n\n触发事刻有两种状态，分别是`before`和`after`。\n\n使用`before`可以使用`OLD`来获取修改前的临时表数据。\n\n使用`after`可以使用`NEW`来获取修改后的临时表数据。\n\n**基本用法**\n\n```sql\n# 创建触发器 MySQL5之后不允许返回结果 所以使用变量接收\ncreate trigger mytrigger after insert on [表名]\nfor each row select \"my trigger is staring\" into @res;\n# 删除触发器\ndrop trigger mytrigger;\n\n# 触发器不能被更新\n```\n\n更多参考：[Trigger Syntax and Examples | MySQL](https://dev.mysql.com/doc/refman/8.0/en/trigger-syntax.html)\n\n### 5.9 事务（transaction）\n\n**事务** 的概念：一组sql语句，我们需要让它要么全部成功，要不直接失败。失败时触发的操作称之为**回滚（rollback）**，当且仅当事务全部执行成功时，事务才被**提交（commit）**。同时事务中还可设置**保留点（savepoint）**，它可以仅回滚到某个状态而不是回退整个事务。\n\n**基本使用**\n\n```sql\nstart transaction;\n# 一些操作\n...\nsavepoint sp1;\n...\nrollback to sp1;\n...\nrollback;\ncommit;\n```\n\nMySQL默认状态下`autocommit = 1`，所以你每次输入SQL语句都会自动提交并立即生效，你可以通过设置`set autocommit = 0`来关闭自动提交。\n\n更多参考：[START TRANSACTION, COMMIT, and ROLLBACK Statements | MySQL](https://dev.mysql.com/doc/refman/8.0/en/commit.html)\n\n## 6. 一些提示与建议\n\n### 6.1 select语句的关键字顺序\n\n依次为，`select`、`from`、`where`、`group by`、`having`、`order by`、`limit`\n\n## 7. 常见SQL语句\n\n### 7.1 数据库相关\n\n```sql\n# 创建数据库\ncreate database [数据库名] character set [字符编码];\n# 查看数据库\nshow databases;\n# 查看数据库创建详情\nshow create database [数据库名字];\n# 修改数据库编码\nalter database [数据库名] character set [字符编码];\n# 切换当前数据库\nuse [数据库名];\n# 删除数据库\ndrop database [数据库名];\n```\n\n### 7.2 表相关\n\n```sql\n# 创建表格\ncreate table [表名]\n(\n\tid int not null auto_increment,\n    name varchar(255) not null,\n    email varchar(255) null\n    enable tinyint default 1\n    primary key (id)\n) engine = InnoDB;\n# 新增列\nalter table [表名] add age int(1);\n# 删除列\nalter table [表名] drop column age;\n# 重命名表\nrename table [旧表名] to [新表名];\n# 删除表\ndrop table [表名];\n```\n\n### 7.3 用户权限相关\n\n```sql\n# 切换到mysql数据库\nuse mysql;\n# 查看所有用户\nselect user from user;\n# 新建用户\ncreate user 'test' identified by 'password';\n# 绑定主机\n# create user 'test'@`localhost` identified by 'password';\n# 重命名用户\nrename user `test` to `test2`;\n# 修改密码\nalter user root identified by '123456';\n# 修改当前用户密码\nset password = '123456';\n# 修改其他密码\nset password for test2 = 'password';\n#查看权限\nshow grants for `test2`; # 默认有个usage权限，其实就是无权限\n# 赋予全数据表查询权限\ngrant select on learningmysql.* to test2;\n# 撤销权限\nrevoke select on learningmysql.* from test2;\n# 删除用户\ndrop user 'test2';\n# 更多参考：https://dev.mysql.com/doc/refman/8.0/en/grant.html\n```\n\n### 7.4 字符集相关\n\n```sql\n# 查看字符集\nshow character set;\n# 查看校对顺序\nshow collation;\n```\n\n\n","\n\u003CBadge text = '简单' type = 'tip' />\n原题链接：[https://leetcode-cn.com/problems/fibonacci-number/](https://leetcode-cn.com/problems/fibonacci-number/)\n\n## 题目描述\n\n斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n> F(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n > 1\n\n给你 n ，请计算 F(n) 。\n\n:::details{text=\"示例 1\"}\n输入：2\n输出：1\n解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n:::\n\n:::details{text=\"示例 2\"}\n输入：3\n输出：2\n解释：F(3) = F(2) + F(1) = 1 + 1 = 2\n:::\n\n:::details{text=\"示例 3\"}\n输入：4\n输出：3\n解释：F(4) = F(3) + F(2) = 2 + 1 = 3\n:::\n\n:::details{text=\"提示\"}\n`0 \u003C= n \u003C= 30`\n:::\n\n## Python题解\n\n\n### 个人题解：递归\n```python\nclass Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        def getfn(n):\n            if n == 0 or n == 1:\n                return n\n            else:\n                return getfn(n - 1) + getfn(n - 2)\n\n        return getfn(n)\n```\n\n### 官方题解：动态规划\n\n```python\nclass Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n \u003C 2:\n            return n\n        p, q, r = 0, 0, 1\n        for _ in range(1, n):  # 官方是这样的 for i in range(2, n+1)\n            p, q = q, r\n            r = p + q\n        return r\n```\n\n## 总结\n\n经典递归，没啥说的。\n\n动态规划，时间复杂度：O(n)，空间复杂度：O(1)，不错的思路。\n\n其实官方还有矩阵快速幂与通项公式的解，感兴趣可以自行了解下。[斐波那契数官方题解](https://leetcode-cn.com/problems/fibonacci-number/solution/fei-bo-na-qi-shu-by-leetcode-solution-o4ze/)\n","\n\u003CBadge text = '困难' type = 'error' />\n原题链接：[https://leetcode-cn.com/problems/number-of-digit-one/](https://leetcode-cn.com/problems/number-of-digit-one/)\n\n## 题目描述\n\n给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。\n\n:::details{text=\"示例 1\"}\n输入：n = 13\n\n输出：6\n:::\n\n:::details{text=\"示例 2\"}\n输入：n = 0\n\n输出：0\n:::\n\n:::details{text=\"提示\"}\n`0 \u003C= n \u003C= 2 * 10^9`\n:::\n\n## Python题解\n\n之前尝试了个暴力解，但是测试数据较大，基本不存在暴力解，但还是贴个代码\n\n```python\nclass Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        for i in range(n + 1):\n            numlist = list(str(i))\n            for j in range(len(numlist)):\n                if numlist[j] == '1':\n                    count += 1\n        return count\n```\n\n### 社区题解\n\n暴力解之后，尝试了另一个思路，但是没推出公式，然后就在官解的评论区看到了这个同思路解，就抄了下来。\n\n贴一下大佬的评论地址：[逆模因 - 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/1077672/)\n\n```python\n\"\"\"\n从低往高位，计算每一位的数量：\n第1位上的1有：1 + (n - 1) / 10\n第2位上的1有：(1 + (n / 10 - 1) / 10) * 10\n第3位上的1有：(1 + (n / 100 - 1) / 10) * 100\n...\n第k + 1位上的1有：(1 + (n / (10 ^ k) - 1) / 10) * (10 ^ k)\n如果n的第k + 1位上是1，则说明可能没有填满该位，计算第k + 1位的数量时还要 - 10 ^ k + 1 + n % (10 ^ k)，相当于独立计算\n\"\"\"\nclass Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        m, ans = 1, 0\n        while n >= m:\n            ans += (1 + (n // m - 1) // 10) * m\n            if n // m % 10 == 1:\n                ans = ans - m + 1 + n % m\n            m *= 10\n        return ans\n```\n\n### 官方题解\n\n```python\ndef countDigitOne(n: int) -> int:\n    \"\"\"\n    分别统计各位可能出现的的1\n    -----------------------个位---------------------------\n    比如1234，个位上会出现1的情况， 01，11 21 ... 1231\n    loop = 1234 // 10 = 123，即会出现123次这样的循环区间 [1,10 ]，[11, 20]...[1220, 1230]\n    每个loop[0, 10]仅有1位个位1，所以所有循环的个位1总数位 123 * 1\n    接下来只要取得剩余部分可能出现1的情况\n    rest = 1234 % 10 = 4 这个余数需要分为两种情况\n    >= 1时，会出现一次个位1\n    \u003C 1时，不会出现个位1\n    sum += 123 * 1 + min(max(rest - 10^0 + 1, 0), 1)\n    -----------------------十位---------------------------\n    同理可得 十位的 1 的情况\n    loop = 1234 // 10 ^ 2 = 12 出现12次循环区间 总循环区间范围[0, 1200]\n    每个loop[0, 100]有10个十位1，所以所有循环的个位1总数位 12 * 10\n    剩余部分 rest = 1234 % 100 = 34，分为三种情况\n    \u003C 10 不会出现十位1\n    >= 10 \u003C 20 会出现 rest - 10 + 1次十位1\n    >= 20 出现全部（10次）十位1的情况\n    sum += 34 * 10 + min(max((rest - 10^1 + 1), 0), 10)\n    -----------------------百位---------------------------\n    loop = 1234 / 10 ^ 3 = 1 总区间 [0, 1000]\n    每个区间一共有100个百位1，1 * 100\n    rest = 1234 % 1000 = 234，同样为三种情况\n    \u003C 100 不会出现百位1\n    >=100 \u003C 200 出现 rest - 100 + 1\n    >= 200 出现全部100个\n    sum += 1 * 100 + min(max(rest - 10^3 + 1, 0), 100)\n    -----------------------n位---------------------------\n    以此类推到所有位...\n    \"\"\"\n    # mulk为10^k\n    mulk, ans = 1, 0\n    while n >= mulk:\n        ans += (n // (mulk * 10) * mulk) + min(max(n % (mulk * 10) - mulk + 1, 0), mulk)\n        mulk *= 10\n    return ans\n```\n\n## 总结\n\n暴力解不可取！最后好奇一下时间的差距，发现大佬的算法算`2*10^9000`次方花了4s，而如果是暴力解计算`2*10^7`这个用例都得14s...\n\n珍爱生命，远离暴力。\n\n看了几天看懂了官解，有用的知识增加了\n\n数位dp的方法还没懂 :(\n","\n## 第一题 - 作为子字符串出现在单词中的字符串数目\n\n\u003CBadge text = \"简单\" type = \"tip\" />\n\n原题链接：[https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word](https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word)\n\n### 题目描述\n\n给你一个字符串数组 patterns 和一个字符串 word ，统计 patterns 中有多少个字符串是 word 的子字符串。返回字符串数目。\n\n子字符串 是字符串中的一个连续字符序列。\n\n:::details{text=\"示例 1\"}\n输入：patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\"\n\n输出：3\n\n解释：\n- \"a\" 是 \"abc\" 的子字符串。\n- \"abc\" 是 \"abc\" 的子字符串。\n- \"bc\" 是 \"abc\" 的子字符串。\n- \"d\" 不是 \"abc\" 的子字符串。\n\npatterns 中有 3 个字符串作为子字符串出现在 word 中。\n:::\n\n:::details{text=\"示例 2\"}\n输入：patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\"\n\n输出：2\n\n解释：\n- \"a\" 是 \"aaaaabbbbb\" 的子字符串。\n- \"b\" 是 \"aaaaabbbbb\" 的子字符串。\n- \"c\" 不是 \"aaaaabbbbb\" 的字符串。\n\npatterns 中有 2 个字符串作为子字符串出现在 word 中。\n:::\n\n:::details{text=\"示例 3\"}\n输入：patterns = [\"a\",\"a\",\"a\"], word = \"ab\"\n\n输出：3\n\n解释：patterns 中的每个字符串都作为子字符串出现在 word \"ab\" 中。\n:::\n\n:::details{text=\"提示\"}\n- `1 \u003C= patterns.length \u003C= 100`\n- `1 \u003C= patterns[i].length \u003C= 100`\n- `1 \u003C= word.length \u003C= 100`\n\n`patterns[i]` 和 `word` 由小写英文字母组成\n:::\n\n### Python题解\n\n```python\nclass Solution(object):\n    def numOfStrings(self, patterns, word):\n        \"\"\"\n        :type patterns: List[str]\n        :type word: str\n        :rtype: int\n        \"\"\"\n        ans = 0\n        for pattern in patterns:\n            if pattern in word:\n                ans += 1\n\n        return ans\n```\n\n### 总结\n\nin 关键字实属开挂行为，高阶做法参考官解。\n\n## 第二题 - 构造元素不等于两相邻元素平均值的数组\n\n\u003CBadge text = \"中等\" type = \"warning\" />\n原题链接：[https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors](https://leetcode-cn.com/problems/array-with-elements-not-equal-to-average-of-neighbors)\n\n### 题目描述\n给你一个 下标从 0 开始 的数组 nums ，数组由若干 互不相同的 整数组成。你打算重新排列数组中的元素以满足：重排后，数组中的每个元素都 不等于 其两侧相邻元素的 平均值 。\n\n更公式化的说法是，重新排列的数组应当满足这一属性：对于范围 `1 \u003C= i \u003C nums.length - 1` 中的每个 i ，(nums[i-1] + nums[i+1]) / 2 不等于 nums[i] 均成立 。\n\n返回满足题意的任一重排结果。\n\n:::details{text=\"示例 1\"}\n输入：nums = [1,2,3,4,5]\n\n输出：[1,2,4,5,3]\n\n解释：\n\ni=1, nums[i] = 2, 两相邻元素平均值为 (1+4) / 2 = 2.5\n\ni=2, nums[i] = 4, 两相邻元素平均值为 (2+5) / 2 = 3.5\n\ni=3, nums[i] = 5, 两相邻元素平均值为 (4+3) / 2 = 3.5\n:::\n\n:::details{text=\"示例 2\"}\n输入：nums = [6,2,0,9,7]\n\n输出：[9,7,6,2,0]\n\n解释：\n\ni=1, nums[i] = 7, 两相邻元素平均值为 (9+6) / 2 = 7.5\n\ni=2, nums[i] = 6, 两相邻元素平均值为 (7+2) / 2 = 4.5\n\ni=3, nums[i] = 2, 两相邻元素平均值为 (6+0) / 2 = 3\n:::\n\n:::details{text=\"提示\"}\n```\n3 \u003C= nums.length \u003C= 105\n\n0 \u003C= nums[i] \u003C= 105\n```\n:::\n\n### Python题解\n\n```python\nclass Solution(object):\n    def rearrangeArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in range(1, len(nums) - 1):\n            if nums[i] == (nums[i + 1] + nums[i - 1]) / 2:\n                tmp = nums[i]\n                nums[i] = nums[-1]\n                nums[-1] = tmp\n        return nums\n```\n\n### 总结\n\n没看官解，过了就行\n\n## 第三题 - 数组元素的最小非零乘积\n\n\u003CBadge text = \"中等\" type = \"warning\" />\n原题链接：[https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements](https://leetcode-cn.com/problems/minimum-non-zero-product-of-the-array-elements)\n\n### 题目描述\n\n给你一个正整数 p 。你有一个下标从 1 开始的数组 nums ，这个数组包含范围 [1, 2p - 1] 内所有整数的二进制形式（两端都 包含）。你可以进行以下操作 任意 次：\n\n从 nums 中选择两个元素 x 和 y  。\n选择 x 中的一位与 y 对应位置的位交换。对应位置指的是两个整数 相同位置 的二进制位。\n比方说，如果 x = 1101 且 y = 0011 ，交换右边数起第 2 位后，我们得到 x = 1111 和 y = 0001 。\n\n请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。将乘积对 109 + 7 取余 后返回。\n\n注意：答案应为取余 之前 的最小值。\n\n\n:::details{text=\"示例 1\"}\n输入：p = 1\n\n输出：1\n\n解释：nums = [1] 。\n\n只有一个元素，所以乘积为该元素。\n:::\n\n:::details{text=\"示例 2\"}\n输入：p = 2\n\n输出：6\n\n解释：nums = [01, 10, 11] 。\n\n所有交换要么使乘积变为 0 ，要么乘积与初始乘积相同。\n\n所以，数组乘积 1 * 2 * 3 = 6 已经是最小值。\n:::\n\n:::details{text=\"示例 3\"}\n输入：p = 3\n\n输出：1512\n\n解释：nums = [001, 010, 011, 100, 101, 110, 111]\n\n- 第一次操作中，我们交换第二个和第五个元素最左边的数位。\n    - 结果数组为 [001, 110, 011, 100, 001, 110, 111] 。\n- 第二次操作中，我们交换第三个和第四个元素中间的数位。\n    - 结果数组为 [001, 110, 001, 110, 001, 110, 111] 。\n\n数组乘积 1 * 6 * 1 * 6 * 1 * 6 * 7 = 1512 是最小乘积。\n:::\n\n:::details{text=\"提示\"}\n`1 \u003C= p \u003C= 60`\n:::\n\n### Python题解\n\n没写出来，todo...\n\n### 总结\n\ntodo...\n\n## 第四题 - 你能穿过矩阵的最后一天\n\n\u003CBadge text = \"困难\" type = \"error\" />\n原题链接：[https://leetcode-cn.com/problems/last-day-where-you-can-still-cross/](https://leetcode-cn.com/problems/last-day-where-you-can-still-cross/)\n\n题都没看 遇到困难 睡大觉 - -\n","\r\n## 序言\r\n\r\n双11冲的腾讯云是真的香！正好嫌gtihub pages太慢了，索性迁移到腾讯云顺带备案！\r\n\r\n但是只放一个博客显然太亏了，所以用这篇博客记录下我用这个服务器干了些什么。\r\n\r\n## Nginx\r\n\r\n因为blog是vuepress生成的静态文件，所以直接丢Nginx了。\r\n\r\n- [https://nginx.org/](https://nginx.org/)\r\n\r\n## Let's encrypt\r\n\r\n之前服务器域名挂了cloudflare（减速cdn）实现https，但是有服务器之后显然是自动申请更方便。\r\n\r\n- [https://letsencrypt.org/](https://letsencrypt.org/)\r\n- [https://certbot.eff.org/](https://certbot.eff.org/)\r\n\r\n## frp\r\n\r\n内网穿透，暴露内网服务到公网，例如内网的远程登录等。\r\n- [https://github.com/fatedier/frp](https://github.com/fatedier/frp)\r\n- [https://gofrp.org/docs/](https://gofrp.org/docs/)\r\n\r\n## MySQL\r\n\r\n关系型数据库。\r\n\r\n- [https://www.mysql.com/](https://www.mysql.com/)\r\n\r\n## Redis\r\n\r\n非关系型数据库。\r\n\r\n- [https://redis.io/](https://redis.io/)\r\n\r\n## Microsoft OpenJDK\r\n\r\n自从微软开始编译OpenJDK之后就一直用微软的了 - -\r\n\r\n- [https://docs.microsoft.com/zh-cn/java/openjdk/install](https://docs.microsoft.com/zh-cn/java/openjdk/install)","\n## 序言\n\n虽然在各类编程语言中自带的排序API十分高效，但是掌握基本的排序算法还是非常有必要的。\n\n## 冒泡排序\n\n经典入门排序题，易于理解。核心思想在于不断交换出最大值放到最后。缺点是交换次数较多。\n\n```python\ndef bubbleSort(nums: List[int]) -> List[int]:\n    n = len(nums)\n    for i in range(n - 1):\n        for j in range(n - i - 1):\n            if nums[j] > nums[j + 1]:\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n    return nums\n```\n\n- 时间复杂度：O(n^2)。时间复杂度近似n的阶加, 即$\\frac{n(n-1)}{2}$ = $\\frac{n^2}{2}$，省略常数1/2,\n- 空间复杂度：O(1)\n- 稳定\n\n:::tip\nnums参数默认为`List[int]`\n:::\n\n## 选择排序\n\n可以看成是冒泡的升级版，核心思想在于不断交换出最小值放到最前。使用min变量记录最小值索引避免了冒泡的频繁交换。\n\n```python\ndef selectionSort(nums):\n    n = len(nums)\n    for i in range(n):\n        minIndex = i\n        for j in range(i + 1, n):\n            if nums[minIndex] > nums[j]:\n                minIndex = j\n        nums[i], nums[minIndex] = nums[minIndex], nums[i]\n    return nums\n```\n\n- 时间复杂度 O(n^2)\n- 空间复杂度 O(1)\n- 不稳定\n\n:::warning\n一直不解为什么选择排序不稳定，网上看到最多的解释是：选择排序的不稳定在于会改变原有相同数据的相对顺序。\n\n一个例子，现在有3个数，分别为:\n\nindex：0 1 2\n\nvalue：2 2 1\n\n选择排序第一次将3和1替换，也就是index为0和2的数替换，此时序列变成了2-1-0，而稳定的做法应该是index序列为2-0-1。\n\n这看起来是个结论，对于解释为什么改变了原有顺序可能会不稳定，多属性排序似乎是个更好的的例子。\n\n假设现在按照学生的 **分数（DESC）** 和 **姓名(ASC)** 对学生进行排序，数据如下：\n\n学生1 学生2 学生3\n\n90 90 100\n\n按照选择排序，此时先按照分数进行排序，则为 **学生3-学生2-学生1** ，这改变了学生1，学生2的顺序，然后之后按照姓名排序，发现又需要交换学生1，学生2的位置，为 **学生3-学生1-学生2** 。\n\n假设这里是冒泡（稳定排序），则不会改成学生1和学生2的相对顺序。\n:::\n\n## 插入排序\n\n插入排序的思想则更为简单，想象一下你正在玩扑克牌，对于每次新抽的牌，你总是会将它插入到合适的顺序，插入排序同样如此，我们假设第一个是初始牌(已排序部分)，那么对于第1到n的其他牌(未排序状态)，我们则每次对比该张牌是否比上一张牌更小，如果是则交换。\n\n反复进行比较直至新牌被插入到合适的位置，这样当所有牌都比较完之后，整个牌组也是有序的。\n\n```python\ndef insertionSort(nums):\n    n = len(nums)\n    for i in range(1, n):\n        cur = nums[i]\n        bef = i - 1\n        while bef >= 0 and cur \u003C nums[bef]:\n            nums[bef + 1] = nums[bef]\n            bef -= 1\n        nums[bef + 1] = cur\n    return nums\n```\n\n- 时间复杂度 O(n^2)\n- 空间复杂度 O(1)\n- 稳定\n\n:::warning\n插入排序的时间不稳定（参考上节warning，理解排序算法不稳定与算法时间不稳定的区别）。\n\n最好的情况为 n-1 次比较和 0 次交换。\n\n最差的情况为 $\\frac{n^2}{2}$ 次比较和 $\\frac{n^2}{2}$ 次交换。\n\n平均为 $\\frac{n^2}{4}$ 比较和 $\\frac{n^2}{4}$ 交换。\n:::\n\n## 希尔排序\n\n希尔排序是插入排序的一种优化，在大部分情况下，希尔排序都要优于插入排序，并且希尔排序的代码比较简单，适合于中等数据量。\n\n希尔排序的基本思想是先将原序列按照一定的间隔分成不同组，通过对不同组的对应部分进行插入排序，首先将序列变为基本有序的状态，之后通过不断调整间隔直至1进行插入排序即可。\n\n希尔排序是不稳定的排序，但是最差的情况会比快排最差好些，同时时间复杂度也比较难推，并且对于不同的增量序列有着不同的时间复杂度，所以这里仅提供Knuth增量序列（h＝3 * h + 1）的最差时间复杂度约为O($n^\\frac{3}{2}$)。\n\n:::tip\n- 增量序列：决定间隔按照何种方式定义以及递减\n- Knuth增量序列：一个性能比较好且较易求出的增量序列，公式为 h = 3 * h + 1，条件是小于长度的 $\\frac{1}{3}$\n- 顺带一嘴Knuth就是KMP算法的那个K，同时创立了Tex系统，图灵奖获得者。\n:::\n\n```python\ndef shellsort(nums: list):\n    n = len(nums)\n    h = 1\n    while h \u003C n // 3:\n        h = h * 3 + 1\n    while h > 0:\n        for i in range(h, n):\n            j = i - h\n            cur = nums[i]\n            while j >= 0 and cur \u003C nums[j]:\n                nums[j + h] = nums[j]\n                j -= h\n            nums[j + h] = cur\n        h = (h - 1) // 3\n    return nums\n```\n\n- 时间复杂度 O(nlogn)\n- 空间复杂度 O(1)\n- 不稳定\n\n## 归并排序\n\n归并排序利用了分治的思想（Divide-and-Conquer），将序列进行分成n个组合，随后两两进行比较并排序，通过不断组合子数组达到快速排序的目的。\n\n归并排序的好处在于高效的性能，唯一的不足在于消耗了额外的空间，即tmp数组O(n)。\n\n同时由于以下代码采取了递归的方式，递归的最大深度为logn，因此空间复杂度还需要logn的栈空间。\n\n此外，也可以考虑使用迭代的方式实现，这里不多介绍。\n\n```python\ndef mergeSort(self, nums: List[int], l: int, r: int) -> None:\n    if l == r:\n        return\n    mid = (l + r) // 2\n    self.mergeSort(nums, l, mid)\n    self.mergeSort(nums, mid + 1, r)\n    tmp = []\n    i = l\n    j = mid + 1\n    while i \u003C= mid or j \u003C= r:\n        if i > mid or (j \u003C= r and nums[j] \u003C nums[i]):\n            tmp.append(nums[j])\n            j += 1\n        else:\n            tmp.append(nums[i])\n            i += 1\n    nums[l: r + 1] = tmp\n```\n\n- 时间复杂度 O(nlogn)\n- 空间复杂度 O(n)\n- 稳定\n\n## 快速排序\n\n快速排序基本称得上是老生常谈的话题了，它的基本思想是从数组中选取一个主元（pivot），然后遍历之后其他元素，大于它的我们将它放到右边，小于它的则放到左边，之后再对左右子序列进行同样的操作，直到结束。\n\n快排的pivot的选择方式很多，这里采用的是随机pivot，复杂度在算法导论第七章证明期望为O(nlogn)，空间复杂度则取决于递归深度，最差O(n)，期望O(logn)\n\n```python\ndef randomizedPartition(self, nums: List[int], l: int, r: int) -> int:\n        pivot = random.randint(l, r)\n        nums[pivot], nums[r] = nums[r], nums[pivot]\n        i = l - 1\n        for j in range(l, r):\n            if nums[j] \u003C nums[r]:\n                i += 1\n                nums[i], nums[j] = nums[j], nums[i]\n        i += 1\n        nums[i], nums[r] = nums[r], nums[i]\n        return i\n\ndef randomizedQuicksort(self, nums: List[int], l: int, r: int) -> None:\n    if l >= r:\n        return\n    mid = self.randomizedPartition(nums, l, r)\n    self.randomizedQuicksort(nums, l, mid - 1)\n    self.randomizedQuicksort(nums, mid + 1, r)\n```\n\n- 时间复杂度 O(nlogn)\n- 空间复杂度 O(logn)\n- 不稳定\n\n:::warning\n快速排序是不稳定的排序，最差的情况的时间复杂度为O(n^2)，但是这种情况不多见，一般对于一个较为随机的大序列而言，快速排序甚至能比一些其他时间复杂度稳定于O(nlogn)的排序算法要快上许多，例如归并排序。\n:::\n\n## 堆排序\n\n堆排序是一种基于数据结构的排序，堆是完全二叉树，同时分为小根堆和大根堆，对于升序排序选择大根堆，反之选择小根堆。\n\n因为堆顶的数总是最大或者最小的，基于这个性质，我们可以得到依次获取最大或者最小值，然后对其他数进行同样的操作，因此堆排序也可以认为是优化的选择排序。\n\n堆排序比选择排序的好处在于不必消耗线性时间去搜索比较未排序的部分。\n\n```python\ndef maxHeapify(self, heap, root, heapLen):\n        p = root\n        # control the node have sub node and not in last layer\n        while p * 2 + 1 \u003C heapLen:\n            # sub node index of p\n            l, r = p * 2 + 1, p * 2 + 2\n            # check which is the smaller sub node\n            if heapLen \u003C= r or heap[r] \u003C heap[l]:\n                nex = l\n            else:\n                nex = r\n            # compare and swap if needed\n            if heap[p] \u003C heap[nex]:\n                heap[p], heap[nex] = heap[nex], heap[p]\n                p = nex\n            else:\n                break\n\n    def buildHeap(self, heap):\n        for i in range(len(heap) - 1, -1, -1):\n            self.maxHeapify(heap, i, len(heap))\n\n    def heapSort(self, nums):\n        self.buildHeap(nums)\n        for i in range(len(nums) - 1, -1, -1):\n            nums[i], nums[0] = nums[0], nums[i]\n            self.maxHeapify(nums, 0, i)\n```\n\n- 时间复杂度 O(nlogn)\n- 空间复杂度 O(1)\n- 不稳定\n\n---\n\n:::warning\n以上是基于比较的排序算法，接下来的三种排序将是基于非比较的排序算法\n:::\n\n:::tip\n任何非比较的排序算法理论上均要比基于比较的排序算法要快。\\\n非比较排序算法通常时间复杂度为O(n+k)，而基于比较的排序算法是O(nlogn)\n:::\n\n---\n\n## 计数排序\n\n计数排序的思想非常简单，前提是序列是整数且范围确定，创建一个bucket，然后进行一次遍历，统计元素出现的次数，接下来只需要再次遍历bucket，将数填充回原序列即可。时间复杂度为O(n+k)，k为bucket数组的长度。\n\n```python\ndef countingSort(nums, bucketLen):\n    bucket = [0] * bucketLen\n    for num in nums:\n        bucket[num] += 1\n    index = 0\n    for i in range(bucketLen):\n        while bucket[i] > 0:\n            nums[index] = i\n            index += 1\n            bucket[i] -= 1\n    return nums\n```\n\n- 时间复杂度 O(n+k)\n- 空间复杂度 O(k)\n- 稳定\n\n## 桶排序\n\n桶排序可以理解为计数排序的通解，只不过桶排序的可以控制每个桶的容量。桶排序的核心思想在于把数分配进不同的桶，最后每个桶进行单独排序，最后顺序遍历桶进行合并结果，此处示例代码使用插入排序对每个桶内元素进行排序。（插入排序对于少量数据而言效率较高）\n\n但是对于其它语言而言，数组需要预先分配内存，而桶排序最差的情况需要为每个桶都分配n的空间（当然也可以考虑初始数组-数据扩容的方案。）。而链表虽然不需要提前分配过多空间，但对于链表排序效率也是问题。\n\n```python\ndef bucketSort(nums, bucketSize):\n    def insertionSort(arr):\n        for i in range(1, len(arr)):\n            cur = arr[i]\n            bef = cur - 1\n            while bef >= 0 and arr[bef] > cur:\n                arr[bef + 1] = arr[bef]\n                bef -= 1\n            arr[bef + 1] = cur\n        return arr\n\n    buckets = [[] for _ in range(bucketSize)]\n    for num in nums:\n        buckets[int(bucketSize * num)].append(num)\n    for i in range(bucketSize):\n        buckets[i] = insertionSort(buckets[i])\n    sortIndex = 0\n    for i in range(bucketSize):\n        for j in range(len(buckets[i])):\n            nums[sortIndex] = buckets[i][j]\n            sortIndex += 1\n    return nums\n```\n\n- 时间复杂度 O(n+k)\n- 空间复杂度 O(n+k)\n- 稳定\n\n:::warning\n桶排序不是稳定的，在数据分布最平均时，可达到最大效率，时间复杂度为O(n)，最差情况是所有数据都被放进1个桶，此时则为完全插入排序，时间复杂度退化到O(n^2^)。因此桶排序有很多变种，这里不再过多介绍。\n:::\n\n## 基数排序\n\n基数排序的思想在于把取出每位数，从低位到高位依次排序，当排到最高位时排序结束，排序结束。\n\n由于每位数的范围为0到9，因此内部排序非常适合使用计数排序。\n\n```python\ndef radixSort(nums):\n    def countingSort(nums, exp, n):\n        count = [0] * 10\n        output = [0] * n\n        for i in range(n):\n            count[(nums[i] // exp) % 10] += 1\n        # ASC\n        for i in range(1, 10):\n            count[i] += count[i - 1]\n        # DESC\n        # for i in range(8, -1, -1):\n        #     count[i] += count[i + 1]\n        for i in range(n-1, -1, -1):\n            num = nums[i] // exp\n            output[count[num % 10] - 1] = nums[i]\n            count[num % 10] -= 1\n        for i in range(n):\n            nums[i] = output[i]\n\n    n = len(nums)\n    ma = max(nums)\n    exp = 1\n    while ma // exp >= 1:\n        countingSort(nums, exp, n)\n        exp *= 10\n    return nums\n```\n\n- 时间复杂度 O(n × k)\n- 空间复杂度 O(n + k)\n- 稳定\n\n## 总结\n\n| 排序算法 | 平均时间复杂度  | 最好情况        | 最坏情况        | 空间复杂度    | 排序方式      | 稳定性 |\n| :--- | :-------: | :----------: | :----------: | :-------: | :--------: | :--: |\n| 冒泡排序 | O(n^2^)  | O(n)        | O(n^2^)     | O(1)     | In-Place  | 稳定  |\n| 选择排序 | O(n^2^)  | O(n^2^)     | O(n^2^)     | O(1)     | In-Place  | 不稳定 |\n| 插入排序 | O(n^2^)  | O(n)        | O(n^2^)     | O(1)     | In-Place  | 稳定  |\n| 希尔排序 | O(nlogn) | O(nlog^2^n) | O(nlog^2^n) | O(1)     | In-Place  | 不稳定 |\n| 归并排序 | O(nlogn) | O(nlogn)    | O(nlogn)    | O(n)     | Out-Place | 稳定  |\n| 快速排序 | O(nlogn) | O(nlogn)    | O(n^2^)     | O(logn)  | In-Place  | 不稳定 |\n| 堆排序  | O(nlogn) | O(nlogn)    | O(nlogn)    | O(1)     | In-Place  | 不稳定 |\n| 计数排序 | O(n + k) | O(n + k)    | O(n + k)    | O(k)     | Out-Place | 稳定  |\n| 桶排序  | O(n + k) | O(n + k)     | O(n^2^)     | O(n + k) | Out-Place | 稳定  |\n| 基数排序 | O(n × k) | O(n × k)    | O(n × k)    | O(n + k) | Out-Place | 稳定  |\n","\r\n## 修改参数提示快捷键\r\n\r\nvscode建议修改按键绑定，修改shortcuts快捷键，`ctrl k` + `ctrl s`，\r\n\r\n然后搜索trigger parameter hint，修改为`ctrl p`\r\n\r\n默认`ctrl p`是被go to绑定了，将go to快捷键切换为参数提示默认的`ctrl shift space`\r\n\r\n然后就是Java的坑，还需要在setting - extensions - java\r\n\r\n搜索signature help，设置为enable。\r\n\r\n## 常用快捷键\r\n\r\n- format: `shift + alt + f`\r\n\r\n- organize import: `shift + alt + o`\r\n\r\n- assign variable: `ctrl + shift + r`\r\n\r\n","\n## 前言\n\n其实很早的时候就听到了copilot的消息，那个时候以为copilot只是个比较只能的代码提示工具，再加上还处于测试阶段，于是也没有去申请，但是在前段时间看到别人分享的copilot写算法题，顿时觉得十分有趣，便去申请了preview资格，直到最近才获得资格，所以有了这篇文章。\n\n## 准备工作\n\n直接上官网申请资格即可。\n\n:::tip\n[https://copilot.github.com/](https://copilot.github.com/)\n:::\n\n需要注意目前仅支持以下平台\n\n- [Visual Studio](https://github.com/github/copilot-docs/blob/main/docs/visualstudio/gettingstarted.md#getting-started-with-github-copilot-in-visual-studio)\n\n- [Visual Studio Code](https://github.com/github/copilot-docs/blob/main/docs/visualstudiocode/gettingstarted.md#getting-started-with-github-copilot-in-visual-studio-code)\n\n- [JetBrains](https://github.com/github/copilot-docs/blob/main/docs/jetbrains/gettingstarted.md#getting-started-with-github-copilot-in-jetbrains)\n\n- [Neovim](https://github.com/github/copilot.vim#getting-started)\n\n这边目前是使用VSCode进行测试，VSCode YYDS!\n\n具体操作就是打开VSCode，下载Github Copilot插件，会跳转Github网页进行授权，之后会提示一个许可协议，同意之后右下角会出现个copilot的logo，点击可选择是否激活。\n\n:::warning\n建议在不重要的本地项目中进行测试，目前copilot还不支持离线工作。\n:::\n\n## 测试\n\n下载完之后当然是进行测试了，首先测试了通过注释生成代码，这里试了下获取最大公约数，效果如下图：\n\n![20220326203427.png](https://cdn.jsdelivr.net/gh/alightyoung/static@main/img/20220326203427.png)\n\n事实上我在输入get greastest注释时，copilot就已经给我补全到common divisor.\n\n除了英文注释之外，\n\n![20220326205604.png](https://cdn.jsdelivr.net/gh/alightyoung/static@main/img/20220326205604.png)\n\n字都没打完就联想完了。。。\n\n以下是中文注释联想的结果\n\n![20220326205749.png](https://cdn.jsdelivr.net/gh/alightyoung/static@main/img/20220326205749.png)\n\n~~常见的函数联想，还是十分有效的。唯一的问题是中文输入时，tab补全~~\n\n![20220326205942.png](https://cdn.jsdelivr.net/gh/alightyoung/static@main/img/20220326205942.png)\n\n~~实际上不是中文的问题，切换到英文输入法tab同样无效，可能是markdown文件中不行吧，需要hover到补全内容上点accept才行。~~\n\n基本可以确定是和markdown all in one插件冲突，导致copilot tab无法补全。\n\n参考：[https://github.com/microsoft/vscode/issues/131953](https://github.com/microsoft/vscode/issues/131953)\n\n同时，上图的4个快捷键也十分有用，建议熟记。另外补充一个快捷键，`alt + \\`，手动触发copilot的联想。\n\n其中`alt + [`， `alt + ]`是切换建议，`ctrl enter`是开一个tab查看更多建议。\n\n## 最后\n\n基本的尝试之后，觉得copilot的联想功能还是不错的，但是还是有一些问题，比如，文字较多的时候可能会出现理解偏差，随便测试了到ez题，但是文字描述较为复杂，然后不出意料地wa了（楽\n\n还有就是数据安全的问题了，如果以后能有离线的的版本可能会让大家更放心些。\n\n此外，因为目前只是在测试阶段，以后可能会是个类似tabnine之类的商业项目，且用且珍惜。\n\n但是以上这些问题仍旧瑕不掩瑜，copilot依旧是一个十分优秀的插件，有兴趣的可以自行官网申请测试尝尝鲜。\n\n\n","\r\n## Preface\r\nwrite this to log some useful (probably) Java tips when I face some confusing 'bugs'.\r\n\r\n1. toLowerCase / toUpperCase do not change the original string.","\n## Docker Base Command\n\n``` sh\n\n# pull a image from docker hub or another private registry\ndocker pull redis:4.0\n\n# -d: detached mode\n# -p: binding host and docker container port\n# --name: setting the name of container\n# run an image, it will create a container as the environment\ndocker run -d -p 6379:6379 --name redis40 redis:4.0\n\n# -a: show all container process info(including the container ID, name, etc.), even if the container already exited\ndocker ps -a\n\n# go to container inner with an interactive terminal\ndocker exec -it \u003CcontainerID> /bin/bash\n\n# get container logs\n# -f: follow mode\ndocker logs -f \u003CcontainerID>\n\n# start / stop / restart a comtainer with containerID or name\ndocker start / stop / restart \u003CcontainerID | container name>\n\n# remove container\n# -v also remove the volumn of container\ndocker rm \u003CcontainerID>\n\n# show images info\ndocker images\n\n# remove images\ndocker image rm \u003CimageID>\n```\n\n## Volume\n\n``` sh\n\n# create a volume\ndocker volume create \u003Cvolume name>\n\n# ls: show all volumes\n# -f: equals to --filter\n# -f \"dangling=true\" filter all volumes that are not used by at least one container\ndocker volume ls\n\n# inspect a volume\ndocker volume inspect \u003CvolumeID or name>\n\n# start a container with volume, you can also use in docker run command\ndocker run -d --name nginx -v myvol:/app nginx\n\n# remove a volume\ndocker volumn rm \u003Cvolume ID or name>\n\n# remove all volumes which are not binding to container (can binding more than one container)\ndocker volumn prune\n\n```\n\nview details: [docker volume](https://docs.docker.com/engine/reference/commandline/volume/)\n\n## Network\n\n``` sh\n\n# show all network\ndocker network ls\n\n# there are three default network (1. bridge 2. host 3. none)\n# by default, docker container will use the bridge network\n\n# to inspect network status\ndocker network inspect bridge\n\n# to find the container ip address, you can use\n# in windows, change the grep to findstr\ndocker inpect \u003CcontainerID> | grep -i \"ipaddress\"\n# or\ndocker network inspect \u003Cthe network your container in>\n\n# create network\n# driver : 1. bridge 2. host 3. none\ndocker network create --driver bridge \u003Cnetwork name>\n\n# now you can run some image with --network to specify the network, etc.\ndocker run -d --name redis --network \u003Cnetwork name> -p 6379:6379 redis\n\n# delete network\ndocker network rm \u003Cnetwork name>\n```\n\nview details: [docker network](https://docs.docker.com/engine/reference/commandline/network/)\n\n## Docker Compose\n\nFor running mutiple docker containers.\n\n``` sh\ndocker-compose -f \u003Cconfig file path> \u003Cup or down> -d\n# you also can use compose in docker CLI like below if your docker version is recently released\ndocker compose -f \u003Cconfig file path> \u003Cup or down> -d\n```\nNormally, you also need a configuration file to tell docker-compose which action you want to do.\n\nNote the configuration file type is yaml.\n\nFor example.\n\n```yaml\nversion: \"2.6.1\"\nservices:\n  redis:\n    image: \"redis\"\n    container_name: \"redis\"\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis:/data\n  mysql:\n    image: \"mysql\"\n    container_name: \"mysql\"\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - mysql:/var/lib/mysql\n    environment:\n      MYSQL_ROOT_PASSWORD: password\n\nvolumes:\n  mysql:\n  redis:\n\n# volumes:\n#   mysql:\n#     external: true\n#   redis:\n#     external:\n#       name: \"\"\n#   postgre:\n#     driver: local\n```\n\n:::tip\ndocker compose will create a network with bridge driver by default, and all services(containers) will running in the same network.\n:::\n\nview details: [docker compose](https://docs.docker.com/engine/reference/commandline/compose/)\n\n## Docker Build Own Image & Push to Repository\n\n### Build from Dockerfile\n\ndockerfile example\n```\nFROM nginx\n\nCOPY ./index.html /usr/share/nginx/html\n```\n\nthen `docker build -t alightyoung/mynginx:1.0 .`\n\nuse `docker image ls` to show image.\n\nand test with `docker run -d -p 8080:80 alightyoung/mynginx:1.0`\n\n:::warning\nTo push an image to Docker Hub, you must first name your local image using your Docker Hub username and the repository name that you created through Docker Hub on the web.\n:::\n\n```sh\n# build\ndocker build -t \u003Chub-user>/\u003Crepo-name>[:\u003Ctag>]\n# re-tagging\ndocker tag \u003Cexisting-image> \u003Chub-user>/\u003Crepo-name>[:\u003Ctag>]\n# commit changes\ndocker commit \u003Cexisting-container> \u003Chub-user>/\u003Crepo-name>[:\u003Ctag>]\n```\n\nview details: [docker build](https://docs.docker.com/engine/reference/commandline/build/)\n\n### Push to Docker Hub Repository\n\nFirst, you need to register an account of docker hub and create a repository.\n\n\n:::warning\nnote the repo name must be the same as the name of the image you have just built.\n:::\n\nthen use `docker login` to verify your account.\n\nby using `docker push alightyoung/mynginx:1.0` to push local image to docker hub.\n\nif your image is public then anyone can pull your image using `docker pull alightyoung/mynginx:1.0`\n\nview details:\n- [docker login](https://docs.docker.com/engine/reference/commandline/login/)\n- [docker push](https://docs.docker.com/engine/reference/commandline/push/)\n- [repositories](https://docs.docker.com/docker-hub/repos/)\n\n## Build new image from existed image\n\n- run existed image by `docker run -it --rm \u003Cimage_id>`\n- copy or exec in container by `docker cp /local/data containerId:/root/data/` or `docker exec -it \u003Ccontainer_id> bash`\n- commit a new image from the container by `docker commit \u003Ccontainer_id> imagename:tagname`\n\n:::warning\nYou can not exit the container started by docker run before commit successful.\n:::\n\n\n\n\n\n","\n:::tip\nWorking on 1.3.524\n\nTheme Foler: `${wox}/app-version/Themes`\n:::\n\n### BlurBlackRadius.xaml\n\n```xml\n\u003CResourceDictionary xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n                    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n                    xmlns:system=\"clr-namespace:System;assembly=mscorlib\">\n    \u003CResourceDictionary.MergedDictionaries>\n        \u003CResourceDictionary Source=\"Base.xaml\" />\n    \u003C/ResourceDictionary.MergedDictionaries>\n\n    \u003Csystem:Boolean x:Key=\"ThemeBlurEnabled\">True\u003C/system:Boolean>\n\n    \u003CStyle x:Key=\"QueryBoxStyle\" BasedOn=\"{StaticResource BaseQueryBoxStyle}\" TargetType=\"{x:Type TextBox}\">\n        \u003CSetter Property=\"Foreground\" Value=\"#FFFFFFFF\" />\n        \u003CSetter Property=\"Background\" Value=\"#01000001\" />\n    \u003C/Style>\n\n    \u003CStyle x:Key=\"WindowBorderStyle\" BasedOn=\"{StaticResource BaseWindowBorderStyle}\" TargetType=\"{x:Type Border}\">\n        \u003CSetter Property=\"Background\">\n            \u003CSetter.Value>\n                \u003CSolidColorBrush Color=\"Black\" Opacity=\"0.3\"/>\n            \u003C/Setter.Value>\n        \u003C/Setter>\n        \u003CSetter Property=\"CornerRadius\" Value=\"10\"/>\n        \u003C!-- \u003CSetter Property=\"Margin\" Value=\"10\"/> -->\n        \u003C!-- \u003CSetter Property=\"Window.Effect\">\n            \u003CSetter.Value>\n                \u003CDropShadowEffect Color=\"black\"\n                                  ShadowDepth=\"0\"\n                                  BlurRadius=\"10\"/>\n            \u003C/Setter.Value>\n        \u003C/Setter> -->\n    \u003C/Style>\n\n    \u003CStyle x:Key=\"WindowStyle\" BasedOn=\"{StaticResource BaseWindowStyle}\" TargetType=\"{x:Type Window}\">\n        \u003CSetter Property=\"Background\">\n            \u003CSetter.Value>\n                \u003CSolidColorBrush Color=\"white\" Opacity=\"0\"/>\n            \u003C/Setter.Value>\n        \u003C/Setter>\n        \u003C!-- \u003CSetter Property=\"Background\" Value=\"Transparent\"/> -->\n    \u003C/Style>\n\n    \u003CStyle x:Key=\"PendingLineStyle\" BasedOn=\"{StaticResource BasePendingLineStyle}\" TargetType=\"{x:Type Line}\">\n    \u003C/Style>\n\n    \u003C!-- Item Style -->\n    \u003CStyle x:Key=\"ItemTitleStyle\"  BasedOn=\"{StaticResource BaseItemTitleStyle}\" TargetType=\"{x:Type TextBlock}\">\n        \u003CSetter Property=\"Margin\" Value=\"0, -10\"/>\n        \u003CSetter Property=\"Foreground\" Value=\"#FFFFFFFF\"/>\n    \u003C/Style>\n    \u003CStyle x:Key=\"ItemSubTitleStyle\" BasedOn=\"{StaticResource BaseItemSubTitleStyle}\" TargetType=\"{x:Type TextBlock}\" >\n        \u003CSetter Property=\"Foreground\" Value=\"#FFFFFFFF\"/>\n    \u003C/Style>\n    \u003CStyle x:Key=\"ItemTitleSelectedStyle\" BasedOn=\"{StaticResource BaseItemTitleSelectedStyle}\"  TargetType=\"{x:Type TextBlock}\" >\n        \u003CSetter Property=\"Margin\" Value=\"0, -10\"/>\n        \u003CSetter Property=\"Foreground\" Value=\"#FFFFFFFF\"/>\n    \u003C/Style>\n    \u003CStyle x:Key=\"ItemSubTitleSelectedStyle\" BasedOn=\"{StaticResource BaseItemSubTitleSelectedStyle}\" TargetType=\"{x:Type TextBlock}\" >\n        \u003CSetter Property=\"Foreground\" Value=\"#FFFFFFFF\"/>\n    \u003C/Style>\n    \u003CSolidColorBrush x:Key=\"ItemSelectedBackgroundColor\">#356ef3\u003C/SolidColorBrush>\n\n    \u003C!-- button style in the middle of the scrollbar -->\n    \u003CStyle x:Key=\"ThumbStyle\" BasedOn=\"{StaticResource BaseThumbStyle}\" TargetType=\"{x:Type Thumb}\">\n    \u003C/Style>\n\n    \u003CStyle x:Key=\"ScrollBarStyle\" BasedOn=\"{StaticResource BaseScrollBarStyle}\" TargetType=\"{x:Type ScrollBar}\">\n        \u003CSetter Property=\"Background\" Value=\"#a0a0a0\"/>\n    \u003C/Style>\n\u003C/ResourceDictionary>\n```\n\n### BlueWhiteRadius.xaml\n\n```xml\n\u003CResourceDictionary xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" xmlns:system=\"clr-namespace:System;assembly=mscorlib\">\n    \u003CResourceDictionary.MergedDictionaries>\n        \u003CResourceDictionary Source=\"Base.xaml\" />\n    \u003C/ResourceDictionary.MergedDictionaries>\n\n    \u003Csystem:Boolean x:Key=\"ThemeBlurEnabled\">True\u003C/system:Boolean>\n\n    \u003CStyle x:Key=\"QueryBoxStyle\" BasedOn=\"{StaticResource BaseQueryBoxStyle}\" TargetType=\"{x:Type TextBox}\">\n        \u003CSetter Property=\"Foreground\" Value=\"#FF000000\" />\n        \u003CSetter Property=\"Background\" Value=\"#01FFFFFF\" />\n    \u003C/Style>\n\n    \u003CStyle x:Key=\"WindowBorderStyle\" BasedOn=\"{StaticResource BaseWindowBorderStyle}\" TargetType=\"{x:Type Border}\">\n        \u003CSetter Property=\"Background\">\n            \u003CSetter.Value>\n                \u003CSolidColorBrush Color=\"white\" Opacity=\"0.3\" />\n            \u003C/Setter.Value>\n        \u003C/Setter>\n        \u003CSetter Property=\"CornerRadius\" Value=\"10\" />\n    \u003C/Style>\n\n    \u003CStyle x:Key=\"WindowStyle\" BasedOn=\"{StaticResource BaseWindowStyle}\" TargetType=\"{x:Type Window}\">\n        \u003CSetter Property=\"Background\">\n            \u003CSetter.Value>\n                \u003CSolidColorBrush Color=\"White\" Opacity=\"0\" />\n            \u003C/Setter.Value>\n        \u003C/Setter>\n    \u003C/Style>\n\n    \u003CStyle x:Key=\"PendingLineStyle\" BasedOn=\"{StaticResource BasePendingLineStyle}\" TargetType=\"{x:Type Line}\">\u003C/Style>\n\n    \u003C!-- Item Style -->\n    \u003CStyle x:Key=\"ItemTitleStyle\" BasedOn=\"{StaticResource BaseItemTitleStyle}\" TargetType=\"{x:Type TextBlock}\">\n        \u003CSetter Property=\"Margin\" Value=\"0, -10\" />\n        \u003CSetter Property=\"Foreground\" Value=\"#FF000000\" />\n    \u003C/Style>\n    \u003CStyle x:Key=\"ItemSubTitleStyle\" BasedOn=\"{StaticResource BaseItemSubTitleStyle}\" TargetType=\"{x:Type TextBlock}\">\n        \u003CSetter Property=\"Foreground\" Value=\"#FF000000\" />\n    \u003C/Style>\n    \u003CStyle x:Key=\"ItemTitleSelectedStyle\" BasedOn=\"{StaticResource BaseItemTitleSelectedStyle}\" TargetType=\"{x:Type TextBlock}\">\n        \u003CSetter Property=\"Margin\" Value=\"0, -10\" />\n        \u003CSetter Property=\"Foreground\" Value=\"#FFFFFFFF\" />\n    \u003C/Style>\n    \u003CStyle x:Key=\"ItemSubTitleSelectedStyle\" BasedOn=\"{StaticResource BaseItemSubTitleSelectedStyle}\" TargetType=\"{x:Type TextBlock}\">\n        \u003CSetter Property=\"Foreground\" Value=\"#FFFFFFFF\" />\n    \u003C/Style>\n    \u003CSolidColorBrush x:Key=\"ItemSelectedBackgroundColor\">#356ef3\u003C/SolidColorBrush>\n\n    \u003C!-- button style in the middle of the scrollbar -->\n    \u003CStyle x:Key=\"ThumbStyle\" BasedOn=\"{StaticResource BaseThumbStyle}\" TargetType=\"{x:Type Thumb}\">\u003C/Style>\n\n    \u003CStyle x:Key=\"ScrollBarStyle\" BasedOn=\"{StaticResource BaseScrollBarStyle}\" TargetType=\"{x:Type ScrollBar}\">\n        \u003CSetter Property=\"Background\" Value=\"#a0a0a0\" />\n    \u003C/Style>\n\u003C/ResourceDictionary>\n\n```\n","\n### Download ISO\n\nThe first thing you need to do is download Debian image file, which can be found here, [Downloading Debian CD/DVD images via HTTP/FTP](https://www.debian.org/CD/http-ftp/).\n\n### Create Bootable USB Driver\n\n**BURN Tools**: to create bootable USB drivers.\n\n**Live USB Driver**: supports live driver, which means it can set persistence partition.\n\n1. [Rufus](https://rufus.ie/zh/) (Support Live USB Driver)\n\n2. [balenaEtcher](https://www.balena.io/etcher/)\n\n3. [UNetbootin](https://unetbootin.github.io/) (Support Live USB Driver)\n\n\n### Free a Patition or Disk\n\nIn Windows11, right click the windows menu, and select disk management. and then refer to [Overview of Disk Management | Microsoft Docs](https://docs.microsoft.com/en-us/windows-server/storage/disk-management/overview-of-disk-management)\n\nYou will need this space to store Debian OS and mounting file system.\n\n### Change Bios Settings\n\nAfter burning the Debian image, you should go to the bios settings (looking for help from your vendor website) to set the priority of the computer boot item and make sure the USB driver is in the top order.\n\n### Finsh Setup Guide\n\nJust follow the setup guide to finish the installation process. Be careful to mount the file system on disk or partition right, otherwise, you will never get those data back.\n\n### Setting Mirror Site\n\nJust edit /etc/apt/sources.list file, you'd better backup it first.\n\nrefer to [Debian Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/help/debian/)\n\n### Set Environment Variables\n\nJust edit `~/.bashrc` or `~/zshrc` and append the following commands.\n\nFor Example, add JDK to PATH.\n\n```bash\nexport JAVA_HOME=\"path/to/yourJDK\"\nexport PATH=\"PATH:$JAVA_HOME/bin/\"\n```\n\n### Questions & Answers\n\n1 failed to load firmware rtl...(-2).\n\n:::tip\nThis question occurred while I using the Rufus to burn the image, it was disappeared when I used balenaEtcher.\n\n**more references:**\n\n[unable to load firmware rtl_nic in Debian 11 | pacesettergraam](https://pacesettergraam.wordpress.com/2021/09/25/unable-to-load-firmware-rtl_nic-in-debian-11/)\n:::\n\n\n2 failed to detect external monitor.\n\n:::tip\nThis is because the dual graphics card is not properly driven, there are two solutions.\n\n- only use the discrete graphics card in bios settings if your computer vendor supports it.\n- refer to [NVIDIA Optimus](https://wiki.debian.org/NVIDIA%20Optimus)\n\n**more references:**\n\n[NvidiaGraphicsDrivers](https://wiki.debian.org/NvidiaGraphicsDrivers)\n:::\n\n3 Restart failed after installing nvidia-driver package.\n\n:::tip\nThis can be solved by entering recovery mode (advance boot Debian with recovery mode).\n\nfirst, you need to enable the network, you can check your network interface name by `ip link`, and up the interface by `ip link set eno1 up`, note modify the eno1 to yourself interface name that checked before this step. finally, use `dhclient eno1` to get ip address so that make network works.\n\nthe next thing you should do is run `apt purge nvidia-*` and `apt install linux-headers-amd64 nvidia-driver firmware-misc-nonfree`, these two commands can help you reinstall the nvidia driver.\n:::\n","\n## 起因\n\n因为平时的主力系统还是在使用 Windows，也没有特别强烈的需求非得使用 Linux，所以使用默认的 Windows Powershell 5 似乎是一件顺理成章的事情，然而在一次 VSCode 的 Terminal Shell Integration 的功能中，突然发现 Windows Powershell 5 居然不支持，于是便有了迁移的想法。\n\n然而事实上根本不需要迁移，因为 Powershell 7 与 Windows Powershell 5 是共存的，不过还是打算写下这篇日志用于记录切换到 Powerhsell 7 的过程。\n\n## Powershell 7\n\nPowershell 7 与 Windows Poershell 5 最大的区别是 Powershell 7 是全平台支持，并且被宣称为专门为云环境设计，这让很多使用 Windows Powershell 的人可以在远程 Linux 时也能使用自己熟悉的 Shell 环境。（虽然大部分人可能还是会选择 ZSH 吧），不过这种支持确实能给用户很大的诱惑力。\n\n关于 Powershell 7 的特性，这里就不赘述了，直接引用官方原话吧。\n\n> Powershell 7 Features\n>\n> Designed for cloud, on-premises, and hybrid environments, PowerShell 7 is packed with enhancements and new features.\n>\n> - Installs and runs side-by-side with Windows PowerShell\n> - Improved compatibility with existing Windows PowerShell modules\n> - New language features, like ternary operators and ForEach-Object -Parallel\n> - Improved performance\n> - SSH-based remoting\n> - Cross-platform interoperability\n> - Support for Docker containers\n>\n> 来自 [Migrating from Windows PowerShell 5.1 to PowerShell 7](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7?view=powershell-7.2)\n\n## 迁移\n\n1 安装 Powershell 7，[Windows 传送门](https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2) ，其他系统例如 Linux，macOS，Arm，Docker 可直接在侧栏切换即可。\n\n\n2 Windows Terminal 配置，会自动添加配置项，只需要切换默认配置文件为 Powershell 7 即可。\n\n\n3 默认的安装位置：\n    - Windows PowerShell 5.1: `$env:WINDIR\\System32\\WindowsPowerShell\\v1.0`\n    - PowerShell 6.x: `$env:ProgramFiles\\PowerShell\\6`\n    - PowerShell 7: `$env:ProgramFiles\\PowerShell\\7`\n\n\n4 Powershell 模块路径与 Windows Powershell 是隔离的，但是 Powershell 的默认模块路径时包括 Windows Powershell 的模块路径的，且这些模块大概率是兼容 Powershell 7 的，这意味着你不用重新下载模块，只需要拷贝一份原来的配置文件即可。想查看具体路径可以使用命令：`$Env:PSModulePath -split (';')`。以下是不同范围的模块路径说明。\n\n| Install Scope                    | Windows PowerShell 5.1                                | PowerShell 7.0                         |\n| :------------------------------- | :---------------------------------------------------- | :------------------------------------- |\n| PowerShell modules               | `$env:WINDIR\\system32\\WindowsPowerShell\\v1.0\\Modules` | `$PSHOME\\Modules`                      |\n| User installed AllUsers scope    | `$env:ProgramFiles\\WindowsPowerShell\\Modules`         | `$env:ProgramFiles\\PowerShell\\Modules` |\n| User installed CurrentUser scope | `$HOME\\Documents\\WindowsPowerShell\\Modules`           | `$HOME\\Documents\\PowerShell\\Modules`   |\n\n5 复制一份原来的配置文件到新的路径，文件不存在则新建。Windows Powershell 的路径是 `$HOME\\Documents\\WindowsPowerShell`，而 Powershell 的路径为 `$HOME\\Documents\\PowerShell`. 除了用户级别的配置文件之外，还有全局的配置文件，且配置文件的名字也发生了变化，具体参考以下命令输出结果。\n\n```powershell\nPS> $PROFILE | Select-Object *Host* | Format-List\n\nAllUsersAllHosts       : C:\\Program Files\\PowerShell\\7\\profile.ps1\nAllUsersCurrentHost    : C:\\Program Files\\PowerShell\\7\\Microsoft.PowerShell_profile.ps1\nCurrentUserAllHosts    : C:\\Users\\\u003Cuser>\\Documents\\PowerShell\\profile.ps1\nCurrentUserCurrentHost : C:\\Users\\\u003Cuser>\\Documents\\PowerShell\\Microsoft.PowerShell_profile.ps1\n```\n\n需要了解更多的配置项可以参考 [about_Profiles](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles)。\n\n6 最后再把 VSCode 的终端默认使用 Powershell 7 即可。步骤，打开命令面板 `Ctrl Shift P`，`Terminal: Select Default Profile`，然后选择 Powershell 7 的那个配置就行了。随后就可以体验到增强的终端功能了，比如执行命令失败会在命令的左边有个红色断点，成功为蓝色，同时右侧进度条也会有提醒，方便快速定位命令，同时左侧断点可以直接重新执行命令，复制命令输出为基础格式，HTML格式等，更多功能可以查看 [Terminal Shell Integration](https://code.visualstudio.com/docs/terminal/shell-integration)\n\n## 配置文件备份\n\n```powershell\n# oh my posh\noh-my-posh --init --shell pwsh --config ~/scoop/apps/oh-my-posh/current/themes/zash.omp.json | Invoke-Expression\n# posh-git\nImport-Module posh-git\n```\n\n## 结束\n\n至此，迁移到 Powershell 7 的工作基本结束，想了解 Powershell 的功能，例如远程支持，组策略相关可以查看[官方文档](https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7?view=powershell-7.2)后半部分。\n","\r\n## Hello World\r\n\r\n```kotlin\r\nfun main() {\r\n    println(\"Hello world\")\r\n}\r\n```\r\n\r\n## Define/Declare Keyword\r\n\r\n- `val`: define a variable that cannot be modified\r\n- `var`: define a variable that can be modified\r\n\r\n## Basic Data Type\r\n\r\n### Numbers\r\n\r\n#### Integer types\r\n\r\n- `Byte`: 8 bits\r\n- `Short`: 16 bits\r\n- `Int`: 32 bits\r\n- `Long`: 64 bits\r\n\r\n```kotlin\r\nfun main() {\r\n    var a: Byte = 8\r\n    var b: Short = 16\r\n    var c = 32\r\n    var d: Long = 64\r\n    println(a::class.simpleName) // Byte\r\n    println(b::class.java.typeName) // short\r\n    println(c::class.simpleName) // Int\r\n    println(d::class.java.typeName) // long\r\n}\r\n```\r\n\r\n#### Floating-point types\r\n\r\n- `Float`: 32 bits\r\n- `Double`: 64 bits\r\n\r\n```kotlin\r\nfun main() {\r\n    var a = 32f\r\n    var b = 64.0\r\n    println(a::class.simpleName) // Float\r\n    println(b::class.simpleName) // Double\r\n}\r\n```\r\n\r\n#### Literal constants\r\n\r\n```kotlin\r\nfun main() {\r\n    var a = 0xff // hexadecimal == 255\r\n    var b = 0b11 // binary == 3\r\n    var c = 1e9 // 1 * 10 ^ 9 ==> 1000000000\r\n    var d = 1_000_000_000 // 1000000000\r\n    // Octal literals are not supported in Kotlin.\r\n}\r\n```\r\n\r\n#### Unsigned Types\r\n\r\n- `UByte`\r\n- `UShort`\r\n- `UInt`\r\n- `ULong`\r\n- ...\r\n\r\n[https://kotlinlang.org/docs/unsigned-integer-types.html](https://kotlinlang.org/docs/unsigned-integer-types.html)\r\n\r\n### Array\r\n\r\n## Null Safety\r\n\r\n### `?` nullable types\r\n\r\nBy default, Kotlin data type is non-null types, unless you declare it as nullable types with `?`.\r\n\r\n```kotlin\r\nfun main() {\r\n    var a: Int = 1 // cannot be null\r\n    var b: Int? = null // can be null\r\n}\r\n```\r\n\r\n### Safe Calls\r\n\r\n```kotlin\r\nval a = \"Kotlin\"\r\nval b: String? = null\r\nprintln(b?.length)\r\nprintln(a?.length) // Unnecessary safe call\r\n\r\n// check null\r\nval a: String? = null\r\nprintln(if (a?.length == null) \"a is null\" else \"a not null\")\r\nprintln(a?.length == null)\r\na?.length?.dec()?.inc() // call in chain, return null instead of throw NPE\r\n\r\n// let: pass null in safe call\r\nval listWithNulls: List\u003CString?> = listOf(\"Kotlin\", null)\r\nfor (item in listWithNulls) {\r\n    item?.let { println(it) } // prints Kotlin and ignores null\r\n}\r\n\r\n// safe call on left side of assignment\r\n// If either `person` or `person.department` is null, the function is not called:\r\n// person?.department?.head = managersPool.getManager()\r\n```\r\n\r\n### Elvis Operator\r\n\r\n- `${nullable variable} ?: ${otherwise value}`:\r\n\r\ni.e. \r\n\r\n `val l = b?.length ?: -1`\r\n\r\nit equals to:\r\n\r\n`val l: Int = if (b != null) b.length else -1` \r\n\r\nSince `throw` and `return` are expressions in Kotlin, they can also be used on the **right-hand** side of the Elvis operator.\r\n\r\n```kotlin\r\nfun foo(node: Node): String? {\r\n    val parent = node.getParent() ?: return null\r\n    val name = node.getName() ?: throw IllegalArgumentException(\"name expected\")\r\n    // ...\r\n}\r\n```\r\n\r\n### Not Null Assertion Operator !!\r\n\r\n- `!!`: Convert any value to non-null type, and will throw NPE if the reference is null.\r\n\r\ni.e. `val l = b!!.length`\r\n\r\n### Safe Cast\r\n\r\n`val aInt: Int? = a as? Int`: Return null instead of throwing `ClassCastException` when casting objects fail.\r\n\r\n### Collections of a nullable type\r\n\r\n```kotlin\r\nval nullableList: List\u003CInt?> = listOf(1, 2, null, 4)\r\nval intList: List\u003CInt> = nullableList.filterNotNull()\r\n```\r\n\r\n\r\n\r\nnull-safety detail: [https://kotlinlang.org/docs/null-safety.html](https://kotlinlang.org/docs/null-safety.html)\r\n\r\n\r\n\r\n## Collections\r\n\r\ntodo...\r\n","\n## 前言\n\n最近网上大热的 chatGPT 可谓是出尽了 AI 的风头。在各大网友的分享图中都可以发现 chatGPT 不仅仅只是一个对话能力卓越的 AI，其“写”代码的能力也是十分惊艳。经过了数小时的体验，我发现 chatGPT 的代码分析编写能力并不比 Copilot 差，并且强大的对话分析能力让其体验要比 Copilot 更加完整（Copilot 更倾向编码分析）。你甚至可以用其替代 Google 来解决你日常开发的大部分问题。\n\n## 体验\n\n在写本文时，发现本地已经没有 PicGo 环境了，于是在 VSCode 找到了 PicGo 插件，然而发现不知道怎么配置上传到 Github，于是有了以下一幕：\n\n![20221209212432](https://cdn.jsdelivr.net/gh/alightyoung/static/img/20221209212432.png)\n\n可以说，这很大程度上减少了搜素简单问题的时间，对于一些常见的问题，CharGPT 总是能够很快给出答案。\n\n此时，如果你忘了如何求最大公因数，你可以：\n\n![20221209213937](https://cdn.jsdelivr.net/gh/alightyoung/static/img/20221209213937.png)\n\n代码太复杂？\n\n![20221209214032](https://cdn.jsdelivr.net/gh/alightyoung/static/img/20221209214032.png)\n\n代码太长？\n\n![20221209214100](https://cdn.jsdelivr.net/gh/alightyoung/static/img/20221209214100.png)\n\n不得不说，上下文分析的能力还不错，给出的代码也能够很方便的复制粘贴。\n\n## 注册\n\n经过上述内容，我想你已经迫不及待想要尝试体验这个神奇的 chatGPT 了，然而，chatGPT 目前不支持中国号码注册，这并不能阻止你，因为这个世界上还有验证码平台。如果你有兴趣，可以查看接下来的注册过程。\n\n注册 Open AI 的地址：[注册 OpenAI](https://auth0.openai.com/u/signup/identifier)\n\n在注册的过程中，你需要亿点点魔法保证你的网络（地区）能够正常注册 OpenAI ，随后在需要手机号的时候，访问接码平台：[sms-activate.org](https://sms-activate.org/en/)\n\n这个平台的验证码不是免费的，不过理论上你选择最便宜的地区只需要 1 RMB。接码平台同样需要简单的注册，网页支持中文，充值支持支付宝，充值结束左侧搜素栏搜索 `openai` 即可。\n\n关于地区选择，目前印度区手机号是支持的，且接码平台印度号也很便宜（1 RMB 左右）。\n\n选择结束后，右侧会出现一个号码，有效期是 20 分钟内，这 20 分钟足够你去 OpenAI 输入手机号并完成接码，验证码会在一会显示在接码平台的手机号右侧。\n\n到此注册成功，就可以开始直接使用注册的 OpenAI 账号访问 [chatGPT](https://chat.openai.com/chat) 网站了。\n\n:::warning\n一般刚注册结束立马登录可能会出现错误，建议等待一会再尝试，一般可以消除该问题。\n:::\n\n## 最后\n\n实际上，chatGPT 的功能除了查找代码，帮你 debug 之外，也能够帮你写故事（目前 Github 上已经有了 chatGPT 地牢）等。\n\n另外感叹一下机器学习的发展实在是日新月异，据官网描述，该模型似乎是一个强化监督学习的模型，不过此模型算法即使公开绝大部分人也没有足够的数据集能够训练到这个程度，对于普通人/公司而言，可以趁此时机免费尝尝鲜。\n\n需要注意此时测试阶段虽然免费，但是你们**输入的数据也都会被记录下**的，因此需要注意不要输入一些保密信息。毕竟公开测试的另一目的也是收集一些输入数据。\n\n估计此次测试结束，chatGPT 也很快就和 Copilot 一样，正式进入商业化阶段了，想尝鲜的最近可以体验一番。\n","\n## 前言\n\n之前一直有想法搭建一个私服，当时主要看到普遍采取的解决方案是 Gitlab，然而启动该项目需要至少 4G 的内存，这对于服务器资源有限的人来说，十分不友好，并且 Gitlab 的管理功能基本是针对团队场景开发的，对于个人而言有些杀鸡牛刀了。\n\n于是，便找到了另外一个方案，直接通过 Git 创建裸仓库（bare repo）。然后通过 SSH 的方式进行代码传输。该方案虽然简单，但是对于个人用户的小型服务器十分友好。\n\n## 前提\n\n- 服务器一台\n\n## 步骤\n\n1 首先是在服务器安装 Git。主流 Linux 发行版基本都可以通过原生的包管理器获取，这里不过多介绍，下载安装之后通过 `git --version` 检查是否成功安装即可。\n\n2 随后创建一个非 sudo 组的新用户专门用于存储 Git 远程仓库。这样会比较安全，即使你只是一个人使用，但万一呢，如果你实在不想创建，则可以直接到步骤 3。\n\n```shell\n# 创建 git 用户\nsudo useradd git\n# 给 git 用户设置一个密码\nsudo passwd git\n```\n\n3 创建服务端的 Git bare repo。\n\n```shell\n# 切换到 git 用户\nsu git\n# 进入到 git 的 home 目录\ncd ~\n# 创建一个文件夹用做仓库\nmkdir repo_name.git\n# 进入到该仓库\ncd repo_name.git\n# 初始化为裸仓库（只包含.git下的内容）\ngit init --bare\n```\n\n:::tip\n如果你需要将 bare repo 的默认分支切换为 main，可以使用 `git symbolic-ref HEAD refs/heads/main`。普通仓库类型设置默认分支比较简单，可以自行百度或者参考以下链接。\n\n参考链接：[Stack Overflow - How can I create a Git repository with the default branch name other than \"master\"?](https://stackoverflow.com/questions/42871542/how-can-i-create-a-git-repository-with-the-default-branch-name-other-than-maste)\n:::\n\n4 通过以上命令，你已经成功创建了一个远程仓库！现在你需要让用户能够 SSH 到该用户，你需要完成以下操作：\n\n```shell\n# 本地创建 SSH 密钥，如果有可以跳过\nssh-keygen\n# 拷贝本地的公钥，通常是在用户目录下的 .ssh/id_rsa.pub\n\n# 复制该公钥到服务器的 git 用户的家目录下的 .ssh/authorized_keys 中\n# 通常情况这个文件夹（.ssh）和文件（authorized_keys）是不存在的，需要你自己创建\n```\n\n5 在完成上述步骤后，你就已经完成了全部绝大部分工作了！现在分为两种情况。\n\n    - 5.1 第一种为你已经有一个本地仓库了，你只想 push 本地仓库到这个远程仓库，那么你只需要绑定远程仓库即可，例如 `git remote add origin git@ip:repo_name.git`。\n    - 5.2 第二种情况就是你没有本地仓库，那么你仅仅只需要通过 `git clone git@ip:repo_name.git` 即可拷贝空项目至本地并建立本地仓库与远程仓库的关联了。\n\n\n:::tip\n由于之前我们是直接将项目放在 git 用户的家目录下，因此这里没有涉及到相对路径，如果你的项目是在 git 用户目录下的子目录中，那么则可以改为 git 目录下的相对路径。例如仓库保存至服务端的 `/home/git/repo/repo_name.git`，那么上述的 clone 或者 remote 之后的路径就是 `repo/repo_name.git`\n:::\n\n## 最后\n\n稍微解释以下 bare repo。其实就是在普通仓库下的 .git 目录已经包含了 git 需要的全部信息，包括代码。这些信息会被压缩打包保存 .git 目录中，只不过没有项目结构那么直观。\n\n因此对于服务端而言，保存为 bare repo，然后每次 push 至该仓库都只是重新生产 .git 目录下的文件并上传至服务端的 repo_name.git 目录中。\n\nEnjoy the Git。\n","\n## CommonMark\n\n### header\n\n```markdown\n# header1\n\n## header2\n\n### header3\n\n#### header4\n\n###### header5\n\n###### header6\n\n### header with `inline code` is not recommended (but it was supported for now)\n```\n\n> # header1\n>\n> ## header2\n>\n> ### header3\n>\n> #### header4\n>\n> ###### header5\n>\n> ###### header6\n>\n> ### header with `inline code` is not recommended (but it was supported for now)\n\n:::tip\n\n-   Header1 is not recommended as it was used in the title of the page header\n-   Only header2 - header3 (header1 also) will add to post navigation\n    :::\n\n### font-related\n\n```markdown\nParagraph with `inline code`, **strong**, _emphasis_, **_emphasis strong_**、[Link](https://github.com)\n\n**[Strong link](https://github.com)**\n```\n\nParagraph with `inline code`, **strong**, _emphasis_, **_emphasis strong_**、[Link](https://github.com)\n\n**[Strong link](https://github.com)**\n\n:::warn\nIf you want to show \"`\" (one backtick, the markdown inline code default start symbol) in inline code block, you need to wrap this code with two backticks.\n\nFor example:\n\n```markdown\n`` `inline code` ``\n```\n\n`` `inline code` ``\n:::\n\n### image\n\n```markdown\n![picsum](https://picsum.photos/800/600)\n```\n\n![picsum](https://picsum.photos/800/600)\n\n### blockquote\n\n```markdown\n> The blockquote can contains `inline code`, **strong**, _emphasis_, **_emphasis strong_**\n> and so on...\n>\n> even itself\n>\n> > inner blockquote\n> > `inner code`, [Google](https://google.com) > > ![picsum](https://picsum.photos/800/600)\n```\n\n> The blockquote can contains `inline code`, **strong**, _emphasis_, **_emphasis strong_**\n> and so on...\n>\n> even itself\n>\n> > inner blockquote\n> > `inner code`, [Google](https://google.com) > > ![picsum](https://picsum.photos/800/600)\n\n### unordered list\n\n```markdown\n-   item1\n-   item2\n-   item3\n```\n\n-   item1\n-   item2\n-   item3\n\n### ordered list\n\n```markdown\n1. item1\n2. item1\n3. item1\n```\n\n1. item1\n2. item1\n3. item1\n\n### nested list\n\n```markdown\n1. First level item\n    1. Nested item 1\n    2. Nested item 2\n2. Another first level item\n    1. Nested item 3\n        1. Sub-nested item A\n        2. Sub-nested item B\n    2. Nested item 4\n\n-   item1\n    -   item2\n        -   item3\n```\n\n1. First level item\n    1. Nested item 1\n    2. Nested item 2\n2. Another first level item\n    1. Nested item 3\n        1. Sub-nested item A\n        2. Sub-nested item B\n    2. Nested item 4\n\n-   item1\n    -   item2\n        -   item3\n\n### code block\n\nSyntax highlight with highlight.js common language.\n\n````markdown\n```c\n#include \u003Cstdio>\n\nint main() {\n  printf(\"hello world\");\n}\n```\n````\n\n```c\n#include \u003Cstdio>\n\nint main() {\n  printf(\"hello world\");\n}\n```\n\n:::warn\nIf you want to show \"```\" (three backticks, the markdown code block default start symbol) in code block, you need to wrap this code with **four** backticks.\n:::\n\n### horizontal rule\n\n```markdown\n---\n```\n\n---\n\n## Github Flavored Markdown\n\n### table\n\n```markdown\n| foo | bar | foo |\n| :-- | :-: | --: |\n| baz | qux | xyz |\n```\n\n| foo | bar | foo |\n| :-- | :-: | --: |\n| baz | qux | xyz |\n\n### auto link\n\n```markdown\nWriting some text like a URL like https://github.com will automatically be converted to a link.\n```\n\nWriting some text like a URL like https://github.com will automatically be converted to a link.\n\n### task list\n\n```markdown\n-   [x] foo\n    -   [ ] bar\n        -   [ ] abc\n    -   [x] baz\n-   [ ] bim\n```\n\n-   [x] foo\n    -   [ ] bar\n        -   [ ] abc\n    -   [x] baz\n-   [ ] bim\n\n### strikethrough\n\n```markdown\nthis is ~~strikethrough~~\n```\n\nthis is ~~strikethrough~~\n\n## Math\n\nMath render currently only support latex syntax (partial) which is support by mathjax.\n\n### inline math\n\n\n\n```markdown\n1 / 2 => $\\frac{1}{2}$\n```\n\n1 / 2 => $\\frac{1}{2}$\n\n### display math\n\n```markdown\n$$\nx = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\n$$\n```\n\n$$\nx = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}\n$$\n\n\n## Directive\n\n### details\n\n```markdown\n:::details{text=\"unfold\"}\nthis is some text\n:::\n\n:::details\nthis is some text\n:::\n```\n\n:::details{text=\"unfold\"}\nthis is some text\n:::\n\n:::details\nthis is some text\n:::\n\n### tip\n\n```markdown\n:::tip{text=\"Tips\"}\nthis is some text\n:::\n\n:::tip\nthis is some text\n:::\n```\n\n:::tip{text=\"Tips\"}\nthis is some text\n:::\n\n:::tip\nthis is some text\n:::\n\n### warning\n\n```markdown\n:::warning{text=\"warn\"}\nthis is some text\n:::\n\n:::warn\nthis is some text\n:::\n```\n\n:::warning{text=\"warn\"}\nthis is some text\n:::\n\n:::warn\nthis is some text\n:::\n\n### error\n\n```markdown\n:::error{text=\"danger\"}\nthis is some text\n:::\n\n:::danger\nthis is some text\n:::\n```\n\n:::error{text=\"danger\"}\nthis is some text\n:::\n\n:::danger\nthis is some text\n:::\n\n## MDX\n\nYou can create custom components with MDX.\n\nYou won't be able to use some characters like `\u003C`, `>` in any position of your markdown content. But you can wrap these content with inline code or inline math.\n\nWrite HTML (include style and script) is also invalid.\n\nSo if you don't want to create custom components, just disable MDX plugin.\n\nIf you still need this, just create a svelte compoennt in the `src/components/mdx`. You can see the `Badge` component in it. The project use tailwindcss and daisyUI as CSS library, so you can write svelte compoennt with amount of pre-defiend css.\n\n### Badge\n\n```markdown\n\u003CBadge type=\"tip\" text=\"tip\"/>\n\u003CBadge type=\"warning\" text=\"warning\"/>\n\u003CBadge type=\"warn\" text=\"warn\"/>\n\u003CBadge type=\"error\" text=\"error\"/>\n\u003CBadge type=\"danger\" text=\"danger\"/>\n```\n\n\u003CBadge type=\"tip\" text=\"tip\"/>\n\u003CBadge type=\"warning\" text=\"warning\"/>\n\u003CBadge type=\"warn\" text=\"warn\"/>\n\u003CBadge type=\"error\" text=\"error\"/>\n\u003CBadge type=\"danger\" text=\"danger\"/>\n\n","\r\n\r\n## preface\r\n\r\nIn the Linux environment, most of people choose vim as a text editor, even as an IDE (Integrated Development Environment). But except vim, there are still so many text editors like vi, nano, etc...\r\n\r\nSo in this post, I'll try to list below text editors' common usage to improve your development.\r\n\r\n- vi\r\n- vim\r\n- nano\r\n\r\n## Vi\r\n\r\n### Opening a File\r\n\r\nUsing `vi {path2file}` to edit file with vi.\r\n\r\n### modes\r\n\r\nvi has different modes:\r\n\r\n- Normal Mode: Used for navigation and executing commands.\r\n- Insert Mode: Used for inserting or editing text.\r\n- Command-Line Mode: Used for saving changes, quitting, and other commands.\r\n\r\nTo switch from Normal Mode to Insert Mode, press `i`.\r\nTo switch from Insert Mode to Normal Mode, press `Esc`.\r\n\r\n### Navigation in Normal Mode\r\n\r\nUse arrow keys to move the cursor.\r\n\r\n`h` for left, `l` for right, `j` for down, and `k` for up.\r\n\r\n`w` to move the cursor to the beginning of the next word. `b` to move the cursor to the beginning of the previous word.\r\n\r\n`0` (zero) to move to the beginning of the current line. `$` to move to the end of the current line.\r\n\r\n`gg` to move to the beginning of the file. `G` to move to the end of the file.\r\n\r\n\r\n### Editing in Normal Mode:\r\n\r\n`x` to delete the character under the cursor.\r\n\r\n`dd` to delete the current line.\r\n\r\n`yy` to yank (copy) the current line.\r\n\r\n`p` to paste the yanked or deleted text after the cursor.\r\n\r\n### Saving and Quitting\r\n\r\nIn Normal Mode, type `:w` to save changes.\r\nType `:q` to quit.\r\nType `:wq` to save and quit.\r\nType `:q!` to quit without saving.\r\n\r\n:::tip\r\nusing `:w !sudo tee > /dev/null %` to save when you forget using sudo to edit unprivileged file.\r\n:::\r\n\r\n### Searching:\r\n\r\nIn Normal Mode, type `/` followed by the search term and press `Enter`.\r\n\r\nUse `n` to find the next occurrence.\r\n\r\n### undo/redo\r\n\r\n`u` to undo the last change.\r\n`Ctrl + r` to redo a change.\r\n\r\n\r\n## Vim\r\n\r\nThe above vi commands can all be used in vim, so only the content that is only valid in Vim is shown here.\r\n\r\n### Visual Mode:\r\n\r\n`v`: Enter Visual Mode to select characters.\r\n`V`: Enter Visual Line Mode to select whole lines.\r\n`Ctrl + v`: Enter Visual Block Mode to select a block of text.\r\n\r\n`d`: Delete the selected text in Visual Mode.\r\n`x`: Cut the selected text in Visual Mode.\r\n\r\n### Search and Replace:\r\n\r\n`:s/old/new/g`: Substitute all occurrences of 'old' with 'new' in the current line.\r\n`:%s/old/new/g`: Substitute all occurrences of 'old' with 'new' in the entire file.\r\n`:s/old/new/gc`: Substitute with confirmation.\r\n\r\n## Nano\r\n\r\n### Opening a File\r\n\r\nUsing `nano {path2file}` to edit file with vi.\r\n\r\n### Basic Navigation\r\n\r\nUse arrow keys to move the cursor.\r\n\r\n`Ctrl + F`: Move forward one page.\r\n`Ctrl + B`: Move backward one page.\r\n`Ctrl + ↑`: Move to the previous line.\r\n`Ctrl + ↓`: Move to the next line.\r\n\r\n### Editing\r\n\r\nSince Nano is a user-friendly editor, you can edit it like a common GUI text editor. for example, append by type character, delete by `backspace`.\r\n\r\nAnd there also has some commands for advanced usage. \r\n\r\n`Ctrl + K`: Cut (delete) the current line.\r\n`Ctrl + U`: Uncut (paste) the previously cut text.\r\n`Ctrl + O`: Write the current contents to a file.\r\n`Ctrl + X`: Exit nano. If changes are made, you will be prompted to save.\r\n\r\n### Searching\r\n\r\n`Ctrl + W`: Search for a specific term. Press `Enter` to search and `Ctrl + W` again to find the next occurrence.\r\n\r\n## to be continued...","\r\n## Environment\r\n\r\nOpenSSL 3.0 version in Ubuntu 22.04 LTS\r\n\r\n## Steps to Create Self-signed Certificate\r\n\r\n### create your CA (certificate authority)\r\n\r\n1. generate CA key\r\n\r\n```sh\r\nopenssl genrsa -out ca.key 4096\r\n```\r\n\r\n2. create CA cert file\r\n\r\n```sh\r\nopenssl req -x509 -days 3650 -new -nodes -sha256 -key ca.key -out ca.crt\r\n```\r\n\r\n### create server key and csr\r\n\r\n1. generate server.key\r\n\r\n```sh\r\nopenssl genrsa -out server.key 2048\r\n```\r\n\r\n2. generate csr file from server.key\r\n\r\n```sh\r\nopenssl req -new -nodes -key server.key -out server.csr\r\n```\r\n\r\n> You can also use below approach to combine step 1 and 2.\r\n\r\n\r\n```sh\r\nopenssl req -new -nodes -keyout server.key -out server.csr\r\n```\r\n\r\n### sign the csr by CA and output a server cert\r\n\r\n:::tip\r\nIf you need sign the csr with SAN (subject alternative name), you need create a file names *server_v3.ext*\r\n\r\n```ext\r\nauthorityKeyIdentifier = keyid,issuer\r\nbasicConstraints = CA:FALSE\r\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\r\n\r\nsubjectAltName = @alt_names\r\n\r\n[alt_names]\r\nDNS.1 = your.domain1.com\r\nDNS.2 = your.domain2.com\r\nIP.1 = 127.0.0.1\r\nIP.2 = 192.168.0.1\r\n```\r\n\r\nIf the top3 settings not suit for you, just find a sample in openssl default configuration file (normally it locate in `/etc/ssl/openssl.cnf`).\r\n:::\r\n\r\n1. CA sign the csr\r\n\r\n> If you don't want to set SAN, just ignore the `-extfile server_v3.ext` in below command.\r\n\r\n```sh\r\nopenssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server_signed.crt -extfile server_v3.ext\r\n```\r\n\r\n## Convert Certificate to PKCS12-Formatted Keystore\r\n\r\nNormally, we maybe want to use a PKCS12-formatted key store, so we can do this.\r\n\r\n```sh\r\nopenssl pkcs12 -export -out server.p12 -inkey server.key -in server_signed.crt\r\n```","\r\n## Redis in SpringBoot\r\n\r\nThe post assume you are use `spring-boot-starter-data-redis` to use Redis in SpringBoot Application.\r\n\r\nThere has two lib to implements redis in SpringBoot, which are Lettuce (default) and Jedis.\r\n\r\nThe first thing you need to do is set `spring.redis.ssl` to `true` in *application.yaml*. (or properties).\r\n\r\n:::warn\r\n\r\nYou also need set custom keystore path and password if you want to fully follow the below lib configuration in next section.\r\n\r\nThe post will use PKCS12-formatted keystore, JKS-formatted keystore also can work fine.\r\n\r\n```\r\nspring.redis.keyStore = \"classpath:server.p12\"\r\nspring.redis.keyStorePass = \"password of pkcs12\"\r\nspring.redis.keyStorePass = \"PKCS12\"\r\n```\r\n:::\r\n\r\nThen follow the right section to see how to config SSL in 3rd party library.\r\n\r\n\r\n## Lettuce\r\n\r\n*RedisConfig.java*\r\n\r\n```java\r\n@Configuration\r\npublic class RedisConfig {\r\n\r\n    @Value(\"${spring.redis.host}\")\r\n    private String host;\r\n    @Value(\"${spring.redis.port}\")\r\n    private int port;\r\n    @Value(\"${spring.redis.ssl}\")\r\n    private boolean ssl;\r\n    @Value(\"${spring.redis.password}\")\r\n    private String password;\r\n    @Value(\"${spring.redis.database}\")\r\n    private int database;\r\n    @Value(\"${spring.redis.timeout}\")\r\n    private int timeout;\r\n    @Value(\"${spring.redis.keyStore}\")\r\n    private String keyStorePath;\r\n    @Value(\"${spring.redis.keyStorePass}\")\r\n    private String keyStorePass;\r\n\r\n    @Resource\r\n    private ResourceLoader resourceLoader;\r\n\r\n    @Bean\r\n    public LettuceConnectionFactory redisConnectionFactory() throws IOException, KeyStoreException, CertificateException, NoSuchAlgorithmException, UnrecoverableKeyException, KeyManagementException {\r\n        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();\r\n        redisStandaloneConfiguration.setHostName(host);\r\n        redisStandaloneConfiguration.setPort(port);\r\n        redisStandaloneConfiguration.setPassword(password);\r\n        redisStandaloneConfiguration.setDatabase(database);\r\n        LettuceClientConfiguration.LettuceClientConfigurationBuilder lettuceClientConfigurationBuilder = LettuceClientConfiguration.builder();\r\n        if (ssl) {\r\n            File keyStore = resourceLoader.getResource(keyStorePath).getFile();\r\n            SslOptions sslOptions = SslOptions.builder()\r\n                    .jdkSslProvider()\r\n                    .keystore(keyStore, keyStorePass.toCharArray())\r\n                    .truststore(keyStore, keyStorePass)\r\n                    .build();\r\n            ClientOptions clientOptions = ClientOptions\r\n                    .builder()\r\n                    .sslOptions(sslOptions)\r\n                    .protocolVersion(ProtocolVersion.RESP3)\r\n                    .build();\r\n            lettuceClientConfigurationBuilder\r\n                    .clientOptions(clientOptions)`\r\n                    .useSsl()\r\n                    .disablePeerVerification(); // if you don't set SAN, you need this\r\n        }\r\n        LettuceClientConfiguration lettuceClientConfiguration = lettuceClientConfigurationBuilder.build();\r\n        return new LettuceConnectionFactory(redisStandaloneConfiguration, lettuceClientConfiguration);\r\n    }\r\n```\r\n\r\n\r\n## Jedis\r\n\r\nIf you don't want to use default Lettuce implementation, you can update POM to use Jedis.\r\n\r\n*pom.xml*\r\n\r\n```xml\r\n\u003Cdependency>\r\n    \u003CgroupId>org.springframework.boot\u003C/groupId>\r\n    \u003CartifactId>spring-boot-starter-data-redis\u003C/artifactId>\r\n    \u003Cexclusions>\r\n        \u003Cexclusion>\r\n            \u003CgroupId>io.lettuce\u003C/groupId>\r\n            \u003CartifactId>lettuce-core\u003C/artifactId>\r\n        \u003C/exclusion>\r\n    \u003C/exclusions>\r\n\u003C/dependency>\r\n\r\n\u003Cdependency>\r\n    \u003CgroupId>redis.clients\u003C/groupId>\r\n    \u003CartifactId>jedis\u003C/artifactId>\r\n    \u003Cversion>5.0.0\u003C/version>\r\n\u003C/dependency>\r\n```\r\n\r\n\r\n*RedisConfig.java*\r\n```java\r\n@Configuration\r\npublic class RedisConfig {\r\n\r\n    @Value(\"${spring.redis.host}\")\r\n    private String host;\r\n    @Value(\"${spring.redis.port}\")\r\n    private int port;\r\n    @Value(\"${spring.redis.ssl}\")\r\n    private boolean ssl;\r\n    @Value(\"${spring.redis.password}\")\r\n    private String password;\r\n    @Value(\"${spring.redis.database}\")\r\n    private int database;\r\n    @Value(\"${spring.redis.timeout}\")\r\n    private int timeout;\r\n    @Value(\"${spring.redis.keyStore}\")\r\n    private String keyStorePath;\r\n    @Value(\"${spring.redis.keyStorePass}\")\r\n    private String keyStorePass;\r\n    @Value(\"${spring.redis.keyStoreType}\")\r\n    private String keyStoreType;\r\n\r\n    // @Value(\"${spring.redis.jedis.pool.max-idle}\")\r\n    // private int maxIdle;\r\n    // @Value(\"${spring.redis.jedis.pool.min-idle}\")\r\n    // private int minIdle;\r\n    // @Value(\"${spring.redis.jedis.pool.max-wait}\")\r\n    // private int maxWait;\r\n    // @Value(\"${spring.redis.jedis.pool.max-active}\")\r\n    // private int maxActive;\r\n\r\n    @Resource\r\n    private ResourceLoader resourceLoader;\r\n\r\n\r\n    @Bean\r\n    public JedisConnectionFactory redisConnectionFactory() throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException, UnrecoverableKeyException, KeyManagementException {\r\n        RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration();\r\n        redisStandaloneConfiguration.setHostName(host);\r\n        redisStandaloneConfiguration.setPort(port);\r\n        redisStandaloneConfiguration.setPassword(password);\r\n        redisStandaloneConfiguration.setDatabase(database);\r\n\r\n        JedisClientConfiguration.JedisClientConfigurationBuilder jedisClientConfigurationBuilder = JedisClientConfiguration.builder();\r\n        if (ssl) {\r\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\r\n            File keyStoreFile = resourceLoader.getResource(keyStorePath).getFile();\r\n            keyStore.load(new FileInputStream(keyStoreFile), keyStorePass.toCharArray());\r\n            KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n            keyManagerFactory.init(keyStore, keyStorePass.toCharArray());\r\n            TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\r\n            trustManagerFactory.init(keyStore);\r\n            SSLContext sslContext = SSLContext.getInstance(\"TLS\");\r\n            sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\r\n            jedisClientConfigurationBuilder\r\n                    .connectTimeout(Duration.ofMillis(timeout))\r\n                    .useSsl()\r\n                    .sslSocketFactory(sslContext.getSocketFactory());\r\n        }\r\n        JedisClientConfiguration jedisClientConfiguration = jedisClientConfigurationBuilder.build();\r\n        return new JedisConnectionFactory(redisStandaloneConfiguration, jedisClientConfiguration);\r\n    }\r\n\r\n//     @Bean\r\n//     public GenericObjectPoolConfig genericObjectPoolConfig() {\r\n//         GenericObjectPoolConfig\u003CObject> genericObjectPoolConfig = new GenericObjectPoolConfig\u003C>();\r\n//         genericObjectPoolConfig.setMaxIdle(maxIdle);\r\n//         genericObjectPoolConfig.setMinIdle(minIdle);\r\n//         genericObjectPoolConfig.setMaxWaitMillis(maxWait);\r\n// //        genericObjectPoolConfig.setMaxTotal(maxActive);\r\n//         return genericObjectPoolConfig;\r\n//     }\r\n}\r\n```\r\n",{"post/2019/20190922/":93,"post/2019/20190923/":101,"post/2019/20191001/":108,"post/2019/20191011/":116,"post/2019/20191015/":123,"post/2019/20191021/":129,"post/2019/20191024/":135,"post/2019/20191028/":142,"post/2019/20191103/":149,"post/2019/20191106/":157,"post/2019/20191110/":164,"post/2019/20191112/":170,"post/2019/20191116/":177,"post/2019/20191120/":184,"post/2019/20191121/":190,"post/2019/20191123/":196,"post/2019/20191127/":202,"post/2019/20191128/":209,"post/2019/20191129/":216,"post/2019/20191202/":223,"post/2019/20191206/":230,"post/2019/20191210/":237,"post/2019/20191215/":245,"post/2019/20191220/":252,"post/2019/20191228/":259,"post/2020/20200101/":266,"post/2020/20200108/":272,"post/2020/20200115/":279,"post/2020/20200122/":287,"post/2020/20200130/":294,"post/2020/20200605/":300,"post/2020/20200606/":307,"post/2020/20200607/":314,"post/2020/20200608/":320,"post/2020/20200609/":328,"post/2020/20200610/":335,"post/2020/20200611/":342,"post/2020/20200612/":348,"post/2020/20200625/":355,"post/2020/20200628/":362,"post/2020/20200713/":368,"post/2020/20200725/":375,"post/2020/20200731/":382,"post/2020/20200810/":388,"post/2020/20201028/":395,"post/2020/20201029/":401,"post/2020/20201107/":407,"post/2020/20201122/":414,"post/2021/20210321/":421,"post/2021/20210326/":428,"post/2021/20210330/":434,"post/2021/20210408/":440,"post/2021/20210419/":448,"post/2021/20210425/":456,"post/2021/20210508/":463,"post/2021/20210510/":470,"post/2021/20210518/":477,"post/2021/20210629/":484,"post/2021/20210630/":490,"post/2021/20210706/":496,"post/2021/20210709/":503,"post/2021/20210710/":509,"post/2021/20210711/":515,"post/2021/20210720/":521,"post/2021/20210725/":527,"post/2021/20210728/":533,"post/2021/20210731/":539,"post/2021/20210801/":545,"post/2021/20210802/":551,"post/2021/20210803/":557,"post/2021/20210804/":563,"post/2021/20210812/":569,"post/2021/20210813/":575,"post/2021/20210816/":581,"post/2021/20211118/":587,"post/2021/20211119/":594,"post/2022/20220223/":601,"post/2022/20220326/":608,"post/2022/20220526/":615,"post/2022/20220601/":621,"post/2022/20220810/":629,"post/2022/20220829/":637,"post/2022/20221009/":645,"post/2022/20221031/":653,"post/2022/20221209/":660,"post/2023/20230312/":667,"post/2023/20230805/":674,"post/2024/20240225/":683,"post/2024/20240310/":692,"post/2024/20240311/":699},{"title":94,"date":95,"categories":96,"tags":98,"link":100},"Hexo入门指北",["Date","2019-09-22T17:05:48.000Z"],[97],"Guide",[99],"Hexo","post/2019/20190922/",{"title":102,"date":103,"categories":104,"tags":105,"link":107},"Windows10下安装Ubuntu双系统",["Date","2019-09-23T12:40:27.000Z"],[97],[106],"Ubuntu","post/2019/20190923/",{"title":109,"date":110,"categories":111,"tags":113,"link":115},"Java13概览",["Date","2019-10-01T18:12:34.000Z"],[112],"Java",[114],"JDK","post/2019/20191001/",{"title":117,"date":118,"categories":119,"tags":120,"link":122},"Apache Shiro的基础应用",["Date","2019-10-11T13:31:34.000Z"],[112],[121],"Shiro","post/2019/20191011/",{"title":124,"date":125,"categories":126,"tags":127,"link":128},"Maven",["Date","2019-10-15T13:31:34.000Z"],[112],[124],"post/2019/20191015/",{"title":130,"date":131,"categories":132,"tags":133,"link":134},"Git",["Date","2019-10-21T10:53:03.000Z"],[130],[130],"post/2019/20191021/",{"title":136,"date":137,"categories":138,"tags":139,"link":141},"Java并发相关概念",["Date","2019-10-24T14:27:03.000Z"],[112],[140],"Synchronization","post/2019/20191024/",{"title":143,"date":144,"categories":145,"tags":146,"link":148},"Java并发容器",["Date","2019-10-28T13:55:00.000Z"],[112],[147],"SyncContainer","post/2019/20191028/",{"title":150,"date":151,"categories":152,"tags":154,"link":156},"LeetCode 2 - 两数相加",["Date","2019-11-03T20:34:22.000Z"],[153],"Algorithm",[155],"LeetCode","post/2019/20191103/",{"title":158,"date":159,"categories":160,"tags":161,"link":163},"Java并发之线程池",["Date","2019-11-06T13:07:56.000Z"],[112],[162],"ThreadPool","post/2019/20191106/",{"title":165,"date":166,"categories":167,"tags":168,"link":169},"JVM",["Date","2019-11-10T13:15:29.000Z"],[112],[165],"post/2019/20191110/",{"title":171,"date":172,"categories":173,"tags":174,"link":176},"Java开发手册",["Date","2019-11-12T21:53:09.000Z"],[112],[175],"Handbook","post/2019/20191112/",{"title":178,"date":179,"categories":180,"tags":181,"link":183},"Java网络编程",["Date","2019-11-16T12:23:06.000Z"],[112],[182],"Socket","post/2019/20191116/",{"title":185,"date":186,"categories":187,"tags":188,"link":189},"Netty",["Date","2019-11-20T13:05:43.000Z"],[112],[185],"post/2019/20191120/",{"title":191,"date":192,"categories":193,"tags":194,"link":195},"LeetCode 1 - 两数之和",["Date","2019-11-21T17:33:22.000Z"],[153],[155],"post/2019/20191121/",{"title":197,"date":198,"categories":199,"tags":200,"link":201},"LeetCode 3 - 无重复字符的最长子串",["Date","2019-11-23T19:05:42.000Z"],[153],[155],"post/2019/20191123/",{"title":203,"date":204,"categories":205,"tags":206,"link":208},"SSO(单点登录)",["Date","2019-11-27T16:24:22.000Z"],[112],[207],"SSO","post/2019/20191127/",{"title":210,"date":211,"categories":212,"tags":213,"link":215},"SpringBoot",["Date","2019-11-28T16:24:22.000Z"],[112],[214],"Spring","post/2019/20191128/",{"title":217,"date":218,"categories":219,"tags":220,"link":222},"ActiveMQ 5基本使用",["Date","2019-11-29T16:24:22.000Z"],[112],[221],"MQ","post/2019/20191129/",{"title":224,"date":225,"categories":226,"tags":227,"link":229},"设计模式之单例模式",["Date","2019-12-02T20:02:34.000Z"],[112],[228],"Design pattern","post/2019/20191202/",{"title":231,"date":232,"categories":233,"tags":234,"link":236},"Github三方登录的实现",["Date","2019-12-06T16:24:22.000Z"],[112],[235],"OAuth 2.0","post/2019/20191206/",{"title":238,"date":239,"categories":240,"tags":242,"link":244},"Nginx的一些常见用法",["Date","2019-12-10T11:23:36.000Z"],[241],"WebServer",[243],"Nginx","post/2019/20191210/",{"title":246,"date":247,"categories":248,"tags":249,"link":251},"Swagger & Knife4j",["Date","2019-12-15T10:03:36.000Z"],[112],[250],"OpenAPI","post/2019/20191215/",{"title":253,"date":254,"categories":255,"tags":256,"link":258},"Gitlab私服环境搭建",["Date","2019-12-20T10:54:21.000Z"],[130],[257],"Gitlab","post/2019/20191220/",{"title":260,"date":261,"categories":262,"tags":263,"link":265},"Java Web分页的实现",["Date","2019-12-28T08:21:35.000Z"],[112],[264],"Pagination","post/2019/20191228/",{"title":267,"date":268,"categories":269,"tags":270,"link":271},"Spring Security 5",["Date","2020-01-01T20:52:09.000Z"],[112],[214],"post/2020/20200101/",{"title":273,"date":274,"categories":275,"tags":276,"link":278},"Mybatis Generator",["Date","2020-01-08T20:52:09.000Z"],[112],[277],"Mybatis","post/2020/20200108/",{"title":280,"date":281,"categories":282,"tags":284,"link":286},"Centos 7 & Ubuntu 20.04 MySQL的安装配置",["Date","2020-01-15T16:54:20.000Z"],[283],"Database",[285],"Mysql","post/2020/20200115/",{"title":288,"date":289,"categories":290,"tags":291,"link":293},"分布式配置中心-Apollo",["Date","2020-01-22T15:09:20.000Z"],[112],[292],"Apollo","post/2020/20200122/",{"title":295,"date":296,"categories":297,"tags":298,"link":299},"Centos7下JDK的安装",["Date","2020-01-30T15:19:20.000Z"],[112],[114],"post/2020/20200130/",{"title":301,"date":302,"categories":303,"tags":304,"link":306},"MySQL查询表字段注释",["Date","2020-06-05T15:19:20.000Z"],[283],[305],"MySQL","post/2020/20200605/",{"title":308,"date":309,"categories":310,"tags":311,"link":313},"Java常用时间处理",["Date","2020-06-06T15:19:20.000Z"],[112],[312],"JavaAPI","post/2020/20200606/",{"title":315,"date":316,"categories":317,"tags":318,"link":319},"Java中集合的排序",["Date","2020-06-07T15:19:20.000Z"],[112],[312],"post/2020/20200607/",{"title":321,"date":322,"categories":323,"tags":325,"link":327},"Node.js基础",["Date","2020-06-08T00:00:00.000Z"],[324],"WebFrontend",[326],"Node.js","post/2020/20200608/",{"title":329,"date":330,"categories":331,"tags":332,"link":334},"ECMAScript6.0",["Date","2020-06-09T00:00:00.000Z"],[324],[333],"ES6","post/2020/20200609/",{"title":336,"date":337,"categories":338,"tags":339,"link":341},"Vue基础语法",["Date","2020-06-10T00:00:00.000Z"],[324],[340],"Vue","post/2020/20200610/",{"title":343,"date":344,"categories":345,"tags":346,"link":347},"VueRouter入门",["Date","2020-06-11T00:00:00.000Z"],[324],[340],"post/2020/20200611/",{"title":349,"date":350,"categories":351,"tags":352,"link":354},"Vuex入门",["Date","2020-06-12T00:00:00.000Z"],[324],[353],"Vuex","post/2020/20200612/",{"title":356,"date":357,"categories":358,"tags":359,"link":361},"CSS制作毛玻璃特效",["Date","2020-06-25T00:00:00.000Z"],[324],[360],"CSS","post/2020/20200625/",{"title":363,"date":364,"categories":365,"tags":366,"link":367},"Sass",["Date","2020-06-28T00:00:00.000Z"],[324],[363],"post/2020/20200628/",{"title":369,"date":370,"categories":371,"tags":372,"link":374},"picgo-图床工具",["Date","2020-07-13T00:00:00.000Z"],[97],[373],"Picgo","post/2020/20200713/",{"title":376,"date":377,"categories":378,"tags":380,"link":381},"数据结构基础",["Date","2020-07-25T00:00:00.000Z"],[379],"DataStructure",[379],"post/2020/20200725/",{"title":383,"date":384,"categories":385,"tags":386,"link":387},"算法基础",["Date","2020-07-31T00:00:00.000Z"],[153],[153],"post/2020/20200731/",{"title":389,"date":390,"categories":391,"tags":392,"link":394},"黑苹果参考记录",["Date","2020-08-10T00:00:00.000Z"],[97],[393],"Hackintosh","post/2020/20200810/",{"title":396,"date":397,"categories":398,"tags":399,"link":400},"CSS制作流光按钮",["Date","2020-10-28T00:00:00.000Z"],[324],[360],"post/2020/20201028/",{"title":402,"date":403,"categories":404,"tags":405,"link":406},"CSS聚光灯效果",["Date","2020-10-29T00:00:00.000Z"],[324],[360],"post/2020/20201029/",{"title":408,"date":409,"categories":410,"tags":411,"link":413},"Windows配置c语言环境(vscode+mingw64+clang)",["Date","2020-11-07T14:25:48.000Z"],[97],[412],"Mingw-w64","post/2020/20201107/",{"title":415,"date":416,"categories":417,"tags":418,"link":420},"内网视频分享",["Date","2020-11-22T14:25:48.000Z"],[324],[419],"Video.js","post/2020/20201122/",{"title":422,"date":423,"categories":424,"tags":425,"link":427},"Ubuntu下编译OpenJDK 16",["Date","2021-03-21T15:26:41.000Z"],[112],[426],"OpenJDK","post/2021/20210321/",{"title":429,"date":430,"categories":431,"tags":432,"link":433},"Mybatis Plus：基础使用",["Date","2021-03-26T23:15:37.000Z"],[112],[277],"post/2021/20210326/",{"title":435,"date":436,"categories":437,"tags":438,"link":439},"Java 8的常用特性、API",["Date","2021-03-30T20:23:26.000Z"],[112],[312],"post/2021/20210330/",{"title":441,"date":442,"categories":443,"tags":445,"link":447},"你真的了解RESTful嘛？",["Date","2021-04-08T21:33:23.000Z"],[444],"Web",[446],"REST","post/2021/20210408/",{"title":449,"date":450,"categories":451,"tags":452,"sticky":453,"publish":454,"link":455},"使用VuePress部署你的个人博客",["Date","2021-04-19T00:00:00.000Z"],[97],[340],1,true,"post/2021/20210419/",{"title":457,"date":458,"categories":459,"tags":460,"link":462},"Github Action快速扫盲",["Date","2021-04-25T21:42:31.000Z"],[97],[461],"Github","post/2021/20210425/",{"title":464,"date":465,"categories":466,"tags":467,"link":469},"Webpack入门",["Date","2021-05-08T20:23:29.000Z"],[324],[468],"Webpack","post/2021/20210508/",{"title":471,"date":472,"categories":473,"tags":474,"link":476},"Babel入门指北",["Date","2021-05-10T21:26:11.000Z"],[324],[475],"Babel","post/2021/20210510/",{"title":478,"date":479,"categories":480,"tags":481,"link":483},"Druid Integration With SpringBoot",["Date","2021-05-18T21:01:53.000Z"],[112],[482],"Druid","post/2021/20210518/",{"title":485,"date":486,"categories":487,"tags":488,"link":489},"Echarts",["Date","2021-06-29T19:02:48.000Z"],[324],[485],"post/2021/20210629/",{"title":491,"date":492,"categories":493,"tags":494,"link":495},"Mockjs",["Date","2021-06-30T19:32:24.000Z"],[324],[491],"post/2021/20210630/",{"title":497,"date":498,"categories":499,"tags":500,"link":502},"Spring Cloud Alibaba",["Date","2021-07-06T13:00:31.000Z"],[112],[501],"SpringCloud Alibaba","post/2021/20210706/",{"title":504,"date":505,"categories":506,"tags":507,"link":508},"LeetCode 1893 - 检查是否区域内所有整数都被覆盖",["Date","2021-07-09T09:58:58.000Z"],[153],[155],"post/2021/20210709/",{"title":510,"date":511,"categories":512,"tags":513,"link":514},"LeetCode 1736 - 替换隐藏数字得到的最晚时间",["Date","2021-07-10T10:08:29.000Z"],[153],[155],"post/2021/20210710/",{"title":516,"date":517,"categories":518,"tags":519,"link":520},"LeetCode 1743 - 从相邻元素对还原数组",["Date","2021-07-11T10:12:44.000Z"],[153],[155],"post/2021/20210711/",{"title":522,"date":523,"categories":524,"tags":525,"link":526},"LeetCode 671 - 二叉树中第二小的节点",["Date","2021-07-20T16:55:47.000Z"],[153],[155],"post/2021/20210720/",{"title":528,"date":529,"categories":530,"tags":531,"link":532},"LeetCode 863 - 二叉树中所有距离为 K 的结点",["Date","2021-07-25T10:39:05.000Z"],[153],[155],"post/2021/20210725/",{"title":534,"date":535,"categories":536,"tags":537,"link":538},"LeetCode 171 - Excel 表列序号",["Date","2021-07-28T13:56:40.000Z"],[153],[155],"post/2021/20210728/",{"title":540,"date":541,"categories":542,"tags":543,"link":544},"LeetCode 987 - 二叉树的垂序遍历",["Date","2021-07-31T14:08:09.000Z"],[153],[155],"post/2021/20210731/",{"title":546,"date":547,"categories":548,"tags":549,"link":550},"LeetCode 1337 - 矩阵中战斗力最弱的 K 行",["Date","2021-08-01T09:49:54.000Z"],[153],[155],"post/2021/20210801/",{"title":552,"date":553,"categories":554,"tags":555,"link":556},"LeetCode 5830 - 三除数",["Date","2021-08-02T09:51:03.000Z"],[153],[155],"post/2021/20210802/",{"title":558,"date":559,"categories":560,"tags":561,"link":562},"LeetCode 743 - 网络延迟时间",["Date","2021-08-03T16:39:16.000Z"],[153],[155],"post/2021/20210803/",{"title":564,"date":565,"categories":566,"tags":567,"link":568},"MySQL - 汇总篇",["Date","2021-08-04T10:52:24.000Z"],[283],[305],"post/2021/20210804/",{"title":570,"date":571,"categories":572,"tags":573,"link":574},"LeetCode 509 - 斐波那契数",["Date","2021-08-12T16:16:27.000Z"],[153],[155],"post/2021/20210812/",{"title":576,"date":577,"categories":578,"tags":579,"link":580},"LeetCode 233 - 数字 1 的个数",["Date","2021-08-13T10:16:47.000Z"],[153],[155],"post/2021/20210813/",{"title":582,"date":583,"categories":584,"tags":585,"link":586},"LeetCode 周赛 254",["Date","2021-08-16T11:49:33.000Z"],[153],[155],"post/2021/20210816/",{"title":588,"date":589,"categories":590,"tags":592,"link":593},"有一台服务器能干什么？",["Date","2021-11-18T08:37:24.000Z"],[591],"Server",[106],"post/2021/20211118/",{"title":595,"date":596,"categories":597,"tags":598,"link":600},"十大常见排序算法",["Date","2021-11-19T08:39:37.000Z"],[153],[599],"Sort","post/2021/20211119/",{"title":602,"date":603,"categories":604,"tags":605,"link":607},"VS Code参数提示 & 常用快捷键（Java篇）",["Date","2022-02-23T21:24:01.000Z"],[97],[606],"VS Code","post/2022/20220223/",{"title":609,"date":610,"categories":611,"tags":612,"link":614},"Copilot初体验",["Date","2022-03-26T20:18:10.000Z"],[97],[613],"Copilot","post/2022/20220326/",{"title":616,"date":617,"categories":618,"tags":619,"link":620},"Java Tips",["Date","2022-05-26T10:45:23.000Z"],[112],[616],"post/2022/20220526/",{"title":622,"date":623,"categories":624,"tags":626,"link":628},"Docker Tutorial for Beginner",["Date","2022-06-01T12:18:04.000Z"],[625],"Containerization",[627],"Docker","post/2022/20220601/",{"title":630,"date":631,"categories":632,"tags":634,"link":636},"Wox Theme Backup",["Date","2022-08-14T15:05:02.000Z"],[633],"Backup",[635],"Wox","post/2022/20220810/",{"title":638,"date":639,"categories":640,"tags":641,"link":644},"Notes of Dual Boot Debian 11 and Windows 11",["Date","2022-08-29T21:03:06.000Z"],[97],[642,643],"Debian","Linux","post/2022/20220829/",{"title":646,"date":647,"categories":648,"tags":650,"link":652},"从 Windows Powershell 5 迁移到 PowerShll 7",["Date","2022-10-09T23:01:35.000Z"],[649],"Shell",[651],"powershell","post/2022/20221009/",{"title":654,"date":655,"categories":656,"tags":658,"link":659},"Kotlin Basics",["Date","2022-10-31T18:35:41.000Z"],[657],"Kotlin",[657],"post/2022/20221031/",{"title":661,"date":662,"categories":663,"tags":664,"link":666},"ChatGPT 初体验",["Date","2022-12-09T18:41:03.000Z"],[97],[665],"chatGPT","post/2022/20221209/",{"title":668,"date":669,"categories":670,"tags":671,"link":673},"Git私服的搭建记录",["Date","2023-03-12T16:10:54.000Z"],[130],[672],"git","post/2023/20230312/",{"title":675,"categories":676,"tags":677,"date":681,"link":682},"Markdown in Svelte-Blog",[97],[678,679,680],"CommonMark","GFM","MDX",["Date","2023-08-05T00:00:00.000Z"],"post/2023/20230805/",{"title":684,"date":685,"categories":686,"tags":687,"link":691},"Linux Common Editor Usage",["Date","2024-02-25T20:19:51.000Z"],[643],[688,689,690],"vi","vim","nano","post/2024/20240225/",{"title":693,"date":694,"categories":695,"tags":697,"link":698},"Use OpenSSL to Create a Self-signed Certificate",["Date","2024-03-10T23:22:45.000Z"],[696],"OpenSSL",[696],"post/2024/20240310/",{"title":700,"date":701,"categories":702,"tags":703,"link":704},"Make Redis to use SSL in SpringBoot",["Date","2024-03-10T23:41:28.000Z"],[112],[210],"post/2024/20240311/"],"uses":{},"slash":"always"},{"type":"data","data":[{"mdAstObj":1,"postMeta":463},{"type":2,"children":3,"position":457},"root",[4,20,34,47,60,89,103,132,146,157,171,180,250,264,272,285,358,402,416,429,443],{"type":5,"depth":6,"children":7,"position":16},"heading",2,[8],{"type":9,"value":10,"position":11},"text","前言",{"start":12,"end":14},{"line":6,"column":13,"offset":13},4,{"line":6,"column":15,"offset":15},6,{"start":17,"end":19},{"line":6,"column":18,"offset":18},1,{"line":6,"column":15,"offset":15},{"type":21,"children":22,"position":31},"paragraph",[23],{"type":9,"value":24,"position":25},"之前一直有想法搭建一个私服，当时主要看到普遍采取的解决方案是 Gitlab，然而启动该项目需要至少 4G 的内存，这对于服务器资源有限的人来说，十分不友好，并且 Gitlab 的管理功能基本是针对团队场景开发的，对于个人而言有些杀鸡牛刀了。",{"start":26,"end":28},{"line":13,"column":18,"offset":27},8,{"line":13,"column":29,"offset":30},121,128,{"start":32,"end":33},{"line":13,"column":18,"offset":27},{"line":13,"column":29,"offset":30},{"type":21,"children":35,"position":44},[36],{"type":9,"value":37,"position":38},"于是，便找到了另外一个方案，直接通过 Git 创建裸仓库（bare repo）。然后通过 SSH 的方式进行代码传输。该方案虽然简单，但是对于个人用户的小型服务器十分友好。",{"start":39,"end":41},{"line":15,"column":18,"offset":40},130,{"line":15,"column":42,"offset":43},87,216,{"start":45,"end":46},{"line":15,"column":18,"offset":40},{"line":15,"column":42,"offset":43},{"type":5,"depth":6,"children":48,"position":56},[49],{"type":9,"value":50,"position":51},"前提",{"start":52,"end":54},{"line":27,"column":13,"offset":53},221,{"line":27,"column":15,"offset":55},223,{"start":57,"end":59},{"line":27,"column":18,"offset":58},218,{"line":27,"column":15,"offset":55},{"type":61,"ordered":62,"start":63,"spread":62,"children":64,"position":86},"list",false,null,[65],{"type":66,"spread":62,"checked":63,"children":67,"position":82},"listItem",[68],{"type":21,"children":69,"position":79},[70],{"type":9,"value":71,"position":72},"服务器一台",{"start":73,"end":77},{"line":74,"column":75,"offset":76},10,3,227,{"line":74,"column":27,"offset":78},232,{"start":80,"end":81},{"line":74,"column":75,"offset":76},{"line":74,"column":27,"offset":78},{"start":83,"end":85},{"line":74,"column":18,"offset":84},225,{"line":74,"column":27,"offset":78},{"start":87,"end":88},{"line":74,"column":18,"offset":84},{"line":74,"column":27,"offset":78},{"type":5,"depth":6,"children":90,"position":99},[91],{"type":9,"value":92,"position":93},"步骤",{"start":94,"end":97},{"line":95,"column":13,"offset":96},12,237,{"line":95,"column":15,"offset":98},239,{"start":100,"end":102},{"line":95,"column":18,"offset":101},234,{"line":95,"column":15,"offset":98},{"type":21,"children":104,"position":129},[105,114,122],{"type":9,"value":106,"position":107},"1 首先是在服务器安装 Git。主流 Linux 发行版基本都可以通过原生的包管理器获取，这里不过多介绍，下载安装之后通过 ",{"start":108,"end":111},{"line":109,"column":18,"offset":110},14,241,{"line":109,"column":112,"offset":113},63,303,{"type":115,"value":116,"position":117},"inlineCode","git --version",{"start":118,"end":119},{"line":109,"column":112,"offset":113},{"line":109,"column":120,"offset":121},78,318,{"type":9,"value":123,"position":124}," 检查是否成功安装即可。",{"start":125,"end":126},{"line":109,"column":120,"offset":121},{"line":109,"column":127,"offset":128},90,330,{"start":130,"end":131},{"line":109,"column":18,"offset":110},{"line":109,"column":127,"offset":128},{"type":21,"children":133,"position":143},[134],{"type":9,"value":135,"position":136},"2 随后创建一个非 sudo 组的新用户专门用于存储 Git 远程仓库。这样会比较安全，即使你只是一个人使用，但万一呢，如果你实在不想创建，则可以直接到步骤 3。",{"start":137,"end":140},{"line":138,"column":18,"offset":139},16,332,{"line":138,"column":141,"offset":142},82,413,{"start":144,"end":145},{"line":138,"column":18,"offset":139},{"line":138,"column":141,"offset":142},{"type":147,"lang":148,"meta":63,"value":149,"position":150},"code","shell","# 创建 git 用户\nsudo useradd git\n# 给 git 用户设置一个密码\nsudo passwd git",{"start":151,"end":154},{"line":152,"column":18,"offset":153},18,415,{"line":155,"column":13,"offset":156},23,489,{"type":21,"children":158,"position":168},[159],{"type":9,"value":160,"position":161},"3 创建服务端的 Git bare repo。",{"start":162,"end":165},{"line":163,"column":18,"offset":164},25,491,{"line":163,"column":166,"offset":167},24,514,{"start":169,"end":170},{"line":163,"column":18,"offset":164},{"line":163,"column":166,"offset":167},{"type":147,"lang":148,"meta":63,"value":172,"position":173},"# 切换到 git 用户\nsu git\n# 进入到 git 的 home 目录\ncd ~\n# 创建一个文件夹用做仓库\nmkdir repo_name.git\n# 进入到该仓库\ncd repo_name.git\n# 初始化为裸仓库（只包含.git下的内容）\ngit init --bare",{"start":174,"end":177},{"line":175,"column":18,"offset":176},27,516,{"line":178,"column":13,"offset":179},38,672,{"type":181,"name":182,"attributes":183,"children":184,"position":243},"containerDirective","tip",{},[185,213],{"type":21,"children":186,"position":210},[187,196,203],{"type":9,"value":188,"position":189},"如果你需要将 bare repo 的默认分支切换为 main，可以使用 ",{"start":190,"end":193},{"line":191,"column":18,"offset":192},41,681,{"line":191,"column":194,"offset":195},37,717,{"type":115,"value":197,"position":198},"git symbolic-ref HEAD refs/heads/main",{"start":199,"end":200},{"line":191,"column":194,"offset":195},{"line":191,"column":201,"offset":202},76,756,{"type":9,"value":204,"position":205},"。普通仓库类型设置默认分支比较简单，可以自行百度或者参考以下链接。",{"start":206,"end":207},{"line":191,"column":201,"offset":202},{"line":191,"column":208,"offset":209},109,789,{"start":211,"end":212},{"line":191,"column":18,"offset":192},{"line":191,"column":208,"offset":209},{"type":21,"children":214,"position":240},[215,223],{"type":9,"value":216,"position":217},"参考链接：",{"start":218,"end":221},{"line":219,"column":18,"offset":220},43,791,{"line":219,"column":15,"offset":222},796,{"type":224,"title":63,"url":225,"children":226,"position":236},"link","https://stackoverflow.com/questions/42871542/how-can-i-create-a-git-repository-with-the-default-branch-name-other-than-maste",[227],{"type":9,"value":228,"position":229},"Stack Overflow - How can I create a Git repository with the default branch name other than \"master\"?",{"start":230,"end":233},{"line":219,"column":231,"offset":232},7,797,{"line":219,"column":234,"offset":235},107,897,{"start":237,"end":238},{"line":219,"column":15,"offset":222},{"line":219,"column":101,"offset":239},1024,{"start":241,"end":242},{"line":219,"column":18,"offset":220},{"line":219,"column":101,"offset":239},{"start":244,"end":247},{"line":245,"column":18,"offset":246},40,674,{"line":248,"column":13,"offset":249},44,1028,{"type":21,"children":251,"position":261},[252],{"type":9,"value":253,"position":254},"4 通过以上命令，你已经成功创建了一个远程仓库！现在你需要让用户能够 SSH 到该用户，你需要完成以下操作：",{"start":255,"end":258},{"line":256,"column":18,"offset":257},46,1030,{"line":256,"column":259,"offset":260},55,1084,{"start":262,"end":263},{"line":256,"column":18,"offset":257},{"line":256,"column":259,"offset":260},{"type":147,"lang":148,"meta":63,"value":265,"position":266},"# 本地创建 SSH 密钥，如果有可以跳过\nssh-keygen\n# 拷贝本地的公钥，通常是在用户目录下的 .ssh/id_rsa.pub\n\n# 复制该公钥到服务器的 git 用户的家目录下的 .ssh/authorized_keys 中\n# 通常情况这个文件夹（.ssh）和文件（authorized_keys）是不存在的，需要你自己创建",{"start":267,"end":270},{"line":268,"column":18,"offset":269},48,1086,{"line":259,"column":13,"offset":271},1269,{"type":21,"children":273,"position":282},[274],{"type":9,"value":275,"position":276},"5 在完成上述步骤后，你就已经完成了全部绝大部分工作了！现在分为两种情况。",{"start":277,"end":280},{"line":278,"column":18,"offset":279},57,1271,{"line":278,"column":178,"offset":281},1308,{"start":283,"end":284},{"line":278,"column":18,"offset":279},{"line":278,"column":178,"offset":281},{"type":61,"ordered":62,"start":63,"spread":62,"children":286,"position":355},[287,322],{"type":66,"spread":62,"checked":63,"children":288,"position":317},[289],{"type":21,"children":290,"position":314},[291,300,307],{"type":9,"value":292,"position":293},"5.1 第一种为你已经有一个本地仓库了，你只想 push 本地仓库到这个远程仓库，那么你只需要绑定远程仓库即可，例如 ",{"start":294,"end":297},{"line":295,"column":231,"offset":296},59,1316,{"line":295,"column":298,"offset":299},66,1375,{"type":115,"value":301,"position":302},"git remote add origin git@ip:repo_name.git",{"start":303,"end":304},{"line":295,"column":298,"offset":299},{"line":295,"column":305,"offset":306},110,1419,{"type":9,"value":308,"position":309},"。",{"start":310,"end":311},{"line":295,"column":305,"offset":306},{"line":295,"column":312,"offset":313},111,1420,{"start":315,"end":316},{"line":295,"column":231,"offset":296},{"line":295,"column":312,"offset":313},{"start":318,"end":321},{"line":295,"column":319,"offset":320},5,1314,{"line":295,"column":312,"offset":313},{"type":66,"spread":62,"checked":63,"children":323,"position":351},[324],{"type":21,"children":325,"position":348},[326,334,341],{"type":9,"value":327,"position":328},"5.2 第二种情况就是你没有本地仓库，那么你仅仅只需要通过 ",{"start":329,"end":332},{"line":330,"column":231,"offset":331},60,1427,{"line":330,"column":194,"offset":333},1457,{"type":115,"value":335,"position":336},"git clone git@ip:repo_name.git",{"start":337,"end":338},{"line":330,"column":194,"offset":333},{"line":330,"column":339,"offset":340},69,1489,{"type":9,"value":342,"position":343}," 即可拷贝空项目至本地并建立本地仓库与远程仓库的关联了。",{"start":344,"end":345},{"line":330,"column":339,"offset":340},{"line":330,"column":346,"offset":347},97,1517,{"start":349,"end":350},{"line":330,"column":231,"offset":331},{"line":330,"column":346,"offset":347},{"start":352,"end":354},{"line":330,"column":319,"offset":353},1425,{"line":330,"column":346,"offset":347},{"start":356,"end":357},{"line":295,"column":319,"offset":320},{"line":330,"column":346,"offset":347},{"type":181,"name":182,"attributes":359,"children":360,"position":396},{},[361],{"type":21,"children":362,"position":393},[363,372,379,386],{"type":9,"value":364,"position":365},"由于之前我们是直接将项目放在 git 用户的家目录下，因此这里没有涉及到相对路径，如果你的项目是在 git 用户目录下的子目录中，那么则可以改为 git 目录下的相对路径。例如仓库保存至服务端的 ",{"start":366,"end":369},{"line":367,"column":18,"offset":368},64,1527,{"line":367,"column":370,"offset":371},99,1625,{"type":115,"value":373,"position":374},"/home/git/repo/repo_name.git",{"start":375,"end":376},{"line":367,"column":370,"offset":371},{"line":367,"column":377,"offset":378},129,1655,{"type":9,"value":380,"position":381},"，那么上述的 clone 或者 remote 之后的路径就是 ",{"start":382,"end":383},{"line":367,"column":377,"offset":378},{"line":367,"column":384,"offset":385},160,1686,{"type":115,"value":387,"position":388},"repo/repo_name.git",{"start":389,"end":390},{"line":367,"column":384,"offset":385},{"line":367,"column":391,"offset":392},180,1706,{"start":394,"end":395},{"line":367,"column":18,"offset":368},{"line":367,"column":391,"offset":392},{"start":397,"end":399},{"line":112,"column":18,"offset":398},1520,{"line":400,"column":13,"offset":401},65,1710,{"type":5,"depth":6,"children":403,"position":412},[404],{"type":9,"value":405,"position":406},"最后",{"start":407,"end":410},{"line":408,"column":13,"offset":409},67,1715,{"line":408,"column":15,"offset":411},1717,{"start":413,"end":415},{"line":408,"column":18,"offset":414},1712,{"line":408,"column":15,"offset":411},{"type":21,"children":417,"position":426},[418],{"type":9,"value":419,"position":420},"稍微解释以下 bare repo。其实就是在普通仓库下的 .git 目录已经包含了 git 需要的全部信息，包括代码。这些信息会被压缩打包保存 .git 目录中，只不过没有项目结构那么直观。",{"start":421,"end":423},{"line":339,"column":18,"offset":422},1719,{"line":339,"column":424,"offset":425},96,1814,{"start":427,"end":428},{"line":339,"column":18,"offset":422},{"line":339,"column":424,"offset":425},{"type":21,"children":430,"position":440},[431],{"type":9,"value":432,"position":433},"因此对于服务端而言，保存为 bare repo，然后每次 push 至该仓库都只是重新生产 .git 目录下的文件并上传至服务端的 repo_name.git 目录中。",{"start":434,"end":437},{"line":435,"column":18,"offset":436},71,1816,{"line":435,"column":438,"offset":439},85,1900,{"start":441,"end":442},{"line":435,"column":18,"offset":436},{"line":435,"column":438,"offset":439},{"type":21,"children":444,"position":454},[445],{"type":9,"value":446,"position":447},"Enjoy the Git。",{"start":448,"end":451},{"line":449,"column":18,"offset":450},73,1902,{"line":449,"column":452,"offset":453},15,1916,{"start":455,"end":456},{"line":449,"column":18,"offset":450},{"line":449,"column":452,"offset":453},{"start":458,"end":460},{"line":18,"column":18,"offset":459},0,{"line":461,"column":18,"offset":462},74,1917,{"title":464,"date":465,"categories":466,"tags":468,"link":470},"Git私服的搭建记录",["Date","2023-03-12T16:10:54.000Z"],[467],"Git",[469],"git","post/2023/20230312/"],"uses":{"params":["slug"],"parent":1}}]}
